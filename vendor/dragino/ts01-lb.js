function decodeUplink(input) {\n var port = input.fPort;\n var bytes = input.bytes;\n var mode=(bytes[6] & 0x7C)>>2;\n var data = {};\n function datalog(i,bytes){\n var aa=(bytes[0+i]<<8 | bytes[1+i]).toString(10)/10;\n var bb=((bytes[2+i]<<8 | bytes[3+i]).toString(10)/32768.0*180).toFixed(2);\n var cc=((bytes[4+i]<<8 | bytes[5+i]).toString(10)/32768.0*180).toFixed(2);\n var dd=(bytes[6+i]&0x01)?\"OPEN\":\"CLOSE\"; \n var ee=(bytes[6+i]&0x01)?\"TRUE\":\"FLASE\"; \n var ff= getMyDate((bytes[7+i]<<24 | bytes[8+i]<<16 | bytes[9+i]<<8 | bytes[10+i]).toString(10));\n var string='['+aa+','+bb+','+cc+','+dd+','+ee+','+ff+']'+','; \n \n return string;\n}\n\n function getzf(c_num){ \n if(parseInt(c_num) < 10)\n c_num = '0' + c_num; \n\n return c_num; \n }\n\n function getMyDate(str){ \n var c_Date;\n if(str > 9999999999)\n c_Date = new Date(parseInt(str));\n else \n c_Date = new Date(parseInt(str) * 1000);\n \n var c_Year = c_Date.getFullYear(), \n c_Month = c_Date.getMonth()+1, \n c_Day = c_Date.getDate(),\n c_Hour = c_Date.getHours(), \n c_Min = c_Date.getMinutes(), \n c_Sen = c_Date.getSeconds();\n var c_Time = c_Year +'-'+ getzf(c_Month) +'-'+ getzf(c_Day) +' '+ getzf(c_Hour) +':'+ getzf(c_Min) +':'+getzf(c_Sen); \n \n return c_Time;\n }\n switch (input.fPort) {\n case 2:\n\n \n data.batV=((bytes[0]<<8 | bytes[1]) & 0x3FFF)/1000;\n \n \n data.i_flag =(bytes[2])&0x80; \n data.a_flag =(bytes[2])&0x01;\n \n value=bytes[3]<<8 | bytes[4];\n if(bytes[3] & 0x80)\n {value |= 0xFFFF0000;}\n data.temp_DS18B20=(value/10).toFixed(2);//DS18B20,temperature \n \n value=bytes[5]<<8 | bytes[6];\n if(bytes[5] & 0x80)\n {value |= 0xFFFF0000;} \n data.Roll=(value/32768.0*180).toFixed(2);\n\n value=bytes[7]<<8 | bytes[8];\n if(bytes[7] & 0x80)\n {value |= 0xFFFF0000;} \n data.Pitch=(value/32768.0*180).toFixed(2);\n \n if(bytes[9]==0)\n {\n var in_flag = \"Level\"; \n }\n else\n {\n in_flag = \"Vertical\"; \n }\n data.in_flag=in_flag;\n\n if(bytes.length==11)\n return {\n data: data,\n }\n break;\ncase 3:\n var pnack= ((bytes[6]>>7)&0x01) ? \"True\":\"False\";\n for(var i=0;i<bytes.length;i=i+11)\n {\n var data1= datalog(i,bytes);\n if(i=='0')\n data_sum=data1;\n else\n data_sum+=data1;\n }\n \n data.DATALOG=data_sum;\n data.PNACKMD=pnack;\n return {\n data: data,\n }\n \n break;\n \ncase 5:\n { \n if(bytes[0]==0x2F)\n data.SENSOR_MODEL= \"TS01-LB\";\n \n if(bytes[4]==0xff)\n data.SUB_BAND=\"NULL\";\n else\n data.SUB_BAND=bytes[4];\n \n if(bytes[3]==0x01)\n data.FREQUENCY_BAND=\"EU868\";\n else if(bytes[3]==0x02)\n data.FREQUENCY_BAND=\"US915\";\n else if(bytes[3]==0x03)\n data.FREQUENCY_BAND=\"IN865\";\n else if(bytes[3]==0x04)\n data.FREQUENCY_BAND=\"AU915\";\n else if(bytes[3]==0x05)\n data.FREQUENCY_BAND=\"KZ865\";\n else if(bytes[3]==0x06)\n data.FREQUENCY_BAND=\"RU864\";\n else if(bytes[3]==0x07)\n data.FREQUENCY_BAND=\"AS923\";\n else if(bytes[3]==0x08)\n data.FREQUENCY_BAND=\"AS923_1\";\n else if(bytes[3]==0x09)\n data.FREQUENCY_BAND=\"AS923_2\";\n else if(bytes[3]==0x0A)\n data.FREQUENCY_BAND=\"AS923_3\";\n else if(bytes[3]==0x0B)\n data.FREQUENCY_BAND=\"CN470\";\n else if(bytes[3]==0x0C)\n data.FREQUENCY_BAND=\"EU433\";\n else if(bytes[3]==0x0D)\n data.FREQUENCY_BAND=\"KR920\";\n else if(bytes[3]==0x0E)\n data.FREQUENCY_BAND=\"MA869\";\n \n data.FIRMWARE_VERSION= (bytes[1]&0x0f)+'.'+(bytes[2]>>4&0x0f)+'.'+(bytes[2]&0x0f);\n data.BAT= (bytes[5]<<8 | bytes[6])/1000;\n }\n return {\n data: data,\n }\n break;\n \n default:\n return {\n errors: [\"unknown FPort\"]\n }\n}\n}