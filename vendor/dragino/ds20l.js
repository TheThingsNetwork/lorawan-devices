function decodeUplink(input) {\n return { \n data: Decode(input.fPort, input.bytes, input.variables)\n }; \n}\nfunction Decode(fPort, bytes, variables) {\n// Decode an uplink message from a buffer\n// (array) of bytes to an object of fields.\n var i;\n var batV=0;//Battery,units:V\n var mod = 0;\n var Firmware = 0; // Firmware version; 5 bits \n var sub_band;\n var freq_band;\n var sensor; \n var firm_ver; \n var distance;\n var distance_state;\n var interrupt_count;\n var interrupt;\n var alarm;\n var dout;\n var toilet_paper;\n var limit;\n var upper_limit;\n var lower_limit;\n var do_flag;\n if(fPort==0x02)\n {\n batV= (bytes[0]<<8 | bytes[1])/1000;\n distance = (bytes[3]<<8 | bytes[4]);\n distance_state = bytes[5];\n interrupt = (bytes[2] >> 7) & 0x01;\n mod = (bytes[2] >> 6);\n if(mod == 1)\n {\n alarm = (bytes[2] >> 5) & 0x01; \n interrupt = (bytes[2] >> 4) & 0x01;\n interrupt_count = (bytes[6]<<24 | bytes[7]<<16 | bytes[8]<<8 | bytes[9]);\n return {\n battery:batV,\n distance:distance,\n distance_state:distance_state,\n interrupt_count:interrupt_count,\n interrupt:interrupt, \n alarm:alarm,\n mod:mod,\n }; \n }\n else\n {\n dout = (bytes[2] >> 4) & 0x01;\n limit = (bytes[2] >>2) & 0x01;\n alarm = (bytes[2] >> 5) & 0x01; \n do_flag = (bytes[2] >> 3) & 0x01; \n if(do_flag==1) \n {\n interrupt_count = (bytes[3]<<24 | bytes[4]<<16 | bytes[5]<<8 | bytes[6]);\n upper_limit = bytes[7]<<8 | bytes[8];\n lower_limit = bytes[9]<<8 | bytes[10]; \n return {\n battery:batV,\n interrupt_count:interrupt_count,\n mod:mod,\n threshold_flag_for_alarm:limit,\n upper_limit:upper_limit,\n lower_limit:lower_limit,\n }; \n }\n else\n {\n distance = (bytes[3]<<8 | bytes[4]);\n upper_limit = bytes[5]<<8 | bytes[6];\n lower_limit = bytes[7]<<8 | bytes[8];\n return {\n battery:batV,\n distance:distance,\n mod:mod,\n alarm:alarm,\n dout:dout,\n do_flag:do_flag,\n threshold_flag_for_alarm:limit,\n upper_limit:upper_limit,\n lower_limit:lower_limit,\n }; \n } \n \n }\n \n }\n \n if(fPort==0x05)\n {\n if(bytes[0]==0x21)\n sensor_mode=\"DS20L\";\n else\n sensor_mode=\"NULL\"; \n \n if(bytes[4]==0xff)\n sub_band=\"NULL\";\n else\n sub_band=bytes[4];\n \n if(bytes[3]==0x01)\n freq_band=\"EU868\";\n else if(bytes[3]==0x02)\n freq_band=\"US915\";\n else if(bytes[3]==0x03)\n freq_band=\"IN865\";\n else if(bytes[3]==0x04)\n freq_band=\"AU915\";\n else if(bytes[3]==0x05)\n freq_band=\"KZ865\";\n else if(bytes[3]==0x06)\n freq_band=\"RU864\";\n else if(bytes[3]==0x07)\n freq_band=\"AS923\";\n else if(bytes[3]==0x08)\n freq_band=\"AS923_1\";\n else if(bytes[3]==0x09)\n freq_band=\"AS923_2\";\n else if(bytes[3]==0x0A)\n freq_band=\"AS923_3\";\n else if(bytes[3]==0x0B)\n freq_band=\"CN470\";\n else if(bytes[3]==0x0C)\n freq_band=\"EU433\";\n else if(bytes[3]==0x0D)\n freq_band=\"KR920\";\n else if(bytes[3]==0x0E)\n freq_band=\"MA869\";\n \n firm_ver= (bytes[1]&0x0f)+'.'+(bytes[2]>>4&0x0f)+'.'+(bytes[2]&0x0f);\n alarm = bytes[5];\n batV= (bytes[6]<<8 | bytes[7])/1000;\n \n return {\n battery:batV,\n SENSOR_MODEL:sensor_mode,\n FIRMWARE_VERSION:firm_ver,\n FREQUENCY_BAND:freq_band,\n SUB_BAND:sub_band, \n SMODE:sensor,\n };\n } \n}