// https://github.com/jooby-dev/jooby-codec/blob/main/src/analog/constants/hardwareTypes.ts
const config = {
    // IMP4EU
    hardwareType: 6
};

// helper
const decode = ( fromBytes, input ) => {
    const data = {bytes: input.bytes};
    const decodeResult = fromBytes(input.bytes, config);
    const errors = [];

    if ( decodeResult.error ) {
        errors.push(decodeResult.error);
        // there may be some partially decoded result
        data.message = decodeResult.message;
    } else {
        data.message = decodeResult;
    }

    return {data, errors};
};

// will have encoder/decoder after init
let message;


/*
  Get bytes from message.

  Input is an object with the following fields:
    * data - object, must contain "commands" field
    * fPort - downlink fPort

  Output must be an object with the following fields:
    * bytes - byte array containing the downlink payload
*/
function encodeDownlink ( input ) {
    let bytes = message.downlink.toBytes(input.data.commands, config);

    return {bytes, fPort: 1};
}

/*
  Get message from bytes.

  Input is an object with the following fields:
    * bytes - byte array containing the uplink payload, e.g. [255, 230, 255, 0]
    * fPort - uplink fPort

  Output must be an object with the following fields:
    * data - object representing the decoded payload
*/
function decodeUplink ( input ) {
    return decode(message.uplink.fromBytes, input);
}

/*
  Get message from bytes.

  Input is an object with the following fields:
    * bytes - byte array containing the downlink payload, e.g. [255, 230, 255, 0]
    * fPort - downlink fPort

  Output must be an object with the following fields:
    * data - object representing the decoded payload
*/
function decodeDownlink ( input ) {
    return decode(message.downlink.fromBytes, input);
}


//#region [autogenerated jooby-codec bundle from index.js]
(function () {
    'use strict';

    const hexFormatOptions = {
      separator: ' ',
      prefix: ''
    };

    const INT8_SIZE = 1;
    const INT16_SIZE = 2;
    const INT24_SIZE = 3;
    const INT32_SIZE = 4;
    const {
      log,
      pow,
      LN2
    } = Math;
    const readFloat = (buffer, offset, isLittleEndian, mLen, bytes) => {
      var e,
        m,
        eLen = bytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        nBits = -7,
        i = isLittleEndian ? bytes - 1 : 0,
        d = isLittleEndian ? -1 : 1,
        s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 0x100 + buffer[offset + i], i += d, nBits -= 8);
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 0x100 + buffer[offset + i], i += d, nBits -= 8);
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : s ? -Infinity : Infinity;
      } else {
        m = m + pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * pow(2, e - mLen);
    };
    const writeFloat = (buffer, offset, value, isLittleEndian, mLen, bytes) => {
      var e,
        m,
        c,
        eLen = bytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0,
        i = isLittleEndian ? 0 : bytes - 1,
        d = isLittleEndian ? 1 : -1,
        s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value < 0 && (value = -value);
      if (value !== value || value === Infinity) {
        m = value !== value ? 1 : 0;
        e = eMax;
      } else {
        e = log(value) / LN2 | 0;
        if (value * (c = pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * pow(2, eBias - 1) * pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 0x100, mLen -= 8);
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 0x100, eLen -= 8);
      buffer[offset + i - d] |= s * 0x80;
    };
    const be2 = [1, 0];
    const be3 = [2, 1, 0];
    const be4 = [3, 2, 1, 0];
    const le2 = [0, 1];
    const le3 = [0, 1, 2];
    const le4 = [0, 1, 2, 3];
    const readUint8 = (buffer, offset) => buffer[offset];
    const readUint16 = (buffer, offset, isLittleEndian) => {
      const order = isLittleEndian ? le2 : be2;
      const b0 = buffer[offset + order[0]];
      const b1 = buffer[offset + order[1]] << 8;
      return b0 | b1;
    };
    const readUint24 = (buffer, offset, isLittleEndian) => {
      const order = isLittleEndian ? le3 : be3;
      const b0 = buffer[offset + order[0]];
      const b1 = buffer[offset + order[1]] << 8;
      const b2 = buffer[offset + order[2]] << 16;
      return b0 | b1 | b2;
    };
    const readUint32 = (buffer, offset, isLittleEndian) => {
      const order = isLittleEndian ? le4 : be4;
      const b0 = buffer[offset + order[3]] * 0x1000000;
      const b1 = buffer[offset + order[2]] * 0x10000;
      const b2 = buffer[offset + order[1]] * 0x100;
      const b3 = buffer[offset + order[0]];
      return b0 + b1 + b2 + b3;
    };
    const writeUint8 = (buffer, offset, value) => {
      buffer[offset] = value & 0xff;
    };
    const writeUint16 = (buffer, offset, value, isLittleEndian) => {
      const order = isLittleEndian ? le2 : be2;
      buffer[offset + order[0]] = value & 0xff;
      buffer[offset + order[1]] = value >>> 8 & 0xff;
    };
    const writeUint24 = (buffer, offset, value, isLittleEndian) => {
      const order = isLittleEndian ? le3 : be3;
      buffer[offset + order[0]] = value & 0xff;
      buffer[offset + order[1]] = value >>> 8 & 0xff;
      buffer[offset + order[2]] = value >>> 16 & 0xff;
    };
    const writeUint32 = (buffer, offset, value, isLittleEndian) => {
      const order = isLittleEndian ? le4 : be4;
      buffer[offset + order[0]] = value & 0xff;
      buffer[offset + order[1]] = value >>> 8 & 0xff;
      buffer[offset + order[2]] = value >>> 16 & 0xff;
      buffer[offset + order[3]] = value >>> 24 & 0xff;
    };
    function BinaryBuffer(dataOrLength, isLittleEndian = true) {
      if (typeof dataOrLength === 'number') {
        const bytes = new Array(dataOrLength).fill(0);
        this.data = bytes;
      } else {
        this.data = dataOrLength;
      }
      this.offset = 0;
      this.isLittleEndian = isLittleEndian;
    }
    BinaryBuffer.prototype = {
      toUint8Array() {
        return this.data;
      },
      seek(position) {
        if (position < 0 || position >= this.data.length) {
          throw new Error('Invalid position.');
        }
        this.offset = position;
      },
      setInt8(value) {
        writeUint8(this.data, this.offset, value < 0 ? value | 0x100 : value);
        this.offset += INT8_SIZE;
      },
      getInt8() {
        const result = readUint8(this.data, this.offset);
        this.offset += INT8_SIZE;
        return result & 0x80 ? result ^ -256 : result;
      },
      setUint8(value) {
        writeUint8(this.data, this.offset, value);
        this.offset += INT8_SIZE;
      },
      getUint8() {
        const result = readUint8(this.data, this.offset);
        this.offset += INT8_SIZE;
        return result;
      },
      setInt16(value, isLittleEndian = this.isLittleEndian) {
        writeUint16(this.data, this.offset, value < 0 ? value | 0x10000 : value, isLittleEndian);
        this.offset += INT16_SIZE;
      },
      getInt16(isLittleEndian = this.isLittleEndian) {
        const result = readUint16(this.data, this.offset, isLittleEndian);
        this.offset += INT16_SIZE;
        return result & 0x8000 ? result ^ -65536 : result;
      },
      setUint16(value, isLittleEndian = this.isLittleEndian) {
        writeUint16(this.data, this.offset, value, isLittleEndian);
        this.offset += INT16_SIZE;
      },
      getUint16(isLittleEndian = this.isLittleEndian) {
        const result = readUint16(this.data, this.offset, isLittleEndian);
        this.offset += INT16_SIZE;
        return result;
      },
      setInt24(value, isLittleEndian = this.isLittleEndian) {
        writeUint24(this.data, this.offset, value < 0 ? value | 0x1000000 : value, isLittleEndian);
        this.offset += INT24_SIZE;
      },
      getInt24(isLittleEndian = this.isLittleEndian) {
        const result = readUint24(this.data, this.offset, isLittleEndian);
        this.offset += INT24_SIZE;
        return result & 0x800000 ? result ^ -16777216 : result;
      },
      setUint24(value, isLittleEndian = this.isLittleEndian) {
        writeUint24(this.data, this.offset, value, isLittleEndian);
        this.offset += INT24_SIZE;
      },
      getUint24(isLittleEndian = this.isLittleEndian) {
        const result = readUint24(this.data, this.offset, isLittleEndian);
        this.offset += INT24_SIZE;
        return result;
      },
      setInt32(value, isLittleEndian = this.isLittleEndian) {
        writeUint32(this.data, this.offset, value < 0 ? value | 0x100000000 : value, isLittleEndian);
        this.offset += INT32_SIZE;
      },
      getInt32(isLittleEndian = this.isLittleEndian) {
        const result = readUint32(this.data, this.offset, isLittleEndian);
        this.offset += INT32_SIZE;
        return result & 0x80000000 ? result ^ -4294967296 : result;
      },
      setUint32(value, isLittleEndian = this.isLittleEndian) {
        writeUint32(this.data, this.offset, value, isLittleEndian);
        this.offset += INT32_SIZE;
      },
      getUint32(isLittleEndian = this.isLittleEndian) {
        const result = readUint32(this.data, this.offset, isLittleEndian);
        this.offset += INT32_SIZE;
        return result;
      },
      setFloat32(value, isLittleEndian = this.isLittleEndian) {
        writeFloat(this.data, this.offset, value, isLittleEndian, 23, 4);
        this.offset += INT32_SIZE;
      },
      getFloat32(isLittleEndian = this.isLittleEndian) {
        const result = readFloat(this.data, this.offset, isLittleEndian, 23, 4);
        this.offset += INT32_SIZE;
        return result;
      },
      setString(value) {
        this.setUint8(value.length);
        for (let index = 0; index < value.length; ++index) {
          this.setUint8(value.charCodeAt(index));
        }
      },
      getString() {
        const size = this.getUint8();
        const endIndex = this.offset + size;
        const chars = [];
        while (this.offset < endIndex) {
          chars.push(String.fromCharCode(this.getUint8()));
        }
        return chars.join('');
      },
      getBytesToOffset(offset = this.offset) {
        return this.data.slice(0, offset);
      },
      getBytesLeft() {
        return this.getBytes(this.bytesLeft);
      },
      getBytes(length, offset = this.offset) {
        this.offset = offset + length;
        return this.data.slice(offset, this.offset);
      },
      setBytes(data, offset = this.offset) {
        const bytes = this.data;
        bytes.splice(offset, data.length, ...data);
        this.data = bytes;
        this.offset = offset + data.length;
      }
    };
    Object.defineProperties(BinaryBuffer.prototype, {
      size: {
        get() {
          return this.data.length;
        }
      },
      isEmpty: {
        get() {
          if (this.offset > this.data.length) {
            throw new Error(`current offset ${this.offset} is outside the bounds of the buffer`);
          }
          return this.data.length - this.offset === 0;
        }
      },
      bytesLeft: {
        get() {
          return this.data.length - this.offset;
        }
      },
      position: {
        get() {
          return this.offset;
        }
      }
    });

    const shortCommandMask = 0xe0;
    const extraCommandMask = 0x1f;
    const fromBytes$13 = bytes => {
      if (bytes.length === 0) {
        throw new Error('Invalid buffer size');
      }
      const header = {
        shortCode: bytes[0] & shortCommandMask,
        extraCode: bytes[0] & extraCommandMask
      };
      if (header.shortCode !== 0) {
        return {
          headerSize: 1,
          commandId: bytes[0] & ~header.extraCode,
          commandSize: header.extraCode
        };
      }
      if (header.extraCode === extraCommandMask) {
        if (bytes.length < 3) {
          throw new Error('Invalid buffer size');
        }
        return {
          headerSize: 3,
          commandId: bytes[1] << 8 | extraCommandMask,
          commandSize: bytes[2]
        };
      }
      if (bytes.length < 2) {
        throw new Error('Invalid buffer size');
      }
      return {
        headerSize: 2,
        commandId: header.extraCode,
        commandSize: bytes[1]
      };
    };
    const toBytes$14 = (commandId, commandSize) => {
      if ((commandId & extraCommandMask) === 0) {
        if (commandSize > extraCommandMask) {
          throw new Error(`Wrong command id/size. Id: ${commandId}, size: ${commandSize}.`);
        }
        return [commandId | commandSize];
      }
      if (commandId > extraCommandMask) {
        return [extraCommandMask, commandId >> 8, commandSize];
      }
      return [commandId, commandSize];
    };

    const toBytes$13 = (commandId, commandBytes = []) => {
      const headerData = toBytes$14(commandId, commandBytes.length);
      return [...headerData, ...commandBytes];
    };

    const setTime2000$1 = 0x02;
    const setParameter$2 = 0x03;
    const getParameter$2 = 0x04;
    const getArchiveHours$1 = 0x05;
    const getArchiveDays$1 = 0x06;
    const getCurrent = 0x07;
    const getTime2000 = 0x09;
    const getArchiveEvents$1 = 0x0b;
    const correctTime2000$1 = 0x0c;
    const getStatus = 0x14;
    const getCurrentMc = 0x18;
    const softRestart$1 = 0x19;
    const getArchiveHoursMc$1 = 0x1a;
    const getArchiveDaysMc$1 = 0x1b;
    const dataSegment$1 = 0x1e;
    const getLmicInfo$1 = 0x21f;
    const getBatteryStatus$1 = 0x51f;
    const usWaterMeterCommand$1 = 0x71f;
    const getExAbsArchiveHoursMc$1 = 0xc1f;
    const getExAbsArchiveDaysMc$1 = 0xd1f;
    const getExAbsCurrentMc = 0xf1f;
    const writeImage$1 = 0x2a1f;
    const verifyImage$1 = 0x2b1f;
    const updateRun$1 = 0x2c1f;
    const getArchiveHoursMcEx$1 = 0x301f;
    const getChannelsStatus$1 = 0x321f;
    const getChannelsTypes$1 = 0x331f;
    const getSignalQuality = 0x341f;

    var downlinkIds = /*#__PURE__*/Object.freeze({
        __proto__: null,
        correctTime2000: correctTime2000$1,
        dataSegment: dataSegment$1,
        getArchiveDays: getArchiveDays$1,
        getArchiveDaysMc: getArchiveDaysMc$1,
        getArchiveEvents: getArchiveEvents$1,
        getArchiveHours: getArchiveHours$1,
        getArchiveHoursMc: getArchiveHoursMc$1,
        getArchiveHoursMcEx: getArchiveHoursMcEx$1,
        getBatteryStatus: getBatteryStatus$1,
        getChannelsStatus: getChannelsStatus$1,
        getChannelsTypes: getChannelsTypes$1,
        getCurrent: getCurrent,
        getCurrentMc: getCurrentMc,
        getExAbsArchiveDaysMc: getExAbsArchiveDaysMc$1,
        getExAbsArchiveHoursMc: getExAbsArchiveHoursMc$1,
        getExAbsCurrentMc: getExAbsCurrentMc,
        getLmicInfo: getLmicInfo$1,
        getParameter: getParameter$2,
        getSignalQuality: getSignalQuality,
        getStatus: getStatus,
        getTime2000: getTime2000,
        setParameter: setParameter$2,
        setTime2000: setTime2000$1,
        softRestart: softRestart$1,
        updateRun: updateRun$1,
        usWaterMeterCommand: usWaterMeterCommand$1,
        verifyImage: verifyImage$1,
        writeImage: writeImage$1
    });

    var invertObject = source => {
      const target = {};
      for (const property in source) {
        const value = source[property];
        target[value] = property;
      }
      return target;
    };

    var downlinkNames = invertObject(downlinkIds);

    const id$10 = correctTime2000$1;
    downlinkNames[correctTime2000$1];
    const COMMAND_BODY_SIZE$y = 2;
    const fromBytes$12 = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$y) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const parameters = {
        sequenceNumber: buffer.getUint8(),
        seconds: buffer.getInt8()
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    const toBytes$12 = parameters => {
      const {
        sequenceNumber,
        seconds
      } = parameters;
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$y, false);
      buffer.setUint8(sequenceNumber);
      buffer.setInt8(seconds);
      return toBytes$13(id$10, buffer.data);
    };

    const fromObject = (bitMask = {}, booleanObject = {}) => {
      let result = 0;
      for (const name in booleanObject) {
        if (name in bitMask && booleanObject[name]) {
          result |= bitMask[name];
        }
      }
      return result;
    };
    const toObject = (bitMask = {}, value = 0) => {
      const result = {};
      for (const name in bitMask) {
        result[name] = (value & bitMask[name]) !== 0;
      }
      return result;
    };
    const extractBits = (value, bitsNumber, startIndex) => (1 << bitsNumber) - 1 & value >> startIndex - 1;
    const fillBits = (value, bitsNumber, startIndex, valueToSet) => {
      const mask = (1 << bitsNumber) - 1 << startIndex - 1;
      let newValueToSet = valueToSet;
      let result = value;
      result &= ~mask;
      newValueToSet <<= startIndex - 1;
      result |= newValueToSet;
      return result;
    };

    var getHexFromBytes = (bytes, options = {}) => {
      const {
        separator,
        prefix
      } = Object.assign({}, hexFormatOptions, options);
      return bytes.map(byte => `${prefix}${byte.toString(16).padStart(2, '0')}`).join(separator);
    };

    var getBytesFromHex = hex => {
      let cleanHex = hex.trim();
      if (!cleanHex) {
        return [];
      }
      cleanHex = cleanHex.replace(/0x/g, '').split(/\s+/).map(byte => byte.padStart(2, '0')).join('');
      if (cleanHex.length % 2 !== 0) {
        cleanHex = `0${cleanHex}`;
      }
      const resultLength = cleanHex.length / 2;
      const bytes = new Array(resultLength);
      for (let index = 0; index < resultLength; index++) {
        bytes[index] = parseInt(cleanHex.substring(index * 2, index * 2 + 2), 16);
      }
      return bytes;
    };

    var roundNumber = (value, decimalPlaces = 4) => {
      const places = Math.pow(10, decimalPlaces);
      return Math.round(value * places * (1 + Number.EPSILON)) / places;
    };

    const INITIAL_YEAR_TIMESTAMP = 946684800000;
    const MILLISECONDS_IN_SECONDS = 1000;
    const getDateFromTime2000 = time2000 => new Date(INITIAL_YEAR_TIMESTAMP + time2000 * MILLISECONDS_IN_SECONDS);
    const getTime2000FromDate = date => (date.getTime() - INITIAL_YEAR_TIMESTAMP) / MILLISECONDS_IN_SECONDS;

    const GASI1 = 1;
    const GASI2 = 2;
    const GASI3 = 3;
    const NOVATOR = 4;
    const IMP2EU = 5;
    const IMP4EU = 6;
    const MTXLORA = 7;
    const IMP2AS = 8;
    const IMP2IN = 9;
    const IMP4IN = 10;
    const ELIMP = 11;
    const GASIC = 12;
    const US_WATER = 13;
    const PLC2LORA = 14;
    const LORA = 21;
    const NBIOT = 24;

    const REPORTING_DATA_INTERVAL = 1;
    const DAY_CHECKOUT_HOUR = 4;
    const REPORTING_DATA_TYPE = 5;
    const PRIORITY_DATA_DELIVERY_TYPE = 8;
    const ACTIVATION_METHOD = 9;
    const BATTERY_DEPASSIVATION_INFO = 10;
    const BATTERY_MINIMAL_LOAD_TIME = 11;
    const CHANNELS_CONFIG = 13;
    const RX2_CONFIG = 18;
    const ABSOLUTE_DATA = 23;
    const ABSOLUTE_DATA_ENABLE = 24;
    const SERIAL_NUMBER = 25;
    const GEOLOCATION = 26;
    const EXTRA_FRAME_INTERVAL = 28;
    const ABSOLUTE_DATA_MULTI_CHANNEL = 29;
    const ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL = 30;
    const PULSE_CHANNELS_SCAN_CONFIG = 31;
    const PULSE_CHANNELS_SET_CONFIG = 32;
    const BATTERY_DEPASSIVATION_CONFIG = 33;
    const MQTT_SESSION_CONFIG = 34;
    const MQTT_BROKER_ADDRESS = 35;
    const MQTT_SSL_ENABLE = 36;
    const MQTT_TOPIC_PREFIX = 37;
    const MQTT_DATA_RECEIVE_CONFIG = 38;
    const MQTT_DATA_SEND_CONFIG = 39;
    const NBIOT_SSL_CONFIG = 40;
    const NBIOT_SSL_CACERT_WRITE = 41;
    const NBIOT_SSL_CACERT_SET = 42;
    const NBIOT_SSL_CLIENT_CERT_WRITE = 43;
    const NBIOT_SSL_CLIENT_CERT_SET = 44;
    const NBIOT_SSL_CLIENT_KEY_WRITE = 45;
    const NBIOT_SSL_CLIENT_KEY_SET = 46;
    const NBIOT_DEVICE_SOFTWARE_UPDATE = 47;
    const NBIOT_MODULE_FIRMWARE_UPDATE = 48;
    const REPORTING_DATA_CONFIG = 49;
    const EVENTS_CONFIG = 50;
    const NBIOT_MODULE_INFO = 51;
    const NBIOT_BANDS = 52;
    const NBIOT_APN = 53;
    const NBIOT_LED_INDICATION = 54;
    const NBIOT_SIM = 55;
    const CHANNEL_TYPE = 56;
    const EXTRA_PAYLOAD_ENABLE = 57;
    const TIME_SYNCHRONIZATION_PERIOD_VIA_MAC = 58;
    const KEEP_LORA_CONNECTION_ON_REMOVAL = 59;
    const NBIOT_NTP_SERVER = 60;
    const ACTIVATE_MODULE = 61;

    var deviceParameters = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ABSOLUTE_DATA: ABSOLUTE_DATA,
        ABSOLUTE_DATA_ENABLE: ABSOLUTE_DATA_ENABLE,
        ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL: ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL,
        ABSOLUTE_DATA_MULTI_CHANNEL: ABSOLUTE_DATA_MULTI_CHANNEL,
        ACTIVATE_MODULE: ACTIVATE_MODULE,
        ACTIVATION_METHOD: ACTIVATION_METHOD,
        BATTERY_DEPASSIVATION_CONFIG: BATTERY_DEPASSIVATION_CONFIG,
        BATTERY_DEPASSIVATION_INFO: BATTERY_DEPASSIVATION_INFO,
        BATTERY_MINIMAL_LOAD_TIME: BATTERY_MINIMAL_LOAD_TIME,
        CHANNELS_CONFIG: CHANNELS_CONFIG,
        CHANNEL_TYPE: CHANNEL_TYPE,
        DAY_CHECKOUT_HOUR: DAY_CHECKOUT_HOUR,
        EVENTS_CONFIG: EVENTS_CONFIG,
        EXTRA_FRAME_INTERVAL: EXTRA_FRAME_INTERVAL,
        EXTRA_PAYLOAD_ENABLE: EXTRA_PAYLOAD_ENABLE,
        GEOLOCATION: GEOLOCATION,
        KEEP_LORA_CONNECTION_ON_REMOVAL: KEEP_LORA_CONNECTION_ON_REMOVAL,
        MQTT_BROKER_ADDRESS: MQTT_BROKER_ADDRESS,
        MQTT_DATA_RECEIVE_CONFIG: MQTT_DATA_RECEIVE_CONFIG,
        MQTT_DATA_SEND_CONFIG: MQTT_DATA_SEND_CONFIG,
        MQTT_SESSION_CONFIG: MQTT_SESSION_CONFIG,
        MQTT_SSL_ENABLE: MQTT_SSL_ENABLE,
        MQTT_TOPIC_PREFIX: MQTT_TOPIC_PREFIX,
        NBIOT_APN: NBIOT_APN,
        NBIOT_BANDS: NBIOT_BANDS,
        NBIOT_DEVICE_SOFTWARE_UPDATE: NBIOT_DEVICE_SOFTWARE_UPDATE,
        NBIOT_LED_INDICATION: NBIOT_LED_INDICATION,
        NBIOT_MODULE_FIRMWARE_UPDATE: NBIOT_MODULE_FIRMWARE_UPDATE,
        NBIOT_MODULE_INFO: NBIOT_MODULE_INFO,
        NBIOT_NTP_SERVER: NBIOT_NTP_SERVER,
        NBIOT_SIM: NBIOT_SIM,
        NBIOT_SSL_CACERT_SET: NBIOT_SSL_CACERT_SET,
        NBIOT_SSL_CACERT_WRITE: NBIOT_SSL_CACERT_WRITE,
        NBIOT_SSL_CLIENT_CERT_SET: NBIOT_SSL_CLIENT_CERT_SET,
        NBIOT_SSL_CLIENT_CERT_WRITE: NBIOT_SSL_CLIENT_CERT_WRITE,
        NBIOT_SSL_CLIENT_KEY_SET: NBIOT_SSL_CLIENT_KEY_SET,
        NBIOT_SSL_CLIENT_KEY_WRITE: NBIOT_SSL_CLIENT_KEY_WRITE,
        NBIOT_SSL_CONFIG: NBIOT_SSL_CONFIG,
        PRIORITY_DATA_DELIVERY_TYPE: PRIORITY_DATA_DELIVERY_TYPE,
        PULSE_CHANNELS_SCAN_CONFIG: PULSE_CHANNELS_SCAN_CONFIG,
        PULSE_CHANNELS_SET_CONFIG: PULSE_CHANNELS_SET_CONFIG,
        REPORTING_DATA_CONFIG: REPORTING_DATA_CONFIG,
        REPORTING_DATA_INTERVAL: REPORTING_DATA_INTERVAL,
        REPORTING_DATA_TYPE: REPORTING_DATA_TYPE,
        RX2_CONFIG: RX2_CONFIG,
        SERIAL_NUMBER: SERIAL_NUMBER,
        TIME_SYNCHRONIZATION_PERIOD_VIA_MAC: TIME_SYNCHRONIZATION_PERIOD_VIA_MAC
    });

    var deviceParameterNames = invertObject(deviceParameters);

    const EMPTY_VALUE = 0xffffffff;

    const IDLE = 0;
    const PULSE_SENSOR = 1;
    const POWER_CHANNEL = 2;
    const BINARY_SENSOR = 3;
    const TEMPERATURE_SENSOR = 4;

    var channelTypes = /*#__PURE__*/Object.freeze({
        __proto__: null,
        BINARY_SENSOR: BINARY_SENSOR,
        IDLE: IDLE,
        POWER_CHANNEL: POWER_CHANNEL,
        PULSE_SENSOR: PULSE_SENSOR,
        TEMPERATURE_SENSOR: TEMPERATURE_SENSOR
    });

    const SF12B125 = 0;
    const SF11B125 = 1;
    const SF10B125 = 2;
    const SF9B125 = 3;
    const SF8B125 = 4;
    const SF7B125 = 5;
    const SF7B250 = 6;

    var rx2SpreadFactors = /*#__PURE__*/Object.freeze({
        __proto__: null,
        SF10B125: SF10B125,
        SF11B125: SF11B125,
        SF12B125: SF12B125,
        SF7B125: SF7B125,
        SF7B250: SF7B250,
        SF8B125: SF8B125,
        SF9B125: SF9B125
    });

    var spreadFactorNames = invertObject(rx2SpreadFactors);

    const INITIAL_YEAR = 2000;
    const MONTH_BIT_SIZE = 4;
    const DATE_BIT_SIZE = 5;
    const YEAR_START_INDEX = 1;
    const UNKNOWN_BATTERY_VOLTAGE = 4095;
    const EXTEND_BIT_MASK = 0x80;
    const LAST_BIT_INDEX = 7;
    const DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT = 600;
    const PARAMETER_RX2_FREQUENCY_COEFFICIENT = 100;
    const SERIAL_NUMBER_SIZE = 6;
    const MAGNETIC_INFLUENCE_BIT_INDEX = 8;
    const LEGACY_HOUR_COUNTER_SIZE = 2 + 4;
    const LEGACY_HOUR_DIFF_SIZE = 2;
    const GAS_HARDWARE_TYPES = [GASI2, GASI3, GASI1, GASIC, NBIOT];
    const TWO_CHANNELS_HARDWARE_TYPES = [IMP2AS, IMP2EU, IMP2IN, NOVATOR];
    const ELIMP_HARDWARE_TYPES = [ELIMP];
    const FOUR_CHANNELS_HARDWARE_TYPES = [IMP4EU, IMP4IN];
    const MTX_HARDWARE_TYPES = [MTXLORA];
    const TWO_BYTES_HARDWARE_TYPES = [...FOUR_CHANNELS_HARDWARE_TYPES, ...MTX_HARDWARE_TYPES];
    const gasBitMask = {
      isBatteryLow: Math.pow(2, 0),
      isMagneticInfluence: Math.pow(2, 1),
      isButtonReleased: Math.pow(2, 2),
      isConnectionLost: Math.pow(2, 3)
    };
    const twoChannelBitMask = {
      isBatteryLow: Math.pow(2, 0),
      isConnectionLost: Math.pow(2, 3),
      isFirstChannelInactive: Math.pow(2, 4),
      isSecondChannelInactive: Math.pow(2, 5)
    };
    const elimpBitMask = {
      isConnectionLost: Math.pow(2, 3)
    };
    const fourChannelBitMask = {
      isBatteryLow: Math.pow(2, 0),
      isConnectionLost: Math.pow(2, 3),
      isFirstChannelInactive: Math.pow(2, 4),
      isSecondChannelInactive: Math.pow(2, 5),
      isThirdChannelInactive: Math.pow(2, 6),
      isForthChannelInactive: Math.pow(2, 8)
    };
    const mtxBitMask = {
      isMeterCaseOpen: Math.pow(2, 0),
      isMagneticInfluence: Math.pow(2, 1),
      isParametersSetRemotely: Math.pow(2, 2),
      isParametersSetLocally: Math.pow(2, 3),
      isMeterProgramRestarted: Math.pow(2, 4),
      isLockedOut: Math.pow(2, 5),
      isTimeSet: Math.pow(2, 6),
      isTimeCorrected: Math.pow(2, 7),
      isMeterFailure: Math.pow(2, 8),
      isMeterTerminalBoxOpen: Math.pow(2, 9),
      isModuleCompartmentOpen: Math.pow(2, 10),
      isTariffPlanChanged: Math.pow(2, 11),
      isNewTariffPlanReceived: Math.pow(2, 12)
    };
    const usWaterMeterEventBitMask = {
      transportMode: 0x01,
      frequencyOutput: 0x02,
      reverseFlow: 0x04,
      tamperBreak: 0x08,
      leakage: 0x10,
      pipeBreak: 0x20,
      pipeEmpty: 0x40,
      batteryDischarge: 0x80
    };
    const getChannelTypeSize = ({
      type
    }) => {
      let size = 1;
      switch (type) {
        case IDLE:
        case PULSE_SENSOR:
        case POWER_CHANNEL:
          break;
        case BINARY_SENSOR:
          size += 2;
          break;
        case TEMPERATURE_SENSOR:
          size += 5;
          break;
      }
      return size;
    };
    const parametersSizeMap = {
      [REPORTING_DATA_INTERVAL]: 1 + 4,
      [DAY_CHECKOUT_HOUR]: 1 + 1,
      [REPORTING_DATA_TYPE]: 1 + 1,
      [PRIORITY_DATA_DELIVERY_TYPE]: 1 + 1,
      [ACTIVATION_METHOD]: 1 + 1,
      [BATTERY_DEPASSIVATION_INFO]: 1 + 6,
      [BATTERY_MINIMAL_LOAD_TIME]: 1 + 4,
      [CHANNELS_CONFIG]: 1 + 1,
      [RX2_CONFIG]: 1 + 4,
      [ABSOLUTE_DATA]: 1 + 9,
      [ABSOLUTE_DATA_ENABLE]: 1 + 1,
      [SERIAL_NUMBER]: 1 + 6,
      [GEOLOCATION]: 1 + 10,
      [EXTRA_FRAME_INTERVAL]: 1 + 2,
      [ABSOLUTE_DATA_MULTI_CHANNEL]: 1 + 10,
      [ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL]: 1 + 2,
      [PULSE_CHANNELS_SCAN_CONFIG]: 1 + 3,
      [PULSE_CHANNELS_SET_CONFIG]: 1 + 1,
      [BATTERY_DEPASSIVATION_CONFIG]: 1 + 4,
      [MQTT_SSL_ENABLE]: 1 + 1,
      [MQTT_DATA_RECEIVE_CONFIG]: 1 + 3,
      [MQTT_DATA_SEND_CONFIG]: 1 + 3,
      [NBIOT_SSL_CONFIG]: 1 + 2,
      [NBIOT_SSL_CACERT_SET]: 1 + 4,
      [NBIOT_SSL_CLIENT_CERT_SET]: 1 + 4,
      [NBIOT_SSL_CLIENT_KEY_SET]: 1 + 4,
      [REPORTING_DATA_CONFIG]: 1 + 4,
      [EVENTS_CONFIG]: 1 + 3,
      [NBIOT_LED_INDICATION]: 1 + 2,
      [NBIOT_SIM]: 1 + 3,
      [EXTRA_PAYLOAD_ENABLE]: 1 + 1,
      [TIME_SYNCHRONIZATION_PERIOD_VIA_MAC]: 1 + 4,
      [KEEP_LORA_CONNECTION_ON_REMOVAL]: 1 + 1,
      [ACTIVATE_MODULE]: 1 + 1
    };
    const fourChannelsBitMask = {
      channel1: Math.pow(2, 0),
      channel2: Math.pow(2, 1),
      channel3: Math.pow(2, 2),
      channel4: Math.pow(2, 3)
    };
    const getChannelsMaskFromNumber = value => {
      const object = toObject(fourChannelsBitMask, value);
      return {
        channel1: object.channel1,
        channel2: object.channel2,
        channel3: object.channel3,
        channel4: object.channel4
      };
    };
    const setChannelsMaskToNumber = channelsMask => {
      const {
        channel1,
        channel2,
        channel3,
        channel4
      } = channelsMask;
      return fromObject(fourChannelsBitMask, {
        channel1,
        channel2,
        channel3,
        channel4
      });
    };
    const getChannelsMask = buffer => getChannelsMaskFromNumber(buffer.getUint8());
    const setChannelsMask = (buffer, channelsMask) => buffer.setUint8(setChannelsMaskToNumber(channelsMask));
    const byteToPulseCoefficientMap = {
      128: 1,
      129: 5,
      130: 10,
      131: 100,
      132: 1000,
      133: 10000,
      134: 100000
    };
    const pulseCoefficientToByteMap = invertObject(byteToPulseCoefficientMap);
    const isMSBSet = value => !!(value & 0x80);
    const getNbiotSslWrite = buffer => ({
      size: buffer.getUint16(),
      position: buffer.getUint16(),
      chunk: buffer.getBytesLeft()
    });
    const setNbiotSslWrite = (buffer, parameter) => {
      if (parameter.size !== parameter.chunk.length) {
        throw new Error('ssl chunk size parameter doesn\'t match actual ssl chunk size');
      }
      buffer.setUint16(parameter.size);
      buffer.setUint16(parameter.position);
      buffer.setBytes(parameter.chunk);
    };
    const getNbiotSslSet = buffer => ({
      crc32: buffer.getUint32()
    });
    const setNbiotSslSet = (buffer, parameter) => {
      buffer.setUint32(parameter.crc32);
    };
    const deviceParameterConvertersMap = {
      [REPORTING_DATA_INTERVAL]: {
        get: buffer => ({
          specialSchedulePeriod: buffer.getUint8() * DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT,
          firstDaysSpecialSchedule: buffer.getUint8(),
          lastDaysSpecialSchedule: buffer.getUint8(),
          period: buffer.getUint8() * DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.specialSchedulePeriod / DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT);
          buffer.setUint8(parameter.firstDaysSpecialSchedule);
          buffer.setUint8(parameter.lastDaysSpecialSchedule);
          buffer.setUint8(parameter.period / DATA_SENDING_INTERVAL_SECONDS_COEFFICIENT);
        }
      },
      [DAY_CHECKOUT_HOUR]: {
        get: buffer => ({
          value: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.value);
        }
      },
      [REPORTING_DATA_TYPE]: {
        get: buffer => ({
          type: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.type);
        }
      },
      [PRIORITY_DATA_DELIVERY_TYPE]: {
        get: buffer => ({
          value: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.value);
        }
      },
      [ACTIVATION_METHOD]: {
        get: buffer => ({
          type: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.type);
        }
      },
      [BATTERY_DEPASSIVATION_INFO]: {
        get: buffer => ({
          loadTime: buffer.getUint16(),
          internalResistance: buffer.getUint16(),
          lowVoltage: buffer.getUint16()
        }),
        set: (buffer, parameter) => {
          buffer.setUint16(parameter.loadTime);
          buffer.setUint16(parameter.internalResistance);
          buffer.setUint16(parameter.lowVoltage);
        }
      },
      [BATTERY_MINIMAL_LOAD_TIME]: {
        get: buffer => ({
          value: buffer.getUint32()
        }),
        set: (buffer, parameter) => {
          buffer.setUint32(parameter.value);
        }
      },
      [CHANNELS_CONFIG]: {
        get: buffer => ({
          value: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          if (parameter.value < 0 || parameter.value > 18) {
            throw new Error('channels config must be between 0-18');
          }
          buffer.setUint8(parameter.value);
        }
      },
      [RX2_CONFIG]: {
        get: buffer => {
          const spreadFactor = buffer.getUint8();
          const spreadFactorName = spreadFactorNames[spreadFactor];
          const frequency = buffer.getUint24() * PARAMETER_RX2_FREQUENCY_COEFFICIENT;
          return {
            spreadFactor,
            spreadFactorName,
            frequency
          };
        },
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.spreadFactor);
          buffer.setUint24(parameter.frequency / PARAMETER_RX2_FREQUENCY_COEFFICIENT);
        }
      },
      [ABSOLUTE_DATA]: {
        get: buffer => ({
          meterValue: buffer.getUint32(),
          pulseCoefficient: getPulseCoefficient(buffer),
          value: buffer.getUint32()
        }),
        set: (buffer, parameter) => {
          buffer.setUint32(parameter.meterValue);
          setPulseCoefficient(buffer, parameter.pulseCoefficient);
          buffer.setUint32(parameter.value);
        }
      },
      [ABSOLUTE_DATA_ENABLE]: {
        get: buffer => ({
          state: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.state);
        }
      },
      [SERIAL_NUMBER]: {
        get: buffer => ({
          value: getHexFromBytes(buffer.getBytes(SERIAL_NUMBER_SIZE))
        }),
        set: (buffer, parameter) => {
          getBytesFromHex(parameter.value).forEach(byte => buffer.setUint8(byte));
        }
      },
      [GEOLOCATION]: {
        get: buffer => ({
          latitude: roundNumber(buffer.getFloat32()),
          longitude: roundNumber(buffer.getFloat32()),
          altitude: roundNumber(buffer.getUint16())
        }),
        set: (buffer, parameter) => {
          buffer.setFloat32(roundNumber(parameter.latitude));
          buffer.setFloat32(roundNumber(parameter.longitude));
          buffer.setUint16(roundNumber(parameter.altitude));
        }
      },
      [EXTRA_FRAME_INTERVAL]: {
        get: buffer => ({
          value: buffer.getUint16()
        }),
        set: (buffer, parameter) => {
          buffer.setUint16(parameter.value);
        }
      },
      [ABSOLUTE_DATA_MULTI_CHANNEL]: {
        get: buffer => ({
          channel: getChannelValue(buffer),
          meterValue: buffer.getUint32(),
          pulseCoefficient: getPulseCoefficient(buffer),
          value: buffer.getUint32()
        }),
        set: (buffer, parameter) => {
          setChannelValue(buffer, parameter.channel);
          buffer.setUint32(parameter.meterValue);
          setPulseCoefficient(buffer, parameter.pulseCoefficient);
          buffer.setUint32(parameter.value);
        }
      },
      [ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL]: {
        get: buffer => ({
          channel: getChannelValue(buffer),
          state: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          setChannelValue(buffer, parameter.channel);
          buffer.setUint8(parameter.state);
        }
      },
      [PULSE_CHANNELS_SCAN_CONFIG]: {
        get: buffer => ({
          channelList: getChannels(buffer),
          pullUpTime: buffer.getUint8(),
          scanTime: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          if (parameter.pullUpTime < 17) {
            throw new Error('minimal value for pullUpTime - 17');
          }
          if (parameter.scanTime < 15) {
            throw new Error('minimal value for scanTime - 15');
          }
          setChannels(buffer, parameter.channelList.map(index => ({
            index
          })));
          buffer.setUint8(parameter.pullUpTime);
          buffer.setUint8(parameter.scanTime);
        }
      },
      [PULSE_CHANNELS_SET_CONFIG]: {
        get: getChannelsMask,
        set: setChannelsMask
      },
      [BATTERY_DEPASSIVATION_CONFIG]: {
        get: buffer => ({
          resistanceStartThreshold: buffer.getUint16(),
          resistanceStopThreshold: buffer.getUint16()
        }),
        set: (buffer, parameter) => {
          buffer.setUint16(parameter.resistanceStartThreshold);
          buffer.setUint16(parameter.resistanceStopThreshold);
        }
      },
      [MQTT_SESSION_CONFIG]: {
        get: buffer => ({
          clientId: buffer.getString(),
          username: buffer.getString(),
          password: buffer.getString(),
          cleanSession: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setString(parameter.clientId);
          buffer.setString(parameter.username);
          buffer.setString(parameter.password);
          buffer.setUint8(parameter.cleanSession);
        }
      },
      [MQTT_BROKER_ADDRESS]: {
        get: buffer => ({
          hostName: buffer.getString(),
          port: buffer.getUint16()
        }),
        set: (buffer, parameter) => {
          buffer.setString(parameter.hostName);
          buffer.setUint16(parameter.port);
        }
      },
      [MQTT_SSL_ENABLE]: {
        get: buffer => ({
          enable: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.enable);
        }
      },
      [MQTT_TOPIC_PREFIX]: {
        get: buffer => ({
          topicPrefix: buffer.getString()
        }),
        set: (buffer, parameter) => {
          buffer.setString(parameter.topicPrefix);
        }
      },
      [MQTT_DATA_RECEIVE_CONFIG]: {
        get: buffer => ({
          qos: buffer.getUint8(),
          count: buffer.getUint8(),
          timeout: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.qos);
          buffer.setUint8(parameter.count);
          buffer.setUint8(parameter.timeout);
        }
      },
      [MQTT_DATA_SEND_CONFIG]: {
        get: buffer => ({
          qos: buffer.getUint8(),
          retain: buffer.getUint8(),
          newestSendFirst: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.qos);
          buffer.setUint8(parameter.retain);
          buffer.setUint8(parameter.newestSendFirst);
        }
      },
      [NBIOT_SSL_CONFIG]: {
        get: buffer => ({
          securityLevel: buffer.getUint8(),
          version: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.securityLevel);
          buffer.setUint8(parameter.version);
        }
      },
      [NBIOT_SSL_CACERT_WRITE]: {
        get: getNbiotSslWrite,
        set: setNbiotSslWrite
      },
      [NBIOT_SSL_CACERT_SET]: {
        get: getNbiotSslSet,
        set: setNbiotSslSet
      },
      [NBIOT_SSL_CLIENT_CERT_WRITE]: {
        get: getNbiotSslWrite,
        set: setNbiotSslWrite
      },
      [NBIOT_SSL_CLIENT_CERT_SET]: {
        get: getNbiotSslSet,
        set: setNbiotSslSet
      },
      [NBIOT_SSL_CLIENT_KEY_WRITE]: {
        get: getNbiotSslWrite,
        set: setNbiotSslWrite
      },
      [NBIOT_SSL_CLIENT_KEY_SET]: {
        get: getNbiotSslSet,
        set: setNbiotSslSet
      },
      [NBIOT_DEVICE_SOFTWARE_UPDATE]: {
        get: buffer => ({
          softwareImageUrl: buffer.getString()
        }),
        set: (buffer, parameter) => {
          buffer.setString(parameter.softwareImageUrl);
        }
      },
      [NBIOT_MODULE_FIRMWARE_UPDATE]: {
        get: buffer => ({
          moduleFirmwareImageUrl: buffer.getString()
        }),
        set: (buffer, parameter) => {
          buffer.setString(parameter.moduleFirmwareImageUrl);
        }
      },
      [REPORTING_DATA_CONFIG]: {
        get: buffer => ({
          dataType: buffer.getUint8(),
          hour: buffer.getUint8(),
          minutes: buffer.getUint8(),
          countToSend: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.dataType);
          buffer.setUint8(parameter.hour);
          buffer.setUint8(parameter.minutes);
          buffer.setUint8(parameter.countToSend);
        }
      },
      [EVENTS_CONFIG]: {
        get: buffer => ({
          eventId: buffer.getUint8(),
          sendEvent: buffer.getUint8(),
          saveEvent: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.eventId);
          buffer.setUint8(parameter.sendEvent);
          buffer.setUint8(parameter.saveEvent);
        }
      },
      [NBIOT_MODULE_INFO]: {
        get: buffer => ({
          moduleInfo: buffer.getString()
        }),
        set: (buffer, parameter) => {
          buffer.setString(parameter.moduleInfo);
        }
      },
      [NBIOT_BANDS]: {
        get: buffer => {
          const count = buffer.getUint8();
          const bands = [];
          for (let index = 0; index < count; index++) {
            bands.push(buffer.getUint8());
          }
          return {
            bands
          };
        },
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.bands.length);
          for (const band of parameter.bands) {
            buffer.setUint8(band);
          }
        }
      },
      [NBIOT_APN]: {
        get: buffer => ({
          apn: buffer.getString()
        }),
        set: (buffer, parameter) => {
          buffer.setString(parameter.apn);
        }
      },
      [NBIOT_LED_INDICATION]: {
        get: buffer => ({
          enableLed: buffer.getUint8(),
          enableNbiotNetworkLed: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.enableLed);
          buffer.setUint8(parameter.enableNbiotNetworkLed);
        }
      },
      [NBIOT_SIM]: {
        get: buffer => ({
          enable: buffer.getUint8(),
          pin: buffer.getUint16()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.enable);
          buffer.setUint16(parameter.pin);
        }
      },
      [CHANNEL_TYPE]: {
        get: buffer => getChannelType(buffer),
        set: (buffer, parameter) => setChannelType(buffer, parameter)
      },
      [EXTRA_PAYLOAD_ENABLE]: {
        get: buffer => ({
          enable: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.enable);
        }
      },
      [TIME_SYNCHRONIZATION_PERIOD_VIA_MAC]: {
        get: buffer => ({
          period: buffer.getUint32()
        }),
        set: (buffer, parameter) => {
          buffer.setUint32(parameter.period);
        }
      },
      [KEEP_LORA_CONNECTION_ON_REMOVAL]: {
        get: buffer => ({
          value: buffer.getUint8() !== 0
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.value ? 1 : 0);
        }
      },
      [NBIOT_NTP_SERVER]: {
        get: buffer => ({
          server: buffer.getString(),
          port: buffer.getUint16()
        }),
        set: (buffer, parameter) => {
          buffer.setString(parameter.server);
          buffer.setUint16(parameter.port);
        }
      },
      [ACTIVATE_MODULE]: {
        get: buffer => ({
          enable: buffer.getUint8()
        }),
        set: (buffer, parameter) => {
          buffer.setUint8(parameter.enable);
        }
      }
    };
    const getEventStatusSize = hardwareType => TWO_BYTES_HARDWARE_TYPES.indexOf(hardwareType) !== -1 ? 2 : 1;
    const getParameterSize = parameter => {
      let size;
      let data;
      switch (parameter.id) {
        case MQTT_SESSION_CONFIG:
          data = parameter.data;
          size = 1 + 1;
          size += data.clientId.length + 1;
          size += data.username.length + 1;
          size += data.password.length + 1;
          break;
        case MQTT_BROKER_ADDRESS:
          data = parameter.data;
          size = 1 + 2;
          size += data.hostName.length + 1;
          break;
        case MQTT_TOPIC_PREFIX:
          data = parameter.data;
          size = 1;
          size += data.topicPrefix.length + 1;
          break;
        case NBIOT_SSL_CACERT_WRITE:
        case NBIOT_SSL_CLIENT_CERT_WRITE:
        case NBIOT_SSL_CLIENT_KEY_WRITE:
          data = parameter.data;
          size = 1 + 2 + 2;
          size += data.chunk.length;
          break;
        case NBIOT_DEVICE_SOFTWARE_UPDATE:
          data = parameter.data;
          size = 1;
          size += data.softwareImageUrl.length + 1;
          break;
        case NBIOT_MODULE_FIRMWARE_UPDATE:
          data = parameter.data;
          size = 1;
          size += data.moduleFirmwareImageUrl.length + 1;
          break;
        case NBIOT_MODULE_INFO:
          data = parameter.data;
          size = 1 + 1 + data.moduleInfo.length;
          break;
        case NBIOT_BANDS:
          data = parameter.data;
          size = 1 + 1;
          size += data.bands.length;
          break;
        case NBIOT_APN:
          data = parameter.data;
          size = 1 + 1 + data.apn.length;
          break;
        case CHANNEL_TYPE:
          data = parameter.data;
          size = 1 + getChannelTypeSize(data);
          break;
        case NBIOT_NTP_SERVER:
          data = parameter.data;
          size = 1 + 1 + data.server.length + 2;
          break;
        default:
          size = parametersSizeMap[parameter.id];
      }
      if (size === undefined) {
        throw new Error('unknown parameter id');
      }
      return size;
    };
    const getRequestParameterSize = parameter => {
      let size;
      switch (parameter.id) {
        case ABSOLUTE_DATA_MULTI_CHANNEL:
        case ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL:
        case REPORTING_DATA_CONFIG:
        case EVENTS_CONFIG:
        case CHANNEL_TYPE:
          size = 2;
          break;
        default:
          size = 1;
          break;
      }
      return size;
    };
    const getResponseParameterSize = parameter => {
      let size;
      switch (parameter.id) {
        case MQTT_SESSION_CONFIG:
        case NBIOT_SSL_CACERT_WRITE:
        case NBIOT_SSL_CLIENT_CERT_WRITE:
        case NBIOT_SSL_CLIENT_KEY_WRITE:
        case NBIOT_SSL_CACERT_SET:
        case NBIOT_SSL_CLIENT_CERT_SET:
        case NBIOT_SSL_CLIENT_KEY_SET:
        case NBIOT_DEVICE_SOFTWARE_UPDATE:
        case NBIOT_MODULE_FIRMWARE_UPDATE:
          size = 1;
          break;
        case MQTT_BROKER_ADDRESS:
        case MQTT_TOPIC_PREFIX:
        case NBIOT_MODULE_INFO:
        case NBIOT_BANDS:
        case NBIOT_APN:
        case CHANNEL_TYPE:
        case NBIOT_NTP_SERVER:
          size = getParameterSize(parameter);
          break;
        default:
          size = parametersSizeMap[parameter.id];
      }
      if (size === undefined) {
        throw new Error('unknown parameter id');
      }
      return size;
    };
    const getMagneticInfluenceBit = byte => !!extractBits(byte, 1, MAGNETIC_INFLUENCE_BIT_INDEX);
    const setMagneticInfluenceBit = (byte, value) => fillBits(byte, 1, MAGNETIC_INFLUENCE_BIT_INDEX, +value);
    const getLegacyHourCounterSize = hourCounter => LEGACY_HOUR_COUNTER_SIZE + hourCounter.diff.length * LEGACY_HOUR_DIFF_SIZE;
    const getExtendedValue = function (buffer) {
      let value = 0;
      let isByteExtended = true;
      let position = 0;
      while (isByteExtended && buffer.offset <= buffer.data.length) {
        const byte = buffer.getUint8();
        isByteExtended = !!(byte & EXTEND_BIT_MASK);
        value += (byte & 0x7f) << 7 * position >>> 0;
        ++position;
      }
      return value;
    };
    const setExtendedValue = function (buffer, value) {
      if (value === 0) {
        buffer.setUint8(0);
        return;
      }
      const data = [];
      let encodedValue = value;
      while (encodedValue) {
        data.push(EXTEND_BIT_MASK | encodedValue & 0x7f);
        encodedValue >>>= 7;
      }
      const lastByte = data.pop();
      if (lastByte) {
        data.push(lastByte & 0x7f);
      }
      data.forEach(extendedValue => buffer.setUint8(extendedValue));
    };
    const getTime = function (buffer) {
      return buffer.getUint32();
    };
    const setTime = function (buffer, value) {
      buffer.setUint32(value);
    };
    const getBatteryVoltage = function (buffer) {
      const lowVoltageByte = buffer.getUint8();
      const lowAndHightVoltageByte = buffer.getUint8();
      const highVoltageByte = buffer.getUint8();
      let underLowLoad = lowVoltageByte << 4;
      underLowLoad |= (lowAndHightVoltageByte & 0xf0) >> 4;
      let underHighLoad = (lowAndHightVoltageByte & 0x0f) << 8 | highVoltageByte;
      if (underHighLoad === UNKNOWN_BATTERY_VOLTAGE) {
        underHighLoad = undefined;
      }
      if (underLowLoad === UNKNOWN_BATTERY_VOLTAGE) {
        underLowLoad = undefined;
      }
      return {
        underLowLoad,
        underHighLoad
      };
    };
    const setBatteryVoltage = function (buffer, batteryVoltage) {
      let {
        underLowLoad,
        underHighLoad
      } = batteryVoltage;
      if (underLowLoad === undefined) {
        underLowLoad = UNKNOWN_BATTERY_VOLTAGE;
      }
      if (underHighLoad === undefined) {
        underHighLoad = UNKNOWN_BATTERY_VOLTAGE;
      }
      const lowVoltageByte = underLowLoad >> 4 & 0xff;
      const lowAndHighVoltageByte = (underLowLoad & 0x0f) << 4 | underHighLoad >> 8 & 0x0f;
      const highVoltageByte = underHighLoad & 0xff;
      [lowVoltageByte, lowAndHighVoltageByte, highVoltageByte].forEach(byte => buffer.setUint8(byte));
    };
    const getLegacyCounterValue = function (buffer) {
      return buffer.getUint24();
    };
    const setLegacyCounterValue = function (buffer, value) {
      buffer.setUint24(value);
    };
    const getLegacyCounter = function (buffer, byte = buffer.getUint8(), isArchiveValue = false) {
      const value = getLegacyCounterValue(buffer);
      return {
        isMagneticInfluence: getMagneticInfluenceBit(byte),
        value: isArchiveValue && value === EMPTY_VALUE ? 0 : value
      };
    };
    const setLegacyCounter = function (buffer, counter, byte = 0, isArchiveValue = false) {
      buffer.setUint8(setMagneticInfluenceBit(byte, counter.isMagneticInfluence));
      setLegacyCounterValue(buffer, isArchiveValue && counter.value === 0 ? EMPTY_VALUE : counter.value);
    };
    const getChannels = function (buffer) {
      const channelList = [];
      let extended = true;
      let channelIndex = 1;
      while (extended) {
        const byte = buffer.getUint8();
        const bits = byte.toString(2).padStart(LAST_BIT_INDEX + 1, '0').split('').reverse();
        bits.forEach((bit, index) => {
          const value = Number(bit);
          if (index === LAST_BIT_INDEX) {
            extended = !!value;
          } else {
            if (value) {
              channelList.push(channelIndex);
            }
            ++channelIndex;
          }
        });
      }
      return channelList;
    };
    const setChannels = function (buffer, channelList) {
      if (channelList.length === 0) {
        buffer.setUint8(0);
        return;
      }
      channelList.sort((a, b) => a.index - b.index);
      const maxChannel = Math.max(...channelList.map(({
        index
      }) => index));
      const size = (maxChannel - maxChannel % 8) / 8;
      const data = new Array(size + 1).fill(0);
      let byte = 0;
      data.forEach((_, byteIndex) => {
        let channelIndex = byteIndex * LAST_BIT_INDEX + 1;
        const maxChannelIndex = channelIndex + LAST_BIT_INDEX;
        while (channelIndex < maxChannelIndex) {
          const channel = channelList.find(item => item.index === channelIndex);
          if (channel !== undefined) {
            byte |= 1 << (channel.index - 1) % LAST_BIT_INDEX;
          }
          ++channelIndex;
        }
        if (data[byteIndex + 1] !== undefined) {
          byte |= 1 << LAST_BIT_INDEX;
        }
        data[byteIndex] = byte;
        byte = 0;
      });
      data.forEach(value => buffer.setUint8(value));
    };
    const getChannelValue = function (buffer) {
      return buffer.getUint8() + 1;
    };
    const setChannelValue = function (buffer, value) {
      if (value < 1) {
        throw new Error('channel must be 1 or greater');
      }
      buffer.setUint8(value - 1);
    };
    const getChannelsValuesWithHourDiff = function (buffer, isArchiveValue = false) {
      const date = getDate(buffer);
      const {
        hour,
        hours
      } = getHours(buffer);
      const channels = getChannels(buffer);
      const channelList = [];
      date.setUTCHours(hour);
      channels.forEach(channelIndex => {
        const diff = [];
        const value = getExtendedValue(buffer);
        for (let diffHour = 1; diffHour < hours; ++diffHour) {
          diff.push(getExtendedValue(buffer));
        }
        channelList.push({
          value: isArchiveValue && value === EMPTY_VALUE ? 0 : value,
          diff,
          index: channelIndex
        });
      });
      return {
        startTime2000: getTime2000FromDate(date),
        hours,
        channelList
      };
    };
    const setChannelsValuesWithHourDiff = function (buffer, hours, startTime2000, channelList, isArchiveValue = false) {
      const date = getDateFromTime2000(startTime2000);
      const hour = date.getUTCHours();
      setDate(buffer, date);
      setHours(buffer, hour, hours);
      setChannels(buffer, channelList);
      channelList.forEach(({
        value,
        diff
      }) => {
        setExtendedValue(buffer, isArchiveValue && value === 0 ? EMPTY_VALUE : value);
        diff.forEach(diffValue => setExtendedValue(buffer, diffValue));
      });
    };
    const getHours = function (buffer, byte = buffer.getUint8()) {
      if (byte === 0) {
        return {
          hours: 0,
          hour: 0
        };
      }
      const hours = ((byte & 0xe0) >> 5) + 1;
      const hour = byte & 0x1f;
      return {
        hours,
        hour
      };
    };
    const setHours = function (buffer, hour, hours) {
      if (hour === 0 && hours === 0) {
        buffer.setUint8(0);
        return;
      }
      buffer.setUint8((hours - 1 & 0x07) << 5 | hour & 0x1f);
    };
    const getDate = function (buffer) {
      const yearMonthByte = buffer.getUint8();
      const monthDateByte = buffer.getUint8();
      const year = yearMonthByte >> YEAR_START_INDEX;
      const month = (yearMonthByte & 0x01) << MONTH_BIT_SIZE - YEAR_START_INDEX | monthDateByte >> DATE_BIT_SIZE;
      const monthDay = monthDateByte & 0x1f;
      return new Date(Date.UTC(year + INITIAL_YEAR, month - 1, monthDay, 0, 0, 0, 0));
    };
    const setDate = function (buffer, dateOrTime) {
      let date;
      if (dateOrTime instanceof Date) {
        date = dateOrTime;
      } else {
        date = getDateFromTime2000(dateOrTime);
      }
      const year = date.getUTCFullYear() - INITIAL_YEAR;
      const month = date.getUTCMonth() + 1;
      const day = date.getUTCDate();
      const yearMonthByte = year << YEAR_START_INDEX | month >> MONTH_BIT_SIZE - YEAR_START_INDEX;
      const monthDateByte = (month & 0x07) << DATE_BIT_SIZE | day;
      [yearMonthByte, monthDateByte].forEach(byte => buffer.setUint8(byte));
    };
    const getPulseCoefficient = function (buffer) {
      const pulseCoefficient = buffer.getUint8();
      if (isMSBSet(pulseCoefficient)) {
        const value = byteToPulseCoefficientMap[pulseCoefficient];
        if (value) {
          return value;
        }
        throw new Error('pulseCoefficient MSB is set, but value unknown');
      }
      return pulseCoefficient;
    };
    const setPulseCoefficient = function (buffer, value) {
      if (value in pulseCoefficientToByteMap) {
        const byte = pulseCoefficientToByteMap[value];
        if (byte) {
          buffer.setUint8(byte);
        } else {
          throw new Error('pulseCoefficient MSB is set, but value unknown');
        }
      } else {
        buffer.setUint8(value);
      }
    };
    const getChannelsWithAbsoluteValues = function (buffer) {
      const channels = getChannels(buffer);
      const channelList = [];
      channels.forEach(channelIndex => {
        channelList.push({
          pulseCoefficient: getPulseCoefficient(buffer),
          value: getExtendedValue(buffer),
          index: channelIndex
        });
      });
      return channelList;
    };
    const setChannelsWithAbsoluteValues = function (buffer, channelList) {
      setChannels(buffer, channelList);
      channelList.forEach(({
        value,
        pulseCoefficient
      }) => {
        setPulseCoefficient(buffer, pulseCoefficient);
        setExtendedValue(buffer, value);
      });
    };
    const getChannelsAbsoluteValuesWithHourDiff = function (buffer, hours) {
      const channels = getChannels(buffer);
      const channelList = [];
      channels.forEach(channelIndex => {
        const pulseCoefficient = getPulseCoefficient(buffer);
        const value = getExtendedValue(buffer);
        const diff = [];
        for (let hourIndex = 1; hourIndex < hours; ++hourIndex) {
          diff.push(getExtendedValue(buffer));
        }
        channelList.push({
          diff,
          value,
          pulseCoefficient,
          index: channelIndex
        });
      });
      return channelList;
    };
    const setChannelsAbsoluteValuesWithHourDiff = function (buffer, channelList) {
      setChannels(buffer, channelList);
      channelList.forEach(({
        value,
        diff,
        pulseCoefficient
      }) => {
        setPulseCoefficient(buffer, pulseCoefficient);
        setExtendedValue(buffer, value);
        diff.forEach(diffValue => setExtendedValue(buffer, diffValue));
      });
    };
    const getEventStatus = function (buffer, hardwareType) {
      let status;
      if (GAS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        status = toObject(gasBitMask, buffer.getUint8());
      } else if (TWO_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        status = toObject(twoChannelBitMask, buffer.getUint8());
      } else if (ELIMP_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        status = toObject(elimpBitMask, buffer.getUint8());
      } else if (FOUR_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        status = toObject(fourChannelBitMask, buffer.getUint16(true));
      } else if (MTX_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        status = toObject(mtxBitMask, buffer.getUint16(true));
      } else if (hardwareType === US_WATER) {
        const event = toObject(usWaterMeterEventBitMask, buffer.getUint8());
        status = {
          event,
          error: buffer.getUint8()
        };
      } else {
        throw new Error('wrong hardwareType');
      }
      return status;
    };
    const setEventStatus = function (buffer, hardwareType, status) {
      if (GAS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        buffer.setUint8(fromObject(gasBitMask, status));
      } else if (TWO_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        buffer.setUint8(fromObject(twoChannelBitMask, status));
      } else if (ELIMP_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        buffer.setUint8(fromObject(elimpBitMask, status));
      } else if (FOUR_CHANNELS_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        buffer.setUint16(fromObject(fourChannelBitMask, status) | 1 << 7, true);
      } else if (MTX_HARDWARE_TYPES.indexOf(hardwareType) !== -1) {
        buffer.setUint16(fromObject(mtxBitMask, status), true);
      } else if (hardwareType === US_WATER) {
        const data = status;
        buffer.setUint8(fromObject(usWaterMeterEventBitMask, data.event));
        buffer.setUint8(data.error);
      } else {
        throw new Error('wrong hardwareType');
      }
    };
    const getParameter$1 = function (buffer) {
      const id = buffer.getUint8();
      const name = deviceParameterNames[id];
      if (!deviceParameterConvertersMap[id] || !deviceParameterConvertersMap[id].get) {
        throw new Error(`parameter ${id} is not supported`);
      }
      const data = deviceParameterConvertersMap[id].get(buffer);
      return {
        id,
        name,
        data
      };
    };
    const setParameter$1 = function (buffer, parameter) {
      const {
        id,
        data
      } = parameter;
      if (!deviceParameterConvertersMap[id] || !deviceParameterConvertersMap[id].set) {
        throw new Error(`parameter ${id} is not supported`);
      }
      buffer.setUint8(id);
      deviceParameterConvertersMap[id].set(buffer, data);
    };
    const getRequestParameter = function (buffer) {
      const id = buffer.getUint8();
      const name = deviceParameterNames[id];
      let data = null;
      switch (id) {
        case ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL:
        case ABSOLUTE_DATA_MULTI_CHANNEL:
        case CHANNEL_TYPE:
          data = {
            channel: getChannelValue(buffer)
          };
          break;
        case REPORTING_DATA_CONFIG:
          data = {
            dataType: buffer.getUint8()
          };
          break;
        case EVENTS_CONFIG:
          data = {
            eventId: buffer.getUint8()
          };
          break;
      }
      return {
        id,
        name,
        data
      };
    };
    const setRequestParameter = function (buffer, parameter) {
      const {
        id,
        data: parameterData
      } = parameter;
      let data;
      buffer.setUint8(id);
      switch (id) {
        case ABSOLUTE_DATA_MULTI_CHANNEL:
        case ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL:
        case CHANNEL_TYPE:
          data = parameterData;
          setChannelValue(buffer, data.channel);
          break;
        case REPORTING_DATA_CONFIG:
          data = parameterData;
          buffer.setUint8(data.dataType);
          break;
        case EVENTS_CONFIG:
          data = parameterData;
          buffer.setUint8(data.eventId);
          break;
      }
    };
    const getResponseParameter = function (buffer) {
      const id = buffer.getUint8();
      const name = deviceParameterNames[id];
      let data;
      if (!deviceParameterConvertersMap[id] || !deviceParameterConvertersMap[id].get) {
        throw new Error(`parameter ${id} is not supported`);
      }
      switch (id) {
        case MQTT_SESSION_CONFIG:
        case NBIOT_SSL_CACERT_WRITE:
        case NBIOT_SSL_CLIENT_CERT_WRITE:
        case NBIOT_SSL_CLIENT_KEY_WRITE:
        case NBIOT_SSL_CACERT_SET:
        case NBIOT_SSL_CLIENT_CERT_SET:
        case NBIOT_SSL_CLIENT_KEY_SET:
        case NBIOT_DEVICE_SOFTWARE_UPDATE:
        case NBIOT_MODULE_FIRMWARE_UPDATE:
          data = null;
          break;
        default:
          data = deviceParameterConvertersMap[id].get(buffer);
      }
      return {
        id,
        name,
        data
      };
    };
    const setResponseParameter = function (buffer, parameter) {
      const {
        id,
        data
      } = parameter;
      if (!deviceParameterConvertersMap[id] || !deviceParameterConvertersMap[id].set) {
        throw new Error(`parameter ${id} is not supported`);
      }
      buffer.setUint8(id);
      switch (id) {
        case MQTT_SESSION_CONFIG:
        case NBIOT_SSL_CACERT_WRITE:
        case NBIOT_SSL_CLIENT_CERT_WRITE:
        case NBIOT_SSL_CLIENT_KEY_WRITE:
        case NBIOT_SSL_CACERT_SET:
        case NBIOT_SSL_CLIENT_CERT_SET:
        case NBIOT_SSL_CLIENT_KEY_SET:
        case NBIOT_DEVICE_SOFTWARE_UPDATE:
        case NBIOT_MODULE_FIRMWARE_UPDATE:
          break;
        default:
          deviceParameterConvertersMap[id].set(buffer, data);
      }
    };
    const getLegacyHourDiff = function (buffer) {
      const stateWithValueByte = buffer.getUint8();
      const valueLowerByte = buffer.getUint8();
      return {
        isMagneticInfluence: getMagneticInfluenceBit(stateWithValueByte),
        value: (stateWithValueByte & 0x1f) << 8 | valueLowerByte
      };
    };
    const setLegacyHourDiff = function (buffer, diff) {
      const bytes = [diff.value >> 8, diff.value & 0xff];
      bytes[0] = setMagneticInfluenceBit(bytes[0], diff.isMagneticInfluence);
      bytes.forEach(byte => buffer.setUint8(byte));
    };
    const getLegacyHourCounterWithDiff = function (buffer, isArchiveValue = false) {
      const date = getDate(buffer);
      const byte = buffer.getUint8();
      const {
        hour
      } = getHours(buffer, byte);
      const value = getLegacyCounterValue(buffer);
      const counter = {
        isMagneticInfluence: getMagneticInfluenceBit(byte),
        value: isArchiveValue && value === EMPTY_VALUE ? 0 : value
      };
      const diff = [];
      while (buffer.offset < buffer.data.length) {
        diff.push(getLegacyHourDiff(buffer));
      }
      date.setUTCHours(hour);
      return {
        startTime2000: getTime2000FromDate(date),
        counter,
        diff
      };
    };
    const setLegacyHourCounterWithDiff = function (buffer, hourCounter, isArchiveValue = false) {
      const date = getDateFromTime2000(hourCounter.startTime2000);
      const hour = date.getUTCHours();
      const {
        value
      } = hourCounter.counter;
      setDate(buffer, date);
      setHours(buffer, hour, 1);
      buffer.seek(buffer.offset - 1);
      const byte = buffer.getUint8();
      buffer.seek(buffer.offset - 1);
      buffer.setUint8(setMagneticInfluenceBit(byte, hourCounter.counter.isMagneticInfluence));
      setLegacyCounterValue(buffer, isArchiveValue && value === 0 ? EMPTY_VALUE : value);
      hourCounter.diff.forEach(diffItem => setLegacyHourDiff(buffer, diffItem));
    };
    const getChannelsValuesWithHourDiffExtended = function (buffer, isArchiveValue = false) {
      const date = getDate(buffer);
      const hour = buffer.getUint8();
      const hours = buffer.getUint8();
      const channels = getChannels(buffer);
      const channelList = [];
      date.setUTCHours(hour);
      channels.forEach(channelIndex => {
        const diff = [];
        const value = getExtendedValue(buffer);
        for (let diffHour = 0; diffHour < hours; ++diffHour) {
          diff.push(getExtendedValue(buffer));
        }
        channelList.push({
          value: isArchiveValue && value === EMPTY_VALUE ? 0 : value,
          diff,
          index: channelIndex
        });
      });
      return {
        startTime2000: getTime2000FromDate(date),
        hour,
        hours,
        channelList
      };
    };
    const setChannelsValuesWithHourDiffExtended = function (buffer, parameters, isArchiveValue = false) {
      const date = getDateFromTime2000(parameters.startTime2000);
      setDate(buffer, date);
      buffer.setUint8(parameters.hour);
      buffer.setUint8(parameters.hours);
      setChannels(buffer, parameters.channelList);
      parameters.channelList.forEach(({
        value,
        diff
      }) => {
        setExtendedValue(buffer, isArchiveValue && value === 0 ? EMPTY_VALUE : value);
        diff.forEach(diffValue => setExtendedValue(buffer, diffValue));
      });
    };
    const getDataSegment = function (buffer) {
      const segmentationSessionId = buffer.getUint8();
      const flag = buffer.getUint8();
      return {
        segmentationSessionId,
        segmentIndex: extractBits(flag, 3, 1),
        segmentsNumber: extractBits(flag, 3, 5),
        isLast: Boolean(extractBits(flag, 1, 8)),
        data: buffer.getBytesLeft()
      };
    };
    const setDataSegment = function (buffer, parameters) {
      let flag = fillBits(0, 3, 1, parameters.segmentIndex);
      flag = fillBits(flag, 3, 5, parameters.segmentsNumber);
      flag = fillBits(flag, 1, 8, +parameters.isLast);
      buffer.setUint8(parameters.segmentationSessionId);
      buffer.setUint8(flag);
      buffer.setBytes(parameters.data);
    };
    const getBinarySensor = function (buffer) {
      const activeStateTimeMs = buffer.getUint16();
      return {
        activeStateTimeMs
      };
    };
    const setBinarySensor = function (buffer, parameters) {
      buffer.setUint16(parameters.activeStateTimeMs);
    };
    const getTemperatureSensor = function (buffer) {
      const measurementPeriod = buffer.getUint16();
      const hysteresisSec = buffer.getUint8();
      const highTemperatureThreshold = buffer.getInt8();
      const lowTemperatureThreshold = buffer.getInt8();
      return {
        measurementPeriod,
        hysteresisSec,
        highTemperatureThreshold,
        lowTemperatureThreshold
      };
    };
    const setTemperatureSensor = function (buffer, parameters) {
      buffer.setUint16(parameters.measurementPeriod);
      buffer.setUint8(parameters.hysteresisSec);
      buffer.setInt8(parameters.highTemperatureThreshold);
      buffer.setInt8(parameters.lowTemperatureThreshold);
    };
    const getChannelType = function (buffer) {
      const channel = getChannelValue(buffer);
      const type = buffer.getUint8();
      let parameters = {};
      switch (type) {
        case BINARY_SENSOR:
          parameters = getBinarySensor(buffer);
          break;
        case TEMPERATURE_SENSOR:
          parameters = getTemperatureSensor(buffer);
          break;
      }
      return {
        channel,
        type,
        parameters
      };
    };
    const setChannelType = function (buffer, {
      type,
      channel,
      parameters
    }) {
      setChannelValue(buffer, channel);
      buffer.setUint8(type);
      switch (type) {
        case BINARY_SENSOR:
          setBinarySensor(buffer, parameters);
          break;
        case TEMPERATURE_SENSOR:
          setTemperatureSensor(buffer, parameters);
          break;
      }
    };

    const id$ = dataSegment$1;
    downlinkNames[dataSegment$1];
    const COMMAND_BODY_MIN_SIZE$3 = 2;
    const fromBytes$11 = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      return getDataSegment(buffer);
    };
    const toBytes$11 = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MIN_SIZE$3 + parameters.data.length, false);
      setDataSegment(buffer, parameters);
      return toBytes$13(id$, buffer.data);
    };

    const id$_ = getArchiveDays$1;
    downlinkNames[getArchiveDays$1];
    const COMMAND_BODY_SIZE$x = 3;
    const fromBytes$10 = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$x) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const days = buffer.getUint8();
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return {
        startTime2000: getTime2000FromDate(date),
        days
      };
    };
    const toBytes$10 = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$x, false);
      const {
        startTime2000,
        days
      } = parameters;
      const date = getDateFromTime2000(startTime2000);
      setDate(buffer, date);
      buffer.setUint8(days);
      return toBytes$13(id$_, buffer.data);
    };

    const id$Z = getArchiveDaysMc$1;
    downlinkNames[getArchiveDaysMc$1];
    const COMMAND_BODY_SIZE$w = 4;
    const fromBytes$ = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$w) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const channelList = getChannels(buffer);
      const days = buffer.getUint8();
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return {
        startTime2000: getTime2000FromDate(date),
        days,
        channelList
      };
    };
    const toBytes$ = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$w, false);
      const {
        startTime2000,
        days,
        channelList
      } = parameters;
      const date = getDateFromTime2000(startTime2000);
      setDate(buffer, date);
      setChannels(buffer, channelList.map(index => ({
        index
      })));
      buffer.setUint8(days);
      return toBytes$13(id$Z, buffer.data);
    };

    const id$Y = getArchiveEvents$1;
    downlinkNames[getArchiveEvents$1];
    const COMMAND_BODY_SIZE$v = 5;
    const fromBytes$_ = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$v) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const startTime2000 = getTime(buffer);
      const events = buffer.getUint8();
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return {
        startTime2000,
        events
      };
    };
    const toBytes$_ = parameters => {
      const {
        startTime2000,
        events
      } = parameters;
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$v, false);
      setTime(buffer, startTime2000);
      buffer.setUint8(events);
      return toBytes$13(id$Y, buffer.data);
    };

    const id$X = getArchiveHours$1;
    downlinkNames[getArchiveHours$1];
    const COMMAND_BODY_SIZE$u = 4;
    const fromBytes$Z = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$u) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const {
        hour
      } = getHours(buffer);
      const hours = buffer.getUint8();
      date.setUTCHours(hour);
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return {
        startTime2000: getTime2000FromDate(date),
        hours
      };
    };
    const toBytes$Z = parameters => {
      const {
        startTime2000,
        hours
      } = parameters;
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$u, false);
      const date = getDateFromTime2000(startTime2000);
      const hour = date.getUTCHours();
      setDate(buffer, date);
      setHours(buffer, hour, 1);
      buffer.setUint8(hours);
      return toBytes$13(id$X, buffer.data);
    };

    const id$W = getArchiveHoursMc$1;
    downlinkNames[getArchiveHoursMc$1];
    const COMMAND_BODY_SIZE$t = 4;
    const fromBytes$Y = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$t) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const {
        hour,
        hours
      } = getHours(buffer);
      const channelList = getChannels(buffer);
      date.setUTCHours(hour);
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return {
        startTime2000: getTime2000FromDate(date),
        hours,
        channelList
      };
    };
    const toBytes$Y = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$t, false);
      const {
        hours,
        startTime2000,
        channelList
      } = parameters;
      const date = getDateFromTime2000(startTime2000);
      const hour = date.getUTCHours();
      setDate(buffer, date);
      setHours(buffer, hour, hours);
      setChannels(buffer, channelList.map(index => ({
        index
      })));
      return toBytes$13(id$W, buffer.data);
    };

    const id$V = getArchiveHoursMcEx$1;
    downlinkNames[getArchiveHoursMcEx$1];
    const COMMAND_BODY_SIZE$s = 5;
    const fromBytes$X = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const hour = buffer.getUint8();
      const hours = buffer.getUint8();
      const channelList = getChannels(buffer);
      date.setUTCHours(hour);
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return {
        startTime2000: getTime2000FromDate(date),
        hour,
        hours,
        channelList
      };
    };
    const toBytes$X = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$s, false);
      const {
        channelList,
        hour,
        hours,
        startTime2000
      } = parameters;
      const date = getDateFromTime2000(startTime2000);
      setDate(buffer, date);
      buffer.setUint8(hour);
      buffer.setUint8(hours);
      setChannels(buffer, channelList.map(index => ({
        index
      })));
      return toBytes$13(id$V, buffer.data);
    };

    const id$U = getBatteryStatus$1;
    downlinkNames[getBatteryStatus$1];
    const COMMAND_BODY_SIZE$r = 0;
    const fromBytes$W = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$r) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$W = () => toBytes$13(id$U);

    const id$T = getChannelsStatus$1;
    downlinkNames[getChannelsStatus$1];
    const fromBytes$V = bytes => bytes.length === 0 ? {} : getChannelsMaskFromNumber(bytes[0]);
    const toBytes$V = parameters => toBytes$13(id$T, Object.keys(parameters).length !== 0 ? [setChannelsMaskToNumber(parameters)] : []);

    const id$S = getChannelsTypes$1;
    downlinkNames[getChannelsTypes$1];
    const COMMAND_BODY_SIZE$q = 0;
    const fromBytes$U = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$q) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$U = () => toBytes$13(id$S);

    const id$R = getCurrent;
    downlinkNames[getCurrent];
    const COMMAND_BODY_SIZE$p = 0;
    const fromBytes$T = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$p) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$T = () => toBytes$13(id$R);

    const id$Q = getCurrentMc;
    downlinkNames[getCurrentMc];
    const COMMAND_BODY_SIZE$o = 0;
    const fromBytes$S = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$o) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$S = () => toBytes$13(id$Q);

    const id$P = getExAbsArchiveDaysMc$1;
    downlinkNames[getExAbsArchiveDaysMc$1];
    const COMMAND_BODY_SIZE$n = 4;
    const fromBytes$R = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$n) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const channelList = getChannels(buffer);
      const days = buffer.getUint8();
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return {
        startTime2000: getTime2000FromDate(date),
        days,
        channelList
      };
    };
    const toBytes$R = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$n, false);
      const {
        startTime2000,
        days,
        channelList
      } = parameters;
      setDate(buffer, startTime2000);
      setChannels(buffer, channelList.map(index => ({
        index
      })));
      buffer.setUint8(days);
      return toBytes$13(id$P, buffer.data);
    };

    const id$O = getExAbsArchiveHoursMc$1;
    downlinkNames[getExAbsArchiveHoursMc$1];
    const COMMAND_BODY_SIZE$m = 4;
    const fromBytes$Q = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const {
        hour,
        hours
      } = getHours(buffer);
      const channelList = getChannels(buffer);
      date.setUTCHours(hour);
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return {
        channelList,
        hours,
        startTime2000: getTime2000FromDate(date)
      };
    };
    const toBytes$Q = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$m, false);
      const {
        startTime2000,
        hours,
        channelList
      } = parameters;
      const date = getDateFromTime2000(startTime2000);
      const hour = date.getUTCHours();
      setDate(buffer, date);
      setHours(buffer, hour, hours);
      setChannels(buffer, channelList.map(index => ({
        index
      })));
      return toBytes$13(id$O, buffer.data);
    };

    const id$N = getExAbsCurrentMc;
    downlinkNames[getExAbsCurrentMc];
    const COMMAND_BODY_SIZE$l = 0;
    const fromBytes$P = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$l) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$P = () => toBytes$13(id$N);

    const id$M = getLmicInfo$1;
    downlinkNames[getLmicInfo$1];
    const COMMAND_BODY_SIZE$k = 0;
    const fromBytes$O = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$k) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$O = () => toBytes$13(id$M);

    const id$L = getParameter$2;
    downlinkNames[getParameter$2];
    const fromBytes$N = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      return getRequestParameter(buffer);
    };
    const toBytes$N = parameters => {
      const buffer = new BinaryBuffer(getRequestParameterSize(parameters), false);
      setRequestParameter(buffer, parameters);
      return toBytes$13(id$L, buffer.data);
    };

    const id$K = getSignalQuality;
    downlinkNames[getSignalQuality];
    const COMMAND_BODY_SIZE$j = 0;
    const fromBytes$M = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$j) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$M = () => toBytes$13(id$K, []);

    const id$J = getStatus;
    downlinkNames[getStatus];
    const COMMAND_BODY_SIZE$i = 0;
    const fromBytes$L = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$i) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$L = () => toBytes$13(id$J);

    const id$I = getTime2000;
    downlinkNames[getTime2000];
    const COMMAND_BODY_SIZE$h = 0;
    const fromBytes$K = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$h) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$K = () => toBytes$13(id$I, []);

    const id$H = setParameter$2;
    downlinkNames[setParameter$2];
    ({
      '01_LoRa: set minimal reporting data interval to 1 hour': {
        parameters: {
          name: deviceParameterNames[REPORTING_DATA_INTERVAL]}},
      '04_LoRa: set day checkout hour to 12:00': {
        parameters: {
          name: deviceParameterNames[DAY_CHECKOUT_HOUR]}},
      '05_LoRa: set reporting data type to "day"': {
        parameters: {
          name: deviceParameterNames[REPORTING_DATA_TYPE]}},
      '08_LoRa: set "with confirmation" for delivery of priority data': {
        parameters: {
          name: deviceParameterNames[PRIORITY_DATA_DELIVERY_TYPE]}},
      '09_LoRa: set activation method to "ABP"': {
        parameters: {
          name: deviceParameterNames[ACTIVATION_METHOD]}},
      '10_LoRa: set battery depassivation info': {
        parameters: {
          name: deviceParameterNames[BATTERY_DEPASSIVATION_INFO]}},
      '11_LoRa: set battery minimal load time to "100"': {
        parameters: {
          name: deviceParameterNames[BATTERY_MINIMAL_LOAD_TIME]}},
      '13_LoRa: enable 1-4 channels, and disable serial channel for device': {
        parameters: {
          name: deviceParameterNames[CHANNELS_CONFIG]}},
      '18_LoRa: set spread factor and frequency for RX2 window': {
        parameters: {
          name: deviceParameterNames[RX2_CONFIG]}},
      '23_Common_Gas: set absolute data (not multichannel device': {
        parameters: {
          name: deviceParameterNames[ABSOLUTE_DATA]}},
      '24_Common_Gas: enable absolute data (not multichannel device': {
        parameters: {
          name: deviceParameterNames[ABSOLUTE_DATA_ENABLE]}},
      '25_LoRa: set device serial number': {
        parameters: {
          name: deviceParameterNames[SERIAL_NUMBER]}},
      '26_LoRa: set device geolocation': {
        parameters: {
          name: deviceParameterNames[GEOLOCATION]}},
      '28_LoRa: set interval to send EXTRA FRAME': {
        parameters: {
          name: deviceParameterNames[EXTRA_FRAME_INTERVAL]}},
      '29_Common_4PU: set absolute data for multichannel device (1 channel': {
        parameters: {
          name: deviceParameterNames[ABSOLUTE_DATA_MULTI_CHANNEL]}},
      '30_Common_4PU: enable absolute data for multichannel device (2 channel': {
        parameters: {
          name: deviceParameterNames[ABSOLUTE_DATA_ENABLE_MULTI_CHANNEL]}},
      '31_LoRa_4PU: set pulse channels config': {
        parameters: {
          name: deviceParameterNames[PULSE_CHANNELS_SCAN_CONFIG]}},
      '32_LoRa_4PU: enable channels: 1, 2, disable channels: 3, 4, for pulse device': {
        parameters: {
          name: deviceParameterNames[PULSE_CHANNELS_SET_CONFIG]}},
      '33_LoRa: set depassivation config for device': {
        parameters: {
          name: deviceParameterNames[BATTERY_DEPASSIVATION_CONFIG]}},
      '34_NB-IoT: set configuration for session': {
        parameters: {
          name: deviceParameterNames[MQTT_SESSION_CONFIG]}},
      '35_NB-IoT: set broker address': {
        parameters: {
          name: deviceParameterNames[MQTT_BROKER_ADDRESS]}},
      '36_NB-IoT: disable ssl': {
        parameters: {
          name: deviceParameterNames[MQTT_SSL_ENABLE]}},
      '37_NB-IoT: set topic prefix': {
        parameters: {
          name: deviceParameterNames[MQTT_TOPIC_PREFIX]}},
      '38_NB-IoT: set configuration for data receive': {
        parameters: {
          name: deviceParameterNames[MQTT_DATA_RECEIVE_CONFIG]}},
      '39_NB-IoT: set configuration for data send': {
        parameters: {
          name: deviceParameterNames[MQTT_DATA_SEND_CONFIG]}},
      '40_NB-IoT: set configuration for ssl': {
        parameters: {
          name: deviceParameterNames[NBIOT_SSL_CONFIG]}},
      '47_NB-IoT: update software': {
        parameters: {
          name: deviceParameterNames[NBIOT_DEVICE_SOFTWARE_UPDATE]}},
      '48_NB-IoT: update NB-IoT module firmware': {
        parameters: {
          name: deviceParameterNames[NBIOT_MODULE_FIRMWARE_UPDATE]}},
      '49_NB-IoT: set configuration for reporting data': {
        parameters: {
          name: deviceParameterNames[REPORTING_DATA_CONFIG]}},
      '50_NB-IoT: set configuration for events': {
        parameters: {
          name: deviceParameterNames[EVENTS_CONFIG]}},
      '52_NB-IoT: set nbiot bands': {
        parameters: {
          name: deviceParameterNames[NBIOT_BANDS]}},
      '53_NB-IoT: set nbiot apn': {
        parameters: {
          name: deviceParameterNames[NBIOT_APN]}},
      '54_NB-IoT: set nbiot led indication': {
        parameters: {
          name: deviceParameterNames[NBIOT_LED_INDICATION]}},
      '55_NB-IoT: set nbiot sim pin code': {
        parameters: {
          name: deviceParameterNames[NBIOT_SIM]}},
      '56_4PU: set channel type. Channel index: 1, type: power channel': {
        parameters: {
          name: deviceParameterNames[CHANNEL_TYPE]}},
      '56_4PU: set channel type. Channel index: 2, type: binary sensor': {
        parameters: {
          name: deviceParameterNames[CHANNEL_TYPE]}},
      '56_4PU: set channel type. Channel index: 3, type: temperature sensor': {
        parameters: {
          name: deviceParameterNames[CHANNEL_TYPE]}},
      '56_4PU: set channel type. Channel index: 4, type: idle': {
        parameters: {
          name: deviceParameterNames[CHANNEL_TYPE]}},
      '57_NB-IoT: enable extra payload with signal quality on every uplink command': {
        parameters: {
          name: deviceParameterNames[EXTRA_PAYLOAD_ENABLE]}},
      '58_Common: time synchronization period in seconds via MAC commands': {
        parameters: {
          name: deviceParameterNames[TIME_SYNCHRONIZATION_PERIOD_VIA_MAC]}},
      '59_LoRa: keep its lora connection even after being removed': {
        parameters: {
          name: deviceParameterNames[KEEP_LORA_CONNECTION_ON_REMOVAL]}},
      '60_NB-IoT: set nbiot ntp server': {
        parameters: {
          name: deviceParameterNames[NBIOT_NTP_SERVER]}},
      '61_LoRa_4PU: activate module': {
        parameters: {
          name: deviceParameterNames[ACTIVATE_MODULE]}}
    });
    const fromBytes$J = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      return getParameter$1(buffer);
    };
    const toBytes$J = parameters => {
      const buffer = new BinaryBuffer(getParameterSize(parameters), false);
      setParameter$1(buffer, parameters);
      return toBytes$13(id$H, buffer.data);
    };

    const id$G = setTime2000$1;
    downlinkNames[setTime2000$1];
    const COMMAND_BODY_SIZE$g = 5;
    const fromBytes$I = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$g) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const parameters = {
        sequenceNumber: buffer.getUint8(),
        seconds: buffer.getInt32()
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    const toBytes$I = parameters => {
      const {
        sequenceNumber,
        seconds
      } = parameters;
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$g, false);
      buffer.setUint8(sequenceNumber);
      buffer.setInt32(seconds);
      return toBytes$13(id$G, buffer.data);
    };

    const id$F = softRestart$1;
    downlinkNames[softRestart$1];
    const COMMAND_BODY_SIZE$f = 0;
    const fromBytes$H = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$f) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$H = () => toBytes$13(id$F);

    const id$E = updateRun$1;
    downlinkNames[updateRun$1];
    const COMMAND_BODY_SIZE$e = 0;
    const fromBytes$G = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$e) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$G = () => toBytes$13(id$E);

    const id$D = usWaterMeterCommand$1;
    downlinkNames[usWaterMeterCommand$1];
    const fromBytes$F = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      const length = buffer.getUint8();
      return {
        length,
        data: bytes.slice(1)
      };
    };
    const toBytes$F = parameters => {
      const {
        data,
        length
      } = parameters;
      const buffer = new BinaryBuffer(length, false);
      buffer.setUint8(length);
      buffer.setBytes(data);
      return toBytes$13(id$D, buffer.data);
    };

    const id$C = verifyImage$1;
    downlinkNames[verifyImage$1];
    const COMMAND_BODY_SIZE$d = 0;
    const fromBytes$E = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$d) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$E = () => toBytes$13(id$C);

    const id$B = writeImage$1;
    downlinkNames[writeImage$1];
    const COMMAND_BODY_MIN_SIZE$2 = 4;
    const fromBytes$D = bytes => {
      if (bytes.length < COMMAND_BODY_MIN_SIZE$2) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const offset = buffer.getUint32();
      return {
        offset,
        data: bytes.slice(COMMAND_BODY_MIN_SIZE$2)
      };
    };
    const toBytes$D = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MIN_SIZE$2, false);
      buffer.setUint32(parameters.offset);
      buffer.setBytes(parameters.data);
      return toBytes$13(id$B, buffer.data);
    };

    var calculateLrc = (data, initialLrc = 0x55) => {
      let lrc = initialLrc;
      data.forEach(item => {
        lrc ^= item;
      });
      return lrc;
    };

    const HEADER_MAX_SIZE = 3;
    const getFromBytes = (fromBytesMap, nameMap) => (bytes = [], config) => {
      const commands = [];
      const message = {
        commands,
        bytes,
        lrc: {
          received: undefined,
          calculated: 0
        }
      };
      let processedBytes = 0;
      let receivedLrc;
      let calculatedLrc;
      if (!bytes.length) {
        return message;
      }
      do {
        const headerInfo = fromBytes$13(bytes.slice(processedBytes, processedBytes + HEADER_MAX_SIZE));
        const headerData = bytes.slice(processedBytes, processedBytes + headerInfo.headerSize);
        const bodyData = bytes.slice(processedBytes + headerInfo.headerSize, processedBytes + headerInfo.headerSize + headerInfo.commandSize);
        const command = {
          id: headerInfo.commandId,
          name: nameMap[headerInfo.commandId],
          headerSize: headerInfo.headerSize,
          bytes: [...headerData, ...bodyData]
        };
        processedBytes = processedBytes + headerInfo.headerSize + headerInfo.commandSize;
        if (config) {
          command.config = config;
        }
        try {
          if (!fromBytesMap[headerInfo.commandId]) {
            throw new Error(`Unsupported command id: ${headerInfo.commandId}!`);
          }
          command.parameters = fromBytesMap[headerInfo.commandId](bodyData, config);
          commands.push(command);
        } catch (error) {
          commands.push({
            command,
            error: error.message
          });
        }
      } while (processedBytes < bytes.length - 1);
      if (bytes.length - processedBytes === 1) {
        receivedLrc = bytes[bytes.length - 1];
        calculatedLrc = calculateLrc(bytes.slice(0, -1));
      } else {
        calculatedLrc = calculateLrc(bytes);
      }
      message.lrc.calculated = calculatedLrc;
      message.lrc.received = receivedLrc;
      if (receivedLrc === calculatedLrc) {
        return message;
      }
      return {
        message,
        error: 'Mismatch LRC.'
      };
    };
    const getToBytes = toBytesMap => commands => {
      const commandBytes = commands.map(command => {
        if ('id' in command) {
          return toBytesMap[command.id](command.parameters || {}, command.config);
        }
        if ('command' in command) {
          return command.command.bytes;
        }
        throw new Error('wrong command format');
      });
      const body = [].concat(...commandBytes);
      return [...body, calculateLrc(body)];
    };
    const getToMessage = toBytesMap => commands => {
      const commandsWithBytes = commands.map(command => {
        if ('parameters' in command) {
          return Object.assign({}, command, {
            bytes: toBytesMap[command.id](command.parameters, command.config)
          });
        }
        throw new Error('wrong command format');
      });
      const commandBytes = commandsWithBytes.map(({
        bytes
      }) => bytes);
      const body = [].concat(...commandBytes);
      const lrc = calculateLrc(body);
      return {
        commands: commandsWithBytes,
        bytes: [...body, lrc],
        lrc: {
          received: lrc,
          calculated: lrc
        }
      };
    };

    const toBytesMap$1 = {};
    const fromBytesMap$1 = {};
    const nameMap$1 = downlinkNames;
    const fromBytes$C = getFromBytes(fromBytesMap$1, nameMap$1);
    const toBytes$C = getToBytes(toBytesMap$1);
    const toMessage$1 = getToMessage(toBytesMap$1);
    toBytesMap$1[id$10] = toBytes$12;
    toBytesMap$1[id$] = toBytes$11;
    toBytesMap$1[id$_] = toBytes$10;
    toBytesMap$1[id$Z] = toBytes$;
    toBytesMap$1[id$Y] = toBytes$_;
    toBytesMap$1[id$X] = toBytes$Z;
    toBytesMap$1[id$W] = toBytes$Y;
    toBytesMap$1[id$V] = toBytes$X;
    toBytesMap$1[id$U] = toBytes$W;
    toBytesMap$1[id$T] = toBytes$V;
    toBytesMap$1[id$S] = toBytes$U;
    toBytesMap$1[id$R] = toBytes$T;
    toBytesMap$1[id$Q] = toBytes$S;
    toBytesMap$1[id$P] = toBytes$R;
    toBytesMap$1[id$O] = toBytes$Q;
    toBytesMap$1[id$N] = toBytes$P;
    toBytesMap$1[id$M] = toBytes$O;
    toBytesMap$1[id$L] = toBytes$N;
    toBytesMap$1[id$K] = toBytes$M;
    toBytesMap$1[id$J] = toBytes$L;
    toBytesMap$1[id$I] = toBytes$K;
    toBytesMap$1[id$H] = toBytes$J;
    toBytesMap$1[id$G] = toBytes$I;
    toBytesMap$1[id$F] = toBytes$H;
    toBytesMap$1[id$E] = toBytes$G;
    toBytesMap$1[id$D] = toBytes$F;
    toBytesMap$1[id$C] = toBytes$E;
    toBytesMap$1[id$B] = toBytes$D;
    fromBytesMap$1[id$10] = fromBytes$12;
    fromBytesMap$1[id$] = fromBytes$11;
    fromBytesMap$1[id$_] = fromBytes$10;
    fromBytesMap$1[id$Z] = fromBytes$;
    fromBytesMap$1[id$Y] = fromBytes$_;
    fromBytesMap$1[id$X] = fromBytes$Z;
    fromBytesMap$1[id$W] = fromBytes$Y;
    fromBytesMap$1[id$V] = fromBytes$X;
    fromBytesMap$1[id$U] = fromBytes$W;
    fromBytesMap$1[id$T] = fromBytes$V;
    fromBytesMap$1[id$S] = fromBytes$U;
    fromBytesMap$1[id$R] = fromBytes$T;
    fromBytesMap$1[id$Q] = fromBytes$S;
    fromBytesMap$1[id$P] = fromBytes$R;
    fromBytesMap$1[id$O] = fromBytes$Q;
    fromBytesMap$1[id$N] = fromBytes$P;
    fromBytesMap$1[id$M] = fromBytes$O;
    fromBytesMap$1[id$L] = fromBytes$N;
    fromBytesMap$1[id$K] = fromBytes$M;
    fromBytesMap$1[id$J] = fromBytes$L;
    fromBytesMap$1[id$I] = fromBytes$K;
    fromBytesMap$1[id$H] = fromBytes$J;
    fromBytesMap$1[id$G] = fromBytes$I;
    fromBytesMap$1[id$F] = fromBytes$H;
    fromBytesMap$1[id$E] = fromBytes$G;
    fromBytesMap$1[id$D] = fromBytes$F;
    fromBytesMap$1[id$C] = fromBytes$E;
    fromBytesMap$1[id$B] = fromBytes$D;

    var downlink = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromBytes: fromBytes$C,
        fromBytesMap: fromBytesMap$1,
        nameMap: nameMap$1,
        toBytes: toBytes$C,
        toBytesMap: toBytesMap$1,
        toMessage: toMessage$1
    });

    const setTime2000 = 0x02;
    const setParameter = 0x03;
    const getParameter = 0x04;
    const getArchiveHours = 0x05;
    const getArchiveDays = 0x06;
    const current = 0x07;
    const time2000 = 0x09;
    const getArchiveEvents = 0x0b;
    const correctTime2000 = 0x0c;
    const status = 0x14;
    const newEvent = 0x15;
    const dayMc = 0x16;
    const hourMc = 0x17;
    const currentMc = 0x18;
    const softRestart = 0x19;
    const getArchiveHoursMc = 0x1a;
    const getArchiveDaysMc = 0x1b;
    const dataSegment = 0x1e;
    const day = 0x20;
    const hour = 0x40;
    const lastEvent = 0x60;
    const getLmicInfo = 0x21f;
    const getBatteryStatus = 0x51f;
    const usWaterMeterCommand = 0x71f;
    const exAbsHourMc = 0xa1f;
    const exAbsDayMc = 0xb1f;
    const getExAbsArchiveHoursMc = 0xc1f;
    const getExAbsArchiveDaysMc = 0xd1f;
    const exAbsCurrentMc = 0xf1f;
    const usWaterMeterBatteryStatus = 0x141f;
    const writeImage = 0x2a1f;
    const verifyImage = 0x2b1f;
    const updateRun = 0x2c1f;
    const getArchiveHoursMcEx = 0x301f;
    const hourMcEx = 0x311f;
    const getChannelsStatus = 0x321f;
    const getChannelsTypes = 0x331f;
    const signalQuality = 0x341f;

    var uplinkIds = /*#__PURE__*/Object.freeze({
        __proto__: null,
        correctTime2000: correctTime2000,
        current: current,
        currentMc: currentMc,
        dataSegment: dataSegment,
        day: day,
        dayMc: dayMc,
        exAbsCurrentMc: exAbsCurrentMc,
        exAbsDayMc: exAbsDayMc,
        exAbsHourMc: exAbsHourMc,
        getArchiveDays: getArchiveDays,
        getArchiveDaysMc: getArchiveDaysMc,
        getArchiveEvents: getArchiveEvents,
        getArchiveHours: getArchiveHours,
        getArchiveHoursMc: getArchiveHoursMc,
        getArchiveHoursMcEx: getArchiveHoursMcEx,
        getBatteryStatus: getBatteryStatus,
        getChannelsStatus: getChannelsStatus,
        getChannelsTypes: getChannelsTypes,
        getExAbsArchiveDaysMc: getExAbsArchiveDaysMc,
        getExAbsArchiveHoursMc: getExAbsArchiveHoursMc,
        getLmicInfo: getLmicInfo,
        getParameter: getParameter,
        hour: hour,
        hourMc: hourMc,
        hourMcEx: hourMcEx,
        lastEvent: lastEvent,
        newEvent: newEvent,
        setParameter: setParameter,
        setTime2000: setTime2000,
        signalQuality: signalQuality,
        softRestart: softRestart,
        status: status,
        time2000: time2000,
        updateRun: updateRun,
        usWaterMeterBatteryStatus: usWaterMeterBatteryStatus,
        usWaterMeterCommand: usWaterMeterCommand,
        verifyImage: verifyImage,
        writeImage: writeImage
    });

    var uplinkNames = invertObject(uplinkIds);

    const id$A = correctTime2000;
    uplinkNames[correctTime2000];
    const COMMAND_BODY_SIZE$c = 1;
    const fromBytes$B = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$c) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const parameters = {
        status: buffer.getUint8()
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    const toBytes$B = parameters => {
      const {
        status
      } = parameters;
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$c, false);
      buffer.setUint8(status);
      return toBytes$13(id$A, buffer.data);
    };

    const id$z = current;
    uplinkNames[current];
    const COMMAND_BODY_MAX_SIZE$e = 4;
    const fromBytes$A = bytes => {
      if (bytes.length > COMMAND_BODY_MAX_SIZE$e) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      return getLegacyCounter(buffer);
    };
    const toBytes$A = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$e, false);
      setLegacyCounter(buffer, parameters);
      return toBytes$13(id$z, buffer.data);
    };

    const id$y = currentMc;
    uplinkNames[currentMc];
    const COMMAND_BODY_MAX_SIZE$d = 37;
    const fromBytes$z = bytes => {
      if (bytes.length > COMMAND_BODY_MAX_SIZE$d) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const parameters = {
        channelList: []
      };
      const buffer = new BinaryBuffer(bytes, false);
      const channelList = getChannels(buffer);
      parameters.channelList = channelList.map(channelIndex => ({
        value: getExtendedValue(buffer),
        index: channelIndex
      }));
      return parameters;
    };
    const toBytes$z = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$d, false);
      const {
        channelList
      } = parameters;
      setChannels(buffer, channelList);
      channelList.forEach(({
        value
      }) => {
        setExtendedValue(buffer, value);
      });
      return toBytes$13(id$y, buffer.getBytesToOffset());
    };

    const id$x = day;
    uplinkNames[day];
    const COMMAND_BODY_SIZE$b = 6;
    const fromBytes$y = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const byte = buffer.getUint8();
      const {
        hour
      } = getHours(buffer, byte);
      const isMagneticInfluence = getMagneticInfluenceBit(byte);
      const value = getLegacyCounterValue(buffer);
      date.setUTCHours(hour);
      return {
        value,
        isMagneticInfluence,
        startTime2000: getTime2000FromDate(date)
      };
    };
    const toBytes$y = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$b, false);
      const {
        value,
        isMagneticInfluence,
        startTime2000
      } = parameters;
      const date = getDateFromTime2000(startTime2000);
      const hour = date.getUTCHours();
      setDate(buffer, date);
      setHours(buffer, hour, 1);
      buffer.seek(buffer.offset - 1);
      const byte = buffer.getUint8();
      buffer.seek(buffer.offset - 1);
      buffer.setUint8(setMagneticInfluenceBit(byte, isMagneticInfluence));
      setLegacyCounterValue(buffer, value);
      return toBytes$13(id$x, buffer.getBytesToOffset());
    };

    const id$w = dayMc;
    uplinkNames[dayMc];
    const COMMAND_BODY_MAX_SIZE$c = 32;
    const fromBytes$x = bytes => {
      if (bytes.length > COMMAND_BODY_MAX_SIZE$c) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const channels = getChannels(buffer);
      const channelList = channels.map(channelIndex => ({
        value: getExtendedValue(buffer),
        index: channelIndex
      }));
      return {
        startTime2000: getTime2000FromDate(date),
        channelList
      };
    };
    const toBytes$x = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$c, false);
      const {
        channelList,
        startTime2000
      } = parameters;
      setDate(buffer, startTime2000);
      setChannels(buffer, channelList);
      channelList.forEach(({
        value
      }) => {
        setExtendedValue(buffer, value);
      });
      return toBytes$13(id$w, buffer.getBytesToOffset());
    };

    const id$v = exAbsCurrentMc;
    uplinkNames[exAbsCurrentMc];
    const COMMAND_BODY_MAX_SIZE$b = 87;
    const fromBytes$w = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      return {
        channelList: getChannelsWithAbsoluteValues(buffer)
      };
    };
    const toBytes$w = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$b, false);
      setChannelsWithAbsoluteValues(buffer, parameters.channelList);
      return toBytes$13(id$v, buffer.getBytesToOffset());
    };

    const id$u = exAbsDayMc;
    uplinkNames[exAbsDayMc];
    const COMMAND_BODY_MAX_SIZE$a = 89;
    const fromBytes$v = bytes => {
      if (bytes.length > COMMAND_BODY_MAX_SIZE$a) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const channelList = getChannelsWithAbsoluteValues(buffer);
      return {
        startTime2000: getTime2000FromDate(date),
        channelList
      };
    };
    const toBytes$v = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$a, false);
      const {
        startTime2000,
        channelList
      } = parameters;
      setDate(buffer, startTime2000);
      setChannelsWithAbsoluteValues(buffer, channelList);
      return toBytes$13(id$u, buffer.getBytesToOffset());
    };

    const id$t = exAbsHourMc;
    uplinkNames[exAbsHourMc];
    const COMMAND_BODY_MAX_SIZE$9 = 168;
    const fromBytes$u = bytes => {
      if (bytes.length > COMMAND_BODY_MAX_SIZE$9) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const {
        hour,
        hours
      } = getHours(buffer);
      const channelList = getChannelsAbsoluteValuesWithHourDiff(buffer, hours);
      date.setUTCHours(hour);
      return {
        startTime2000: getTime2000FromDate(date),
        hours,
        channelList
      };
    };
    const toBytes$u = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$9, false);
      const {
        startTime2000,
        hours,
        channelList
      } = parameters;
      const date = getDateFromTime2000(startTime2000);
      const hour = date.getUTCHours();
      setDate(buffer, startTime2000);
      setHours(buffer, hour, hours);
      setChannelsAbsoluteValuesWithHourDiff(buffer, channelList);
      return toBytes$13(id$t, buffer.getBytesToOffset());
    };

    const id$s = getArchiveDays;
    uplinkNames[getArchiveDays];
    const COMMAND_BODY_MIN_SIZE$1 = 2;
    const DAY_COUNTER_SIZE = 4;
    const fromBytes$t = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const dayList = [];
      while (buffer.offset < buffer.data.length) {
        dayList.push(getLegacyCounter(buffer, undefined, true));
      }
      return {
        startTime2000: getTime2000FromDate(date),
        dayList
      };
    };
    const toBytes$t = parameters => {
      const {
        startTime2000,
        dayList
      } = parameters;
      const buffer = new BinaryBuffer(COMMAND_BODY_MIN_SIZE$1 + dayList.length * DAY_COUNTER_SIZE, false);
      setDate(buffer, startTime2000);
      dayList.forEach(dayCounter => setLegacyCounter(buffer, dayCounter, undefined, true));
      return toBytes$13(id$s, buffer.getBytesToOffset());
    };

    const id$r = getArchiveDaysMc;
    uplinkNames[getArchiveDaysMc];
    const COMMAND_BODY_MAX_SIZE$8 = 255;
    const fromBytes$s = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const channels = getChannels(buffer);
      const days = buffer.getUint8();
      const channelList = [];
      channels.forEach(channelIndex => {
        const dayList = [];
        channelList.push({
          dayList,
          index: channelIndex
        });
        for (let day = 0; day < days; ++day) {
          const value = getExtendedValue(buffer);
          dayList.push(value === EMPTY_VALUE ? 0 : value);
        }
      });
      return {
        startTime2000: getTime2000FromDate(date),
        days,
        channelList
      };
    };
    const toBytes$s = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$8, false);
      const {
        startTime2000,
        days,
        channelList
      } = parameters;
      setDate(buffer, startTime2000);
      setChannels(buffer, channelList);
      buffer.setUint8(days);
      channelList.forEach(({
        dayList
      }) => {
        dayList.forEach(value => {
          setExtendedValue(buffer, value === 0 ? EMPTY_VALUE : value);
        });
      });
      return toBytes$13(id$r, buffer.getBytesToOffset());
    };

    const MAGNET_ON = 1;
    const MAGNET_OFF = 2;
    const ACTIVATE = 3;
    const DEACTIVATE = 4;
    const BATTERY_ALARM = 5;
    const CAN_OFF = 6;
    const INSERT = 7;
    const REMOVE = 8;
    const COUNTER_OVER = 9;
    const SET_TIME = 10;
    const ACTIVATE_MTX = 11;
    const CONNECT = 12;
    const DISCONNECT = 13;
    const DEPASS_DONE = 14;
    const OPTOLOW = 15;
    const OPTOFLASH = 16;
    const MTX = 17;
    const JOIN_ACCEPT = 18;
    const WATER_EVENT = 19;
    const WATER_NO_RESPONSE = 20;
    const OPTOSENSOR_ERROR = 21;
    const BINARY_SENSOR_ON = 22;
    const BINARY_SENSOR_OFF = 23;
    const TEMPERATURE_SENSOR_HYSTERESIS = 24;
    const TEMPERATURE_SENSOR_LOW_TEMPERATURE = 25;
    const TEMPERATURE_SENSOR_HIGH_TEMPERATURE = 26;

    var events = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACTIVATE: ACTIVATE,
        ACTIVATE_MTX: ACTIVATE_MTX,
        BATTERY_ALARM: BATTERY_ALARM,
        BINARY_SENSOR_OFF: BINARY_SENSOR_OFF,
        BINARY_SENSOR_ON: BINARY_SENSOR_ON,
        CAN_OFF: CAN_OFF,
        CONNECT: CONNECT,
        COUNTER_OVER: COUNTER_OVER,
        DEACTIVATE: DEACTIVATE,
        DEPASS_DONE: DEPASS_DONE,
        DISCONNECT: DISCONNECT,
        INSERT: INSERT,
        JOIN_ACCEPT: JOIN_ACCEPT,
        MAGNET_OFF: MAGNET_OFF,
        MAGNET_ON: MAGNET_ON,
        MTX: MTX,
        OPTOFLASH: OPTOFLASH,
        OPTOLOW: OPTOLOW,
        OPTOSENSOR_ERROR: OPTOSENSOR_ERROR,
        REMOVE: REMOVE,
        SET_TIME: SET_TIME,
        TEMPERATURE_SENSOR_HIGH_TEMPERATURE: TEMPERATURE_SENSOR_HIGH_TEMPERATURE,
        TEMPERATURE_SENSOR_HYSTERESIS: TEMPERATURE_SENSOR_HYSTERESIS,
        TEMPERATURE_SENSOR_LOW_TEMPERATURE: TEMPERATURE_SENSOR_LOW_TEMPERATURE,
        WATER_EVENT: WATER_EVENT,
        WATER_NO_RESPONSE: WATER_NO_RESPONSE
    });

    var eventNames = invertObject(events);

    const id$q = getArchiveEvents;
    uplinkNames[getArchiveEvents];
    const COMMAND_BODY_MIN_SIZE = 4 + 1 + 1;
    const getEvent = buffer => {
      const time2000 = getTime(buffer);
      const eventId = buffer.getUint8();
      const sequenceNumber = buffer.getUint8();
      return {
        time2000,
        id: eventId,
        name: eventNames[eventId],
        sequenceNumber
      };
    };
    const setEvent = (buffer, event) => {
      setTime(buffer, event.time2000);
      buffer.setUint8(event.id);
      buffer.setUint8(event.sequenceNumber);
    };
    const fromBytes$r = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      const eventList = [];
      while (buffer.bytesLeft > 0) {
        eventList.push(getEvent(buffer));
      }
      return {
        eventList
      };
    };
    function toBytes$r(parameters) {
      const {
        eventList
      } = parameters;
      const buffer = new BinaryBuffer(eventList.length * COMMAND_BODY_MIN_SIZE, false);
      eventList.forEach(event => setEvent(buffer, event));
      return toBytes$13(id$q, buffer.data);
    }

    const id$p = getArchiveHours;
    uplinkNames[getArchiveHours];
    const fromBytes$q = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      return getLegacyHourCounterWithDiff(buffer, true);
    };
    const toBytes$q = parameters => {
      const buffer = new BinaryBuffer(getLegacyHourCounterSize(parameters), false);
      setLegacyHourCounterWithDiff(buffer, parameters, true);
      return toBytes$13(id$p, buffer.getBytesToOffset());
    };

    const id$o = getArchiveHoursMc;
    uplinkNames[getArchiveHoursMc];
    const COMMAND_BODY_MAX_SIZE$7 = 164;
    const fromBytes$p = bytes => {
      if (bytes.length > COMMAND_BODY_MAX_SIZE$7) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      return getChannelsValuesWithHourDiff(buffer, true);
    };
    const toBytes$p = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$7, false);
      const {
        hours,
        startTime2000,
        channelList
      } = parameters;
      setChannelsValuesWithHourDiff(buffer, hours, startTime2000, channelList, true);
      return toBytes$13(id$o, buffer.getBytesToOffset());
    };

    const id$n = getArchiveHoursMcEx;
    uplinkNames[getArchiveHoursMcEx];
    const COMMAND_BODY_MAX_SIZE$6 = 255;
    const fromBytes$o = bytes => {
      if (bytes.length > COMMAND_BODY_MAX_SIZE$6) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      return getChannelsValuesWithHourDiffExtended(buffer, true);
    };
    const toBytes$o = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$6, false);
      setChannelsValuesWithHourDiffExtended(buffer, parameters, true);
      return toBytes$13(id$n, buffer.getBytesToOffset());
    };

    const id$m = getBatteryStatus;
    uplinkNames[getBatteryStatus];
    const COMMAND_BODY_SIZE$a = 11;
    const fromBytes$n = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      return {
        voltageUnderLowLoad: buffer.getUint16(),
        voltageUnderHighLoad: buffer.getUint16(),
        internalResistance: buffer.getUint16(),
        temperature: buffer.getUint8(),
        remainingCapacity: buffer.getUint8(),
        isLastDayOverconsumption: buffer.getUint8() === 1,
        averageDailyOverconsumptionCounter: buffer.getUint16()
      };
    };
    const toBytes$n = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$a, false);
      buffer.setUint16(parameters.voltageUnderLowLoad);
      buffer.setUint16(parameters.voltageUnderHighLoad);
      buffer.setUint16(parameters.internalResistance);
      buffer.setUint8(parameters.temperature);
      buffer.setUint8(parameters.remainingCapacity);
      buffer.setUint8(parameters.isLastDayOverconsumption ? 1 : 0);
      buffer.setUint16(parameters.averageDailyOverconsumptionCounter);
      return toBytes$13(id$m, buffer.data);
    };

    var channelNames = invertObject(channelTypes);

    const id$l = getChannelsStatus;
    uplinkNames[getChannelsStatus];
    const getBufferSize = channelsStatus => {
      let size = 0;
      for (let index = 0; index < channelsStatus.length; index++) {
        size += 2;
        switch (channelsStatus[index].type) {
          case BINARY_SENSOR:
          case TEMPERATURE_SENSOR:
            size += 1;
            break;
        }
      }
      return size;
    };
    const getBinarySensorStatus = buffer => ({
      state: buffer.getUint8() !== 0
    });
    const setBinarySensorStatus = (status, buffer) => {
      buffer.setUint8(status.state ? 1 : 0);
    };
    const getTemperatureSensorStatus = buffer => ({
      temperature: buffer.getInt8(),
      time2000: getTime(buffer)
    });
    const setTemperatureSensorStatus = (status, buffer) => {
      buffer.setInt8(status.temperature);
      setTime(buffer, status.time2000);
    };
    const fromBytes$m = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      const result = [];
      while (buffer.bytesLeft !== 0) {
        const type = buffer.getUint8();
        const channelStatus = {
          type,
          typeName: channelNames[type],
          channel: getChannelValue(buffer)
        };
        switch (channelStatus.type) {
          case BINARY_SENSOR:
            channelStatus.status = getBinarySensorStatus(buffer);
            break;
          case TEMPERATURE_SENSOR:
            channelStatus.status = getTemperatureSensorStatus(buffer);
            break;
        }
        result.push(channelStatus);
      }
      return result;
    };
    const toBytes$m = channelsStatus => {
      const buffer = new BinaryBuffer(getBufferSize(channelsStatus), false);
      for (let index = 0; index < channelsStatus.length; index++) {
        const {
          type,
          channel,
          status
        } = channelsStatus[index];
        buffer.setUint8(type);
        setChannelValue(buffer, channel);
        switch (type) {
          case BINARY_SENSOR:
            setBinarySensorStatus(status, buffer);
            break;
          case TEMPERATURE_SENSOR:
            setTemperatureSensorStatus(status, buffer);
            break;
        }
      }
      return toBytes$13(id$l, buffer.data);
    };

    const id$k = getChannelsTypes;
    uplinkNames[getChannelsTypes];
    const fromBytes$l = bytes => ({
      channels: bytes.map(type => ({
        type,
        typeName: channelNames[type]
      }))
    });
    const toBytes$l = ({
      channels
    }) => toBytes$13(id$k, channels.map(channel => channel.type));

    const id$j = getExAbsArchiveDaysMc;
    uplinkNames[getExAbsArchiveDaysMc];
    const COMMAND_BODY_MAX_SIZE$5 = 255;
    const fromBytes$k = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      const date = getDate(buffer);
      const channels = getChannels(buffer);
      const days = buffer.getUint8();
      const channelList = [];
      channels.forEach(channelIndex => {
        const dayList = [];
        const pulseCoefficient = getPulseCoefficient(buffer);
        channelList.push({
          pulseCoefficient,
          dayList,
          index: channelIndex
        });
        for (let day = 0; day < days; ++day) {
          const value = getExtendedValue(buffer);
          dayList.push(value === EMPTY_VALUE ? 0 : value);
        }
      });
      return {
        channelList,
        days,
        startTime2000: getTime2000FromDate(date)
      };
    };
    const toBytes$k = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$5, false);
      const {
        channelList,
        startTime2000,
        days
      } = parameters;
      setDate(buffer, startTime2000);
      setChannels(buffer, channelList);
      buffer.setUint8(days);
      channelList.forEach(({
        pulseCoefficient,
        dayList
      }) => {
        setPulseCoefficient(buffer, pulseCoefficient);
        dayList.forEach(value => {
          setExtendedValue(buffer, value === 0 ? EMPTY_VALUE : value);
        });
      });
      return toBytes$13(id$j, buffer.getBytesToOffset());
    };

    const id$i = getExAbsArchiveHoursMc;
    uplinkNames[getExAbsArchiveHoursMc];
    const COMMAND_BODY_MAX_SIZE$4 = 164;
    const fromBytes$j = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      return getChannelsValuesWithHourDiff(buffer, true);
    };
    const toBytes$j = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$4, false);
      setChannelsValuesWithHourDiff(buffer, parameters.hours, parameters.startTime2000, parameters.channelList, true);
      return toBytes$13(id$i, buffer.getBytesToOffset());
    };

    const id$h = getLmicInfo;
    uplinkNames[getLmicInfo];
    const COMMAND_BODY_SIZE$9 = 2;
    const lmicCapabilitiesBitMask = {
      isMulticastSupported: 1 << 0,
      isFragmentedDataSupported: 1 << 1
    };
    const fromBytes$i = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$9) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes);
      const capabilities = toObject(lmicCapabilitiesBitMask, buffer.getUint8());
      const version = buffer.getUint8();
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return {
        capabilities,
        version
      };
    };
    const toBytes$i = parameters => {
      const {
        capabilities,
        version
      } = parameters;
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$9);
      buffer.setUint8(fromObject(lmicCapabilitiesBitMask, capabilities));
      buffer.setUint8(version);
      return toBytes$13(id$h, buffer.data);
    };

    const id$g = getParameter;
    uplinkNames[getParameter];
    const fromBytes$h = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      return getResponseParameter(buffer);
    };
    const toBytes$h = parameters => {
      const buffer = new BinaryBuffer(getResponseParameterSize(parameters), false);
      setResponseParameter(buffer, parameters);
      return toBytes$13(id$g, buffer.data);
    };

    const id$f = signalQuality;
    uplinkNames[signalQuality];
    const COMMAND_BODY_SIZE$8 = 6;
    const fromBytes$g = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$8) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const parameters = {
        rssi: buffer.getInt8(),
        rsrp: buffer.getInt8(),
        rsrq: buffer.getInt8(),
        sinr: buffer.getInt8(),
        txPower: buffer.getInt8(),
        ecl: buffer.getUint8()
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    const toBytes$g = parameters => {
      const {
        rssi,
        rsrp,
        rsrq,
        sinr,
        txPower,
        ecl
      } = parameters;
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$8, false);
      buffer.setInt8(rssi);
      buffer.setInt8(rsrp);
      buffer.setInt8(rsrq);
      buffer.setInt8(sinr);
      buffer.setInt8(txPower);
      buffer.setUint8(ecl);
      return toBytes$13(id$f, buffer.data);
    };

    const id$e = hour;
    uplinkNames[hour];
    const fromBytes$f = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      return getLegacyHourCounterWithDiff(buffer);
    };
    const toBytes$f = parameters => {
      const buffer = new BinaryBuffer(getLegacyHourCounterSize(parameters), false);
      setLegacyHourCounterWithDiff(buffer, parameters);
      return toBytes$13(id$e, buffer.getBytesToOffset());
    };

    const id$d = hourMc;
    uplinkNames[hourMc];
    const COMMAND_BODY_MAX_SIZE$3 = 164;
    const fromBytes$e = bytes => {
      if (bytes.length > COMMAND_BODY_MAX_SIZE$3) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      return getChannelsValuesWithHourDiff(buffer);
    };
    const toBytes$e = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$3, false);
      const {
        startTime2000,
        hours,
        channelList
      } = parameters;
      setChannelsValuesWithHourDiff(buffer, hours, startTime2000, channelList);
      return toBytes$13(id$d, buffer.getBytesToOffset());
    };

    const id$c = hourMcEx;
    uplinkNames[hourMcEx];
    const COMMAND_BODY_MAX_SIZE$2 = 255;
    const fromBytes$d = bytes => {
      if (bytes.length > COMMAND_BODY_MAX_SIZE$2) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      return getChannelsValuesWithHourDiffExtended(buffer);
    };
    const toBytes$d = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$2, false);
      setChannelsValuesWithHourDiffExtended(buffer, parameters);
      return toBytes$13(id$c, buffer.getBytesToOffset());
    };

    const id$b = lastEvent;
    uplinkNames[lastEvent];
    const fromBytes$c = (bytes, config) => {
      if (!config.hardwareType) {
        throw new Error('hardwareType in config is mandatory');
      }
      const buffer = new BinaryBuffer(bytes, false);
      const sequenceNumber = buffer.getUint8();
      const status = getEventStatus(buffer, config.hardwareType);
      return {
        sequenceNumber,
        status
      };
    };
    const toBytes$c = (parameters, config) => {
      if (!config.hardwareType) {
        throw new Error('hardwareType in config is mandatory');
      }
      const buffer = new BinaryBuffer(1 + getEventStatusSize(config.hardwareType), false);
      const {
        sequenceNumber,
        status
      } = parameters;
      buffer.setUint8(sequenceNumber);
      setEventStatus(buffer, config.hardwareType, status);
      return toBytes$13(id$b, buffer.data);
    };

    const id$a = newEvent;
    uplinkNames[newEvent];
    const COMMAND_BODY_MAX_SIZE$1 = 14;
    const MTX_ADDRESS_SIZE = 8;
    const getVoltage = buffer => buffer.getUint16();
    const setVoltage = (buffer, value) => buffer.setUint16(value);
    const getDeviceId = buffer => getHexFromBytes(buffer.getBytes(MTX_ADDRESS_SIZE));
    const setDeviceId = (buffer, value) => {
      getBytesFromHex(value).forEach(byte => buffer.setUint8(byte));
    };
    const fromBytes$b = bytes => {
      if (bytes.length > COMMAND_BODY_MAX_SIZE$1) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const eventId = buffer.getUint8();
      const eventName = eventNames[eventId];
      const sequenceNumber = buffer.getUint8();
      let eventData;
      switch (eventId) {
        case MAGNET_ON:
        case MAGNET_OFF:
        case ACTIVATE:
        case DEACTIVATE:
        case CAN_OFF:
        case INSERT:
        case REMOVE:
        case COUNTER_OVER:
        case OPTOLOW:
        case OPTOFLASH:
        case JOIN_ACCEPT:
        case DEPASS_DONE:
        case WATER_NO_RESPONSE:
        case OPTOSENSOR_ERROR:
          eventData = {
            time2000: getTime(buffer)
          };
          break;
        case BATTERY_ALARM:
          eventData = {
            voltage: getVoltage(buffer)
          };
          break;
        case ACTIVATE_MTX:
          eventData = {
            time2000: getTime(buffer),
            deviceId: getDeviceId(buffer)
          };
          break;
        case CONNECT:
        case DISCONNECT:
          eventData = {
            channel: buffer.getUint8() + 1,
            value: getExtendedValue(buffer)
          };
          break;
        case MTX:
          eventData = {
            status: getEventStatus(buffer, MTXLORA)
          };
          break;
        case BINARY_SENSOR_ON:
        case BINARY_SENSOR_OFF:
          eventData = {
            time2000: getTime(buffer),
            channel: getChannelValue(buffer)
          };
          break;
        case TEMPERATURE_SENSOR_HYSTERESIS:
        case TEMPERATURE_SENSOR_LOW_TEMPERATURE:
        case TEMPERATURE_SENSOR_HIGH_TEMPERATURE:
          eventData = {
            time2000: getTime(buffer),
            channel: getChannelValue(buffer),
            temperature: buffer.getInt8()
          };
          break;
        case WATER_EVENT:
          eventData = {
            time2000: getTime(buffer),
            status: getEventStatus(buffer, US_WATER)
          };
          break;
        default:
          throw new Error(`Event ${eventId} is not supported`);
      }
      return {
        id: eventId,
        name: eventName,
        sequenceNumber,
        data: eventData
      };
    };
    const toBytes$b = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE$1, false);
      const {
        id: eventId,
        sequenceNumber,
        data
      } = parameters;
      buffer.setUint8(eventId);
      buffer.setUint8(sequenceNumber);
      switch (eventId) {
        case MAGNET_ON:
        case MAGNET_OFF:
        case ACTIVATE:
        case DEACTIVATE:
        case CAN_OFF:
        case INSERT:
        case REMOVE:
        case COUNTER_OVER:
        case OPTOLOW:
        case OPTOFLASH:
        case JOIN_ACCEPT:
        case DEPASS_DONE:
        case WATER_NO_RESPONSE:
        case OPTOSENSOR_ERROR:
          setTime(buffer, data.time2000);
          break;
        case BATTERY_ALARM:
          setVoltage(buffer, data.voltage);
          break;
        case ACTIVATE_MTX:
          setTime(buffer, data.time2000);
          setDeviceId(buffer, data.deviceId);
          break;
        case CONNECT:
        case DISCONNECT:
          buffer.setUint8(data.channel - 1);
          setExtendedValue(buffer, data.value);
          break;
        case MTX:
          setEventStatus(buffer, MTXLORA, data.status);
          break;
        case BINARY_SENSOR_ON:
        case BINARY_SENSOR_OFF:
          setTime(buffer, data.time2000);
          setChannelValue(buffer, data.channel);
          break;
        case TEMPERATURE_SENSOR_HYSTERESIS:
        case TEMPERATURE_SENSOR_LOW_TEMPERATURE:
        case TEMPERATURE_SENSOR_HIGH_TEMPERATURE:
          setTime(buffer, data.time2000);
          setChannelValue(buffer, data.channel);
          buffer.setInt8(data.temperature);
          break;
        case WATER_EVENT:
          setTime(buffer, data.time2000);
          setEventStatus(buffer, US_WATER, data.status);
          break;
        default:
          throw new Error(`Event ${eventId} is not supported`);
      }
      return toBytes$13(id$a, buffer.getBytesToOffset());
    };

    const id$9 = setParameter;
    uplinkNames[setParameter];
    const COMMAND_BODY_SIZE$7 = 2;
    const fromBytes$a = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$7) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const parameters = {
        id: buffer.getUint8(),
        status: buffer.getUint8()
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    const toBytes$a = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$7, false);
      buffer.setUint8(parameters.id);
      buffer.setUint8(parameters.status);
      return toBytes$13(id$9, buffer.data);
    };

    const id$8 = setTime2000;
    uplinkNames[setTime2000];
    const COMMAND_BODY_SIZE$6 = 1;
    const fromBytes$9 = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$6) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const parameters = {
        status: buffer.getUint8()
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    const toBytes$9 = parameters => {
      const {
        status
      } = parameters;
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$6, false);
      buffer.setUint8(status);
      return toBytes$13(id$8, buffer.data);
    };

    const id$7 = softRestart;
    uplinkNames[softRestart];
    const COMMAND_BODY_SIZE$5 = 0;
    const fromBytes$8 = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$5) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$8 = () => toBytes$13(id$7);

    const id$6 = status;
    uplinkNames[status];
    const COMMAND_BODY_MAX_SIZE = 20;
    const UNKNOWN_BATTERY_RESISTANCE = 65535;
    const UNKNOWN_BATTERY_CAPACITY = 255;
    const fromBytes$7 = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      const software = {
        type: buffer.getUint8(),
        version: buffer.getUint8()
      };
      const hardware = {
        type: buffer.getUint8(),
        version: buffer.getUint8()
      };
      let data;
      switch (hardware.type) {
        case GASI1:
        case GASI2:
        case GASI3:
        case NOVATOR:
        case IMP2EU:
        case IMP4EU:
        case IMP2AS:
        case IMP2IN:
        case IMP4IN:
        case GASIC:
        case NBIOT:
        case US_WATER:
          {
            const statusData = {
              batteryVoltage: getBatteryVoltage(buffer),
              batteryInternalResistance: buffer.getUint16(),
              temperature: buffer.getUint8(),
              remainingBatteryCapacity: buffer.getUint8(),
              lastEventSequenceNumber: buffer.getUint8()
            };
            if (statusData.batteryInternalResistance === UNKNOWN_BATTERY_RESISTANCE) {
              statusData.batteryInternalResistance = undefined;
            }
            if (statusData.remainingBatteryCapacity === UNKNOWN_BATTERY_CAPACITY) {
              statusData.remainingBatteryCapacity = undefined;
            } else if (statusData.remainingBatteryCapacity !== undefined) {
              statusData.remainingBatteryCapacity = roundNumber(statusData.remainingBatteryCapacity * 100 / (UNKNOWN_BATTERY_CAPACITY - 1), 1);
            }
            if (!buffer.isEmpty) {
              statusData.downlinkQuality = buffer.getUint8();
            }
            data = statusData;
          }
          break;
        case MTXLORA:
        case PLC2LORA:
        case LORA:
          data = {
            time2000: buffer.getUint32(),
            resetReason: buffer.getUint8(),
            rssiLastDownlinkFrame: buffer.getUint8(),
            snrLastDownlinkFrame: buffer.getUint8(),
            downlinkRequestsNumber: buffer.getUint8(),
            downlinkFragmentsNumber: buffer.getUint8(),
            uplinkResponsesNumber: buffer.getUint8(),
            uplinkFragmentsNumber: buffer.getUint8(),
            signalMarginToGateway: buffer.getUint8(),
            signalMarginFromGateway: buffer.getUint8(),
            detectedGatewaysNumber: buffer.getUint8(),
            gatewayDownlinkErrorRate: buffer.getUint8(),
            lastEventSequenceNumber: buffer.getUint8()
          };
          break;
        case ELIMP:
        default:
          throw new Error(`${id$6}: hardware type ${hardware.type} is not supported`);
      }
      return {
        software,
        hardware,
        data
      };
    };
    const toBytes$7 = parameters => {
      const {
        software,
        hardware,
        data
      } = parameters;
      const buffer = new BinaryBuffer(COMMAND_BODY_MAX_SIZE, false);
      buffer.setUint8(software.type);
      buffer.setUint8(software.version);
      buffer.setUint8(hardware.type);
      buffer.setUint8(hardware.version);
      switch (hardware.type) {
        case GASI1:
        case GASI2:
        case GASI3:
        case NOVATOR:
        case IMP2EU:
        case IMP4EU:
        case IMP2AS:
        case IMP2IN:
        case IMP4IN:
        case GASIC:
          {
            const statusData = data;
            setBatteryVoltage(buffer, statusData.batteryVoltage);
            if (statusData.batteryInternalResistance === undefined) {
              buffer.setUint16(UNKNOWN_BATTERY_RESISTANCE);
            } else {
              buffer.setUint16(statusData.batteryInternalResistance);
            }
            buffer.setUint8(statusData.temperature);
            if (statusData.remainingBatteryCapacity === undefined) {
              buffer.setUint8(UNKNOWN_BATTERY_CAPACITY);
            } else {
              buffer.setUint8(roundNumber((UNKNOWN_BATTERY_CAPACITY - 1) * (statusData.remainingBatteryCapacity / 100), 0));
            }
            buffer.setUint8(statusData.lastEventSequenceNumber);
            if ('downlinkQuality' in statusData) {
              buffer.setUint8(statusData.downlinkQuality);
            }
          }
          break;
        case MTXLORA:
          {
            const statusData = data;
            buffer.setUint32(statusData.time2000);
            buffer.setUint8(statusData.resetReason);
            buffer.setUint8(statusData.rssiLastDownlinkFrame);
            buffer.setUint8(statusData.snrLastDownlinkFrame);
            buffer.setUint8(statusData.downlinkRequestsNumber);
            buffer.setUint8(statusData.downlinkFragmentsNumber);
            buffer.setUint8(statusData.uplinkResponsesNumber);
            buffer.setUint8(statusData.uplinkFragmentsNumber);
            buffer.setUint8(statusData.signalMarginToGateway);
            buffer.setUint8(statusData.signalMarginFromGateway);
            buffer.setUint8(statusData.detectedGatewaysNumber);
            buffer.setUint8(statusData.gatewayDownlinkErrorRate);
            buffer.setUint8(statusData.lastEventSequenceNumber);
          }
          break;
        case ELIMP:
        default:
          throw new Error(`${id$6}: hardware type ${hardware.type} is not supported`);
      }
      return toBytes$13(id$6, buffer.getBytesToOffset());
    };

    const id$5 = time2000;
    uplinkNames[time2000];
    const COMMAND_BODY_SIZE$4 = 5;
    const fromBytes$6 = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$4) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      const parameters = {
        sequenceNumber: buffer.getUint8(),
        time2000: getTime(buffer)
      };
      if (!buffer.isEmpty) {
        throw new Error('BinaryBuffer is not empty.');
      }
      return parameters;
    };
    function toBytes$6(parameters) {
      const {
        sequenceNumber,
        time2000
      } = parameters;
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$4, false);
      buffer.setUint8(sequenceNumber);
      setTime(buffer, time2000);
      return toBytes$13(id$5, buffer.data);
    }

    const id$4 = updateRun;
    uplinkNames[updateRun];
    const COMMAND_BODY_SIZE$3 = 0;
    const fromBytes$5 = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$3) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$5 = () => toBytes$13(id$4);

    const id$3 = usWaterMeterBatteryStatus;
    uplinkNames[usWaterMeterBatteryStatus];
    const COMMAND_BODY_SIZE$2 = 7;
    const fromBytes$4 = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      return {
        voltage: getBatteryVoltage(buffer),
        internalResistance: buffer.getUint16(),
        lastDepassivationTime: buffer.getUint16()
      };
    };
    const toBytes$4 = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$2, false);
      setBatteryVoltage(buffer, parameters.voltage);
      buffer.setUint16(parameters.internalResistance);
      buffer.setUint16(parameters.lastDepassivationTime);
      return toBytes$13(id$3, buffer.data);
    };

    const id$2 = usWaterMeterCommand;
    uplinkNames[usWaterMeterCommand];
    const fromBytes$3 = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      const length = buffer.getUint8();
      return {
        length,
        data: bytes.slice(1)
      };
    };
    const toBytes$3 = parameters => {
      const {
        data,
        length
      } = parameters;
      const buffer = new BinaryBuffer(length, false);
      buffer.setUint8(length);
      buffer.setBytes(data);
      return toBytes$13(id$2, buffer.data);
    };

    const id$1 = verifyImage;
    uplinkNames[verifyImage];
    const COMMAND_BODY_SIZE$1 = 1;
    const fromBytes$2 = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE$1) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBuffer(bytes, false);
      return {
        status: buffer.getUint8()
      };
    };
    const toBytes$2 = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE$1, false);
      buffer.setUint8(parameters.status);
      return toBytes$13(id$1, buffer.data);
    };

    const id = writeImage;
    uplinkNames[writeImage];
    const COMMAND_BODY_SIZE = 5;
    const fromBytes$1 = bytes => {
      const buffer = new BinaryBuffer(bytes, false);
      return {
        offset: buffer.getUint32(),
        status: buffer.getUint8()
      };
    };
    const toBytes$1 = parameters => {
      const buffer = new BinaryBuffer(COMMAND_BODY_SIZE, false);
      buffer.setUint32(parameters.offset);
      buffer.setUint8(parameters.status);
      return toBytes$13(id, buffer.data);
    };

    const toBytesMap = {};
    const fromBytesMap = {};
    const nameMap = uplinkNames;
    const fromBytes = getFromBytes(fromBytesMap, nameMap);
    const toBytes = getToBytes(toBytesMap);
    const toMessage = getToMessage(toBytesMap);
    toBytesMap[id$A] = toBytes$B;
    toBytesMap[id$z] = toBytes$A;
    toBytesMap[id$y] = toBytes$z;
    toBytesMap[id$] = toBytes$11;
    toBytesMap[id$x] = toBytes$y;
    toBytesMap[id$w] = toBytes$x;
    toBytesMap[id$v] = toBytes$w;
    toBytesMap[id$u] = toBytes$v;
    toBytesMap[id$t] = toBytes$u;
    toBytesMap[id$s] = toBytes$t;
    toBytesMap[id$r] = toBytes$s;
    toBytesMap[id$q] = toBytes$r;
    toBytesMap[id$p] = toBytes$q;
    toBytesMap[id$o] = toBytes$p;
    toBytesMap[id$n] = toBytes$o;
    toBytesMap[id$m] = toBytes$n;
    toBytesMap[id$l] = toBytes$m;
    toBytesMap[id$k] = toBytes$l;
    toBytesMap[id$j] = toBytes$k;
    toBytesMap[id$i] = toBytes$j;
    toBytesMap[id$h] = toBytes$i;
    toBytesMap[id$g] = toBytes$h;
    toBytesMap[id$e] = toBytes$f;
    toBytesMap[id$d] = toBytes$e;
    toBytesMap[id$c] = toBytes$d;
    toBytesMap[id$b] = toBytes$c;
    toBytesMap[id$a] = toBytes$b;
    toBytesMap[id$9] = toBytes$a;
    toBytesMap[id$8] = toBytes$9;
    toBytesMap[id$f] = toBytes$g;
    toBytesMap[id$7] = toBytes$8;
    toBytesMap[id$6] = toBytes$7;
    toBytesMap[id$5] = toBytes$6;
    toBytesMap[id$4] = toBytes$5;
    toBytesMap[id$3] = toBytes$4;
    toBytesMap[id$2] = toBytes$3;
    toBytesMap[id$1] = toBytes$2;
    toBytesMap[id] = toBytes$1;
    fromBytesMap[id$A] = fromBytes$B;
    fromBytesMap[id$z] = fromBytes$A;
    fromBytesMap[id$y] = fromBytes$z;
    fromBytesMap[id$] = fromBytes$11;
    fromBytesMap[id$x] = fromBytes$y;
    fromBytesMap[id$w] = fromBytes$x;
    fromBytesMap[id$v] = fromBytes$w;
    fromBytesMap[id$u] = fromBytes$v;
    fromBytesMap[id$t] = fromBytes$u;
    fromBytesMap[id$s] = fromBytes$t;
    fromBytesMap[id$r] = fromBytes$s;
    fromBytesMap[id$q] = fromBytes$r;
    fromBytesMap[id$p] = fromBytes$q;
    fromBytesMap[id$o] = fromBytes$p;
    fromBytesMap[id$n] = fromBytes$o;
    fromBytesMap[id$m] = fromBytes$n;
    fromBytesMap[id$l] = fromBytes$m;
    fromBytesMap[id$k] = fromBytes$l;
    fromBytesMap[id$j] = fromBytes$k;
    fromBytesMap[id$i] = fromBytes$j;
    fromBytesMap[id$h] = fromBytes$i;
    fromBytesMap[id$g] = fromBytes$h;
    fromBytesMap[id$e] = fromBytes$f;
    fromBytesMap[id$d] = fromBytes$e;
    fromBytesMap[id$c] = fromBytes$d;
    fromBytesMap[id$b] = fromBytes$c;
    fromBytesMap[id$a] = fromBytes$b;
    fromBytesMap[id$9] = fromBytes$a;
    fromBytesMap[id$8] = fromBytes$9;
    fromBytesMap[id$f] = fromBytes$g;
    fromBytesMap[id$7] = fromBytes$8;
    fromBytesMap[id$6] = fromBytes$7;
    fromBytesMap[id$5] = fromBytes$6;
    fromBytesMap[id$4] = fromBytes$5;
    fromBytesMap[id$3] = fromBytes$4;
    fromBytesMap[id$2] = fromBytes$3;
    fromBytesMap[id$1] = fromBytes$2;
    fromBytesMap[id] = fromBytes$1;

    var uplink = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromBytes: fromBytes,
        fromBytesMap: fromBytesMap,
        nameMap: nameMap,
        toBytes: toBytes,
        toBytesMap: toBytesMap,
        toMessage: toMessage
    });

    var analogMessage = /*#__PURE__*/Object.freeze({
        __proto__: null,
        downlink: downlink,
        uplink: uplink
    });

    // export
    message = analogMessage;

})();
//#endregion
