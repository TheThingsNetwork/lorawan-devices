// encoded message should be less than this size
// to be able to send to a device
const MAX_DATA_SEGMENT_SIZE = 50;

// will have encoder/decoder after init
let message;

// helpers for data segments
let getDataSegment;
let setDataSegment;

// helper
const decode = ( fromBytes, input ) => {
    const data = {bytes: input.bytes, message: null};
    const segment = getDataSegment(input.bytes);
    const warnings = [];
    const errors = [];

    // just a single data segment
    if ( segment ) {
        const decodeResult = fromBytes(segment);

        if ( decodeResult.error ) {
            errors.push(decodeResult.error);
            // there may be some partially decoded result
            data.message = decodeResult.message;
        } else {
            data.message = decodeResult;
        }
    } else {
        warnings.push('should be present one data segment');
    }

    return {data, warnings, errors};
};

/*
  Get bytes from message.

  Input is an object with the following fields:
    * data - object with data to encode
    * data.commands - array of commands
    * data.config - object with messageId, accessLevel and aesKey
    * fPort - downlink fPort

  Output must be an object with the following fields:
    * bytes - byte array containing the downlink payload
*/
function encodeDownlink ( input ) {
    const bytes = message.downlink.toBytes(input.data.commands, input.data.config || {});
    const result = {fPort: 1};

    // send nothing if not fit in a single data segment
    if ( bytes.length > MAX_DATA_SEGMENT_SIZE ) {
        result.bytes = [];
        result.warnings = ['payload is too big for a single data segment'];
    } else {
        result.bytes = setDataSegment(bytes);
    }

    return result;
}


/*
  Get message from bytes.

  Input is an object with the following fields:
    * bytes - byte array containing the uplink payload, e.g. [255, 230, 255, 0]
    * fPort - uplink fPort

  Output must be an object with the following fields:
    * data - object representing the decoded payload
*/
function decodeUplink ( input ) {
    return decode(message.uplink.fromBytes, input);
}


/*
  Get message from bytes.

  Input is an object with the following fields:
    * bytes - byte array containing the downlink payload, e.g. [255, 230, 255, 0]
    * fPort - downlink fPort

  Output must be an object with the following fields:
    * data - object representing the decoded payload
*/
function decodeDownlink ( input ) {
    return decode(message.downlink.fromBytes, input);
}


//#region [autogenerated jooby-codec bundle from index.js]
(function () {
    'use strict';

    const hexFormatOptions = {
      separator: ' ',
      prefix: ''
    };

    const INT8_SIZE = 1;
    const INT16_SIZE = 2;
    const INT24_SIZE = 3;
    const INT32_SIZE = 4;
    const {
      log,
      pow,
      LN2
    } = Math;
    const readFloat = (buffer, offset, isLittleEndian, mLen, bytes) => {
      var e,
        m,
        eLen = bytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        nBits = -7,
        i = isLittleEndian ? bytes - 1 : 0,
        d = isLittleEndian ? -1 : 1,
        s = buffer[offset + i];
      i += d;
      e = s & (1 << -nBits) - 1;
      s >>= -nBits;
      nBits += eLen;
      for (; nBits > 0; e = e * 0x100 + buffer[offset + i], i += d, nBits -= 8);
      m = e & (1 << -nBits) - 1;
      e >>= -nBits;
      nBits += mLen;
      for (; nBits > 0; m = m * 0x100 + buffer[offset + i], i += d, nBits -= 8);
      if (e === 0) {
        e = 1 - eBias;
      } else if (e === eMax) {
        return m ? NaN : s ? -Infinity : Infinity;
      } else {
        m = m + pow(2, mLen);
        e = e - eBias;
      }
      return (s ? -1 : 1) * m * pow(2, e - mLen);
    };
    const writeFloat = (buffer, offset, value, isLittleEndian, mLen, bytes) => {
      var e,
        m,
        c,
        eLen = bytes * 8 - mLen - 1,
        eMax = (1 << eLen) - 1,
        eBias = eMax >> 1,
        rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0,
        i = isLittleEndian ? 0 : bytes - 1,
        d = isLittleEndian ? 1 : -1,
        s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
      value < 0 && (value = -value);
      if (value !== value || value === Infinity) {
        m = value !== value ? 1 : 0;
        e = eMax;
      } else {
        e = log(value) / LN2 | 0;
        if (value * (c = pow(2, -e)) < 1) {
          e--;
          c *= 2;
        }
        if (e + eBias >= 1) {
          value += rt / c;
        } else {
          value += rt * pow(2, 1 - eBias);
        }
        if (value * c >= 2) {
          e++;
          c /= 2;
        }
        if (e + eBias >= eMax) {
          m = 0;
          e = eMax;
        } else if (e + eBias >= 1) {
          m = (value * c - 1) * pow(2, mLen);
          e = e + eBias;
        } else {
          m = value * pow(2, eBias - 1) * pow(2, mLen);
          e = 0;
        }
      }
      for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 0x100, mLen -= 8);
      e = e << mLen | m;
      eLen += mLen;
      for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 0x100, eLen -= 8);
      buffer[offset + i - d] |= s * 0x80;
    };
    const be2 = [1, 0];
    const be3 = [2, 1, 0];
    const be4 = [3, 2, 1, 0];
    const le2 = [0, 1];
    const le3 = [0, 1, 2];
    const le4 = [0, 1, 2, 3];
    const readUint8 = (buffer, offset) => buffer[offset];
    const readUint16 = (buffer, offset, isLittleEndian) => {
      const order = isLittleEndian ? le2 : be2;
      const b0 = buffer[offset + order[0]];
      const b1 = buffer[offset + order[1]] << 8;
      return b0 | b1;
    };
    const readUint24 = (buffer, offset, isLittleEndian) => {
      const order = isLittleEndian ? le3 : be3;
      const b0 = buffer[offset + order[0]];
      const b1 = buffer[offset + order[1]] << 8;
      const b2 = buffer[offset + order[2]] << 16;
      return b0 | b1 | b2;
    };
    const readUint32 = (buffer, offset, isLittleEndian) => {
      const order = isLittleEndian ? le4 : be4;
      const b0 = buffer[offset + order[3]] * 0x1000000;
      const b1 = buffer[offset + order[2]] * 0x10000;
      const b2 = buffer[offset + order[1]] * 0x100;
      const b3 = buffer[offset + order[0]];
      return b0 + b1 + b2 + b3;
    };
    const writeUint8 = (buffer, offset, value) => {
      buffer[offset] = value & 0xff;
    };
    const writeUint16 = (buffer, offset, value, isLittleEndian) => {
      const order = isLittleEndian ? le2 : be2;
      buffer[offset + order[0]] = value & 0xff;
      buffer[offset + order[1]] = value >>> 8 & 0xff;
    };
    const writeUint24 = (buffer, offset, value, isLittleEndian) => {
      const order = isLittleEndian ? le3 : be3;
      buffer[offset + order[0]] = value & 0xff;
      buffer[offset + order[1]] = value >>> 8 & 0xff;
      buffer[offset + order[2]] = value >>> 16 & 0xff;
    };
    const writeUint32 = (buffer, offset, value, isLittleEndian) => {
      const order = isLittleEndian ? le4 : be4;
      buffer[offset + order[0]] = value & 0xff;
      buffer[offset + order[1]] = value >>> 8 & 0xff;
      buffer[offset + order[2]] = value >>> 16 & 0xff;
      buffer[offset + order[3]] = value >>> 24 & 0xff;
    };
    function BinaryBuffer(dataOrLength) {
      let isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      if (typeof dataOrLength === 'number') {
        const bytes = new Array(dataOrLength).fill(0);
        this.data = bytes;
      } else {
        this.data = dataOrLength;
      }
      this.offset = 0;
      this.isLittleEndian = isLittleEndian;
    }
    BinaryBuffer.prototype = {
      toUint8Array() {
        return this.data;
      },
      seek(position) {
        if (position < 0 || position >= this.data.length) {
          throw new Error('Invalid position.');
        }
        this.offset = position;
      },
      setInt8(value) {
        writeUint8(this.data, this.offset, value < 0 ? value | 0x100 : value);
        this.offset += INT8_SIZE;
      },
      getInt8() {
        const result = readUint8(this.data, this.offset);
        this.offset += INT8_SIZE;
        return result & 0x80 ? result ^ -256 : result;
      },
      setUint8(value) {
        writeUint8(this.data, this.offset, value);
        this.offset += INT8_SIZE;
      },
      getUint8() {
        const result = readUint8(this.data, this.offset);
        this.offset += INT8_SIZE;
        return result;
      },
      setInt16(value) {
        let isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeUint16(this.data, this.offset, value < 0 ? value | 0x10000 : value, isLittleEndian);
        this.offset += INT16_SIZE;
      },
      getInt16() {
        let isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        const result = readUint16(this.data, this.offset, isLittleEndian);
        this.offset += INT16_SIZE;
        return result & 0x8000 ? result ^ -65536 : result;
      },
      setUint16(value) {
        let isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeUint16(this.data, this.offset, value, isLittleEndian);
        this.offset += INT16_SIZE;
      },
      getUint16() {
        let isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        const result = readUint16(this.data, this.offset, isLittleEndian);
        this.offset += INT16_SIZE;
        return result;
      },
      setInt24(value) {
        let isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeUint24(this.data, this.offset, value < 0 ? value | 0x1000000 : value, isLittleEndian);
        this.offset += INT24_SIZE;
      },
      getInt24() {
        let isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        const result = readUint24(this.data, this.offset, isLittleEndian);
        this.offset += INT24_SIZE;
        return result & 0x800000 ? result ^ -16777216 : result;
      },
      setUint24(value) {
        let isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeUint24(this.data, this.offset, value, isLittleEndian);
        this.offset += INT24_SIZE;
      },
      getUint24() {
        let isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        const result = readUint24(this.data, this.offset, isLittleEndian);
        this.offset += INT24_SIZE;
        return result;
      },
      setInt32(value) {
        let isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeUint32(this.data, this.offset, value < 0 ? value | 0x100000000 : value, isLittleEndian);
        this.offset += INT32_SIZE;
      },
      getInt32() {
        let isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        const result = readUint32(this.data, this.offset, isLittleEndian);
        this.offset += INT32_SIZE;
        return result & 0x80000000 ? result ^ -4294967296 : result;
      },
      setUint32(value) {
        let isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeUint32(this.data, this.offset, value, isLittleEndian);
        this.offset += INT32_SIZE;
      },
      getUint32() {
        let isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        const result = readUint32(this.data, this.offset, isLittleEndian);
        this.offset += INT32_SIZE;
        return result;
      },
      setFloat32(value) {
        let isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.isLittleEndian;
        writeFloat(this.data, this.offset, value, isLittleEndian, 23, 4);
        this.offset += INT32_SIZE;
      },
      getFloat32() {
        let isLittleEndian = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.isLittleEndian;
        const result = readFloat(this.data, this.offset, isLittleEndian, 23, 4);
        this.offset += INT32_SIZE;
        return result;
      },
      setString(value) {
        this.setUint8(value.length);
        for (let index = 0; index < value.length; ++index) {
          this.setUint8(value.charCodeAt(index));
        }
      },
      getString() {
        const size = this.getUint8();
        const endIndex = this.offset + size;
        const chars = [];
        while (this.offset < endIndex) {
          chars.push(String.fromCharCode(this.getUint8()));
        }
        return chars.join('');
      },
      getBytesToOffset() {
        let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.offset;
        return this.data.slice(0, offset);
      },
      getBytesLeft() {
        return this.getBytes(this.bytesLeft);
      },
      getBytes(length) {
        let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.offset;
        this.offset = offset + length;
        return this.data.slice(offset, this.offset);
      },
      setBytes(data) {
        let offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.offset;
        const bytes = this.data;
        bytes.splice(offset, data.length, ...data);
        this.data = bytes;
        this.offset = offset + data.length;
      }
    };
    Object.defineProperties(BinaryBuffer.prototype, {
      size: {
        get() {
          return this.data.length;
        }
      },
      isEmpty: {
        get() {
          if (this.offset > this.data.length) {
            throw new Error(`current offset ${this.offset} is outside the bounds of the buffer`);
          }
          return this.data.length - this.offset === 0;
        }
      },
      bytesLeft: {
        get() {
          return this.data.length - this.offset;
        }
      },
      position: {
        get() {
          return this.offset;
        }
      }
    });

    const fromObject = function () {
      let bitMask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let booleanObject = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      let result = 0;
      for (const name in booleanObject) {
        if (name in bitMask && booleanObject[name]) {
          result |= bitMask[name];
        }
      }
      return result;
    };
    const toObject = function () {
      let bitMask = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      let value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      const result = {};
      for (const name in bitMask) {
        result[name] = (value & bitMask[name]) !== 0;
      }
      return result;
    };
    const extractBits = (value, bitsNumber, startIndex) => (1 << bitsNumber) - 1 & value >> startIndex - 1;
    const fillBits = (value, bitsNumber, startIndex, valueToSet) => {
      const mask = (1 << bitsNumber) - 1 << startIndex - 1;
      let newValueToSet = valueToSet;
      let result = value;
      result &= ~mask;
      newValueToSet <<= startIndex - 1;
      result |= newValueToSet;
      return result;
    };

    var getBytesFromHex = hex => {
      let cleanHex = hex.trim();
      if (!cleanHex) {
        return [];
      }
      cleanHex = cleanHex.replace(/0x/g, '').split(/\s+/).map(byte => byte.padStart(2, '0')).join('');
      if (cleanHex.length % 2 !== 0) {
        cleanHex = `0${cleanHex}`;
      }
      const resultLength = cleanHex.length / 2;
      const bytes = new Array(resultLength);
      for (let index = 0; index < resultLength; index++) {
        bytes[index] = parseInt(cleanHex.substring(index * 2, index * 2 + 2), 16);
      }
      return bytes;
    };

    const DEVICE_TYPE_INVALID_CHAR = 'x';
    const nibbles1 = ['.', '1', '3', 'R', 'M'];
    const nibbles2 = ['.', 'A', 'G', 'R', 'T', 'D'];
    const nibbles3 = ['.', '0', '1', '2', '3', '4', '5'];
    const nibbles4 = ['.', 'A', 'B', 'C', 'D', 'E', 'F'];
    const nibbles5 = ['.', 'A', 'B', 'C', 'D', 'E', 'F', 'H', 'K', 'G'];
    const nibbles6 = ['.', '1', '2', '3', '4'];
    const nibbles7 = ['.', 'L', 'M', 'Z', 'K'];
    const nibbles8 = ['.', '0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
    const nibbles9 = ['.', 'D', 'B', 'C', 'E', 'P', 'R', 'O', 'L', 'F', 'S', 'M', 'Y', 'G', 'N', 'U'];
    const nibbles10 = ['.', '0', '1', '2', '3', '4', '5', '6', 'P', 'R', 'L', 'E', 'G', '-', '/'];
    const nibbles11 = ['.', 'H', 'A', 'T', '0', '0', '0', '0', '0', '1', '2', '3', '4', '0', '0', '0'];
    const nibbles12 = ['.', '0', '1', '2', '3', '4', '5', '6', '7', '8', 'I', 'X', 'G', 'W', 'M', '-'];
    const splitByte = byte => [byte >> 4, byte & 0x0F];
    const splitToNibbles = data => {
      const result = new Array(data.length * 2).fill(0);
      data.forEach((byte, index) => {
        const [high, low] = splitByte(byte);
        result[index * 2] = high;
        result[index * 2 + 1] = low;
      });
      return result;
    };
    const joinNibbles = nibbles => {
      const hex = [];
      nibbles.forEach(nibble => hex.push(nibble.toString(16)));
      if (nibbles.length & 1) {
        hex.push('0');
      }
      return getBytesFromHex(hex.join(''));
    };
    const fromBytesMtx = nibbles => {
      if (nibbles.length !== 14 && nibbles.length !== 16) {
        throw new Error('Device type bytes wrong size');
      }
      const type = ['MTX '];
      type.push(nibbles1[nibbles[0]] ?? DEVICE_TYPE_INVALID_CHAR);
      type.push(nibbles2[nibbles[1]] ?? DEVICE_TYPE_INVALID_CHAR);
      type.push(nibbles3[nibbles[2]] ?? DEVICE_TYPE_INVALID_CHAR);
      type.push(nibbles3[nibbles[3]] ?? DEVICE_TYPE_INVALID_CHAR);
      type.push('.');
      type.push(nibbles4[nibbles[4]] ?? DEVICE_TYPE_INVALID_CHAR);
      type.push(nibbles5[nibbles[5]] ?? DEVICE_TYPE_INVALID_CHAR);
      type.push('.');
      type.push(nibbles6[nibbles[6]] ?? DEVICE_TYPE_INVALID_CHAR);
      type.push(nibbles7[nibbles[7]] ?? DEVICE_TYPE_INVALID_CHAR);
      const revision = nibbles[8];
      type.push(nibbles8[nibbles[9]] ?? DEVICE_TYPE_INVALID_CHAR);
      type.push('-');
      let deviceProtocolIndex;
      if (nibbles.length < 14 || nibbles[12] === 0 && nibbles[13] === 0) {
        type.push(nibbles9[nibbles[10]] ?? DEVICE_TYPE_INVALID_CHAR);
        deviceProtocolIndex = 11;
      } else if (nibbles[13] === 0) {
        type.push(nibbles9[nibbles[10]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push(nibbles9[nibbles[11]] ?? DEVICE_TYPE_INVALID_CHAR);
        deviceProtocolIndex = 12;
      } else {
        type.push(nibbles9[nibbles[10]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push(nibbles9[nibbles[11]] ?? DEVICE_TYPE_INVALID_CHAR);
        type.push(nibbles9[nibbles[12]] ?? DEVICE_TYPE_INVALID_CHAR);
        deviceProtocolIndex = 13;
      }
      const deviceProtocolNibble = nibbles[deviceProtocolIndex];
      if (deviceProtocolNibble && deviceProtocolNibble !== 0) {
        type.push(nibbles11[deviceProtocolNibble] ?? DEVICE_TYPE_INVALID_CHAR);
      }
      return {
        type: type.join(''),
        revision,
        meterType: 0
      };
    };
    const toBytesMtx = (type, prefix, revision) => {
      const nibbles = [];
      if (type.length < 11) {
        throw new Error('Wrong format');
      }
      nibbles.push(nibbles1.indexOf(type[0]));
      nibbles.push(nibbles2.indexOf(type[1]));
      nibbles.push(nibbles3.indexOf(type[2]));
      nibbles.push(nibbles3.indexOf(type[3]));
      if (type[4] !== '.') {
        throw new Error('Wrong format');
      }
      nibbles.push(nibbles4.indexOf(type[5]));
      nibbles.push(nibbles5.indexOf(type[6]));
      if (type[7] !== '.') {
        throw new Error('Wrong format');
      }
      nibbles.push(nibbles6.indexOf(type[8]));
      nibbles.push(nibbles7.indexOf(type[9]));
      nibbles.push(revision ?? 0);
      nibbles.push(nibbles8.indexOf(type[10]));
      if (type[11] !== '-') {
        throw new Error('Wrong format');
      }
      const deviceProtocolIndex = type.length > 13 ? type.length - 1 : type.length;
      for (let index = 12; index < deviceProtocolIndex; index++) {
        nibbles.push(nibbles9.indexOf(type[index]));
      }
      if (deviceProtocolIndex < type.length) {
        nibbles.push(nibbles11.indexOf(type[deviceProtocolIndex]));
      }
      const bytes = joinNibbles(nibbles);
      const result = new Array(9).fill(0);
      result[0] = 0;
      for (let index = 0; index < bytes.length; index++) {
        result[index + (bytes.length < 8 ? 1 : 0)] = bytes[index];
      }
      return result;
    };
    const fromBytesMtx2 = nibbles => {
      if (nibbles.length < 14) {
        throw new Error('The buffer is too small');
      }
      const type = ['MTX '];
      const separator = nibbles[1] === 5 ? '-' : ' ';
      type.push(nibbles1[nibbles[0]] ?? DEVICE_TYPE_INVALID_CHAR);
      type.push(nibbles2[nibbles[1]] ?? DEVICE_TYPE_INVALID_CHAR);
      type.push(separator);
      for (let index = 2; index < nibbles.length; index++) {
        if (nibbles[index] !== 0) {
          type.push(nibbles10[nibbles[index]] ?? DEVICE_TYPE_INVALID_CHAR);
        }
      }
      return {
        type: type.join(''),
        meterType: 0
      };
    };
    const toBytesMtx2 = type => {
      if (type.length < 3) {
        throw new Error('Wrong format');
      }
      const nibbles = [];
      nibbles.push(nibbles1.indexOf(type[0]));
      nibbles.push(nibbles2.indexOf(type[1]));
      for (let index = 3; index < type.length; index++) {
        nibbles.push(nibbles10.indexOf(type[index]));
      }
      const bytes = joinNibbles(nibbles);
      if (bytes.length === 8) {
        return bytes;
      }
      if (bytes.length > 8) {
        throw new Error('Wrong format');
      }
      const result = new Array(8).fill(0);
      for (let index = 0; index < bytes.length; index++) {
        result[index] = bytes[index];
      }
      return result;
    };
    const fromBytesM = nibbles => {
      if (nibbles.length < 14) {
        throw new Error('The buffer is too small');
      }
      const type = [];
      type.push(nibbles1[nibbles[0]] ?? DEVICE_TYPE_INVALID_CHAR);
      for (let index = 1; index < nibbles.length; index++) {
        if (nibbles[index] !== 0) {
          type.push(nibbles12[nibbles[index]] ?? DEVICE_TYPE_INVALID_CHAR);
        }
      }
      return {
        type: type.join(''),
        meterType: 0
      };
    };
    const toBytesM = type => {
      if (type.length < 1) {
        throw new Error('Wrong format');
      }
      const nibbles = [];
      nibbles.push(nibbles1.indexOf(type[0]));
      for (let index = 1; index < type.length; index++) {
        nibbles.push(nibbles12.indexOf(type[index]));
      }
      const bytes = joinNibbles(nibbles);
      const result = new Array(8).fill(0);
      for (let index = 0; index < bytes.length && index < 8; index++) {
        result[index] = bytes[index];
      }
      return result;
    };
    const fromBytes$23 = bytes => {
      if (bytes.length !== 9) {
        throw new Error('The buffer is too small');
      }
      let result;
      const reserve = [0x00, 0x05, 0x06, 0x07, 0x09, 0x7f, 0xef];
      const position = reserve.indexOf(bytes[0]) !== -1 ? 2 : 0;
      const nibbles = splitToNibbles(bytes.slice(0, 8));
      const deviceTypeNibble = nibbles[position];
      const deviceType = nibbles1[deviceTypeNibble];
      if (deviceType === '1' || deviceType === '3') {
        result = fromBytesMtx(nibbles.slice(position));
      } else {
        result = deviceType === 'M' ? fromBytesM(nibbles) : fromBytesMtx2(nibbles);
      }
      result.meterType = bytes[8];
      return result;
    };
    const toBytes$24 = (_ref, prefix) => {
      let {
        type,
        revision,
        meterType
      } = _ref;
      if (!type.startsWith('MTX ')) {
        throw new Error('Wrong format');
      }
      let result;
      const content = type.substring(4);
      const deviceTypeSymbol = type[4];
      if (deviceTypeSymbol === '1' || deviceTypeSymbol === '3') {
        result = toBytesMtx(content, prefix, revision);
      } else {
        result = deviceTypeSymbol === 'M' ? toBytesM(content) : toBytesMtx2(content);
      }
      result[8] = meterType;
      return result;
    };

    var getHexFromBytes = (function (bytes) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const {
        separator,
        prefix
      } = Object.assign({}, hexFormatOptions, options);
      return bytes.map(byte => `${prefix}${byte.toString(16).padStart(2, '0')}`).join(separator);
    });

    const DATA_REQUEST = 0x50;
    const DATA_RESPONSE = 0x51;
    const IDENT_REQUEST = 0x52;
    const IDENT_RESPONSE = 0x53;
    const L2_SET_ADDRESS_REQUEST = 0x54;
    const L2_SET_ADDRESS_RESPONSE = 0x55;
    const L2_CHECK_ADDRESS_REQUEST = 0x56;
    const L2_CHECK_ADDRESS_RESPONSE = 0x57;
    const L2_RM_ADDRESS_REQUEST = 0x58;
    const L2_RM_ADDRESS_RESPONSE = 0x59;
    const FRAGMENT_REQUEST = 0x5A;
    const FRAGMENT_RESPONSE = 0x5B;
    const INVALID = 0xFF;

    var frameTypes = /*#__PURE__*/Object.freeze({
        __proto__: null,
        DATA_REQUEST: DATA_REQUEST,
        DATA_RESPONSE: DATA_RESPONSE,
        FRAGMENT_REQUEST: FRAGMENT_REQUEST,
        FRAGMENT_RESPONSE: FRAGMENT_RESPONSE,
        IDENT_REQUEST: IDENT_REQUEST,
        IDENT_RESPONSE: IDENT_RESPONSE,
        INVALID: INVALID,
        L2_CHECK_ADDRESS_REQUEST: L2_CHECK_ADDRESS_REQUEST,
        L2_CHECK_ADDRESS_RESPONSE: L2_CHECK_ADDRESS_RESPONSE,
        L2_RM_ADDRESS_REQUEST: L2_RM_ADDRESS_REQUEST,
        L2_RM_ADDRESS_RESPONSE: L2_RM_ADDRESS_RESPONSE,
        L2_SET_ADDRESS_REQUEST: L2_SET_ADDRESS_REQUEST,
        L2_SET_ADDRESS_RESPONSE: L2_SET_ADDRESS_RESPONSE
    });

    var invertObject = source => {
      const target = {};
      for (const property in source) {
        const value = source[property];
        target[value] = property;
      }
      return target;
    };

    var frameNames = invertObject(frameTypes);

    const ENERGY_REG_FAULT = 0x01;
    const VENDOR_PAR_FAULT = 0x02;
    const OP_PAR_FAULT = 0x03;
    const ACCESS_CLOSED = 0x10;
    const ERR_ACCESS = 0x11;
    const CASE_OPEN$1 = 0x12;
    const CASE_CLOSE = 0x13;
    const MAGNETIC_ON$1 = 0x14;
    const MAGNETIC_OFF = 0x15;
    const CHANGE_ACCESS_KEY0 = 0x20;
    const CHANGE_ACCESS_KEY1 = 0x21;
    const CHANGE_ACCESS_KEY2 = 0x22;
    const CHANGE_ACCESS_KEY3 = 0x23;
    const CHANGE_PAR_LOCAL = 0x24;
    const CHANGE_PAR_REMOTE = 0x25;
    const CMD_CHANGE_TIME = 0x26;
    const CMD_RELAY_ON = 0x27;
    const CMD_RELAY_OFF = 0x28;
    const CHANGE_COR_TIME = 0x29;
    const ENERGY_REG_OVERFLOW = 0x31;
    const CHANGE_TARIFF_TBL = 0x32;
    const SET_TARIFF_TBL = 0x33;
    const SUMMER_TIME = 0x34;
    const WINTER_TIME = 0x35;
    const RELAY_ON = 0x36;
    const RELAY_OFF = 0x37;
    const RESTART$1 = 0x38;
    const WD_RESTART = 0x39;
    const V_MAX_OK = 0x40;
    const V_MAX_OVER = 0x41;
    const V_MIN_OK = 0x42;
    const V_MIN_OVER = 0x43;
    const T_MAX_OK = 0x44;
    const T_MAX_OVER = 0x45;
    const T_MIN_OK = 0x46;
    const T_MIN_OVER = 0x47;
    const F_MAX_OK = 0x48;
    const F_MAX_OVER = 0x49;
    const F_MIN_OK = 0x4A;
    const F_MIN_OVER = 0x4B;
    const I_MAX_OK = 0x4C;
    const I_MAX_OVER = 0x4D;
    const P_MAX_OK = 0x4E;
    const P_MAX_OVER = 0x4F;
    const POWERSALDO_OK = 0x50;
    const POWERSALDO_OVER = 0x51;
    const BAT_OK = 0x52;
    const BAT_FAULT = 0x53;
    const CAL_OK = 0x54;
    const CAL_FAULT = 0x55;
    const CLOCK_OK = 0x56;
    const CLOCK_FAULT = 0x57;
    const POWER_A_OFF = 0x58;
    const POWER_A_ON = 0x59;
    const CMD_RELAY_2_ON = 0x60;
    const CMD_RELAY_2_OFF = 0x61;
    const CROSSZERO_ENT0 = 0x62;
    const CROSSZERO_ENT1 = 0x63;
    const CROSSZERO_ENT2 = 0x64;
    const CROSSZERO_ENT3 = 0x65;
    const CALFLAG_SET = 0x66;
    const CALFLAG_RESET = 0x67;
    const BAD_TEST_EEPROM = 0x68;
    const BAD_TEST_FRAM = 0x69;
    const SET_NEW_SALDO = 0x70;
    const SALDO_PARAM_BAD = 0x71;
    const ACCPARAM_BAD = 0x72;
    const ACCPARAM_EXT_BAD = 0x73;
    const CALC_PERIOD_BAD = 0x74;
    const BLOCK_TARIFF_BAD = 0x75;
    const CALIBR_PARAM_BAD = 0x76;
    const WINTER_SUMMER_BAD = 0x77;
    const SALDO_EN_BAD = 0x78;
    const TIME_CORRECT$1 = 0x79;
    const CASE_TERMINAL_OPEN$1 = 0x7A;
    const CASE_TERMINAL_CLOSE = 0x7B;
    const CASE_MODULE_OPEN$1 = 0x7C;
    const CASE_MODULE_CLOSE = 0x7D;
    const RELAY_HARD_BAD_OFF = 0x90;
    const RELAY_HARD_ON = 0x91;
    const RELAY_HARD_BAD_ON = 0x93;
    const RELAY_HARD_OFF = 0x94;
    const SET_SALDO_PARAM = 0x9C;
    const POWER_OVER_RELAY_OFF = 0x9D;
    const CROSSZERO_EXP_ENT0 = 0x9E;
    const CROSSZERO_EXP_ENT1 = 0x9F;
    const CROSSZERO_EXP_ENT2 = 0xA0;
    const CROSSZERO_EXP_ENT3 = 0xA1;
    const TIME_CORRECT_NEW = 0xA2;
    const EM_MAGNETIC_ON = 0xB0;
    const EM_MAGNETIC_OFF = 0xB1;
    const CURRENT_UNEQUIL_FAULT = 0xB2;
    const CURRENT_UNEQUIL_OK = 0xB3;
    const BIPOLAR_POWER_FAULT = 0xB4;
    const BIPOLAR_POWER_OK = 0xB5;
    const RESET_EM_FLAG = 0xB6;
    const RESET_MAGN_FLAG = 0xB7;
    const NVRAM_FAULT = 0xD0;
    const SET_DEMAND_EN_1MIN = 0xE0;
    const SET_DEMAND_EN_3MIN = 0xE1;
    const SET_DEMAND_EN_5MIN = 0xE2;
    const SET_DEMAND_EN_10MIN = 0xE3;
    const SET_DEMAND_EN_15MIN = 0xE4;
    const SET_DEMAND_EN_30MIN = 0xE5;
    const SET_DEMAND_EN_60MIN = 0xE6;

    var events = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACCESS_CLOSED: ACCESS_CLOSED,
        ACCPARAM_BAD: ACCPARAM_BAD,
        ACCPARAM_EXT_BAD: ACCPARAM_EXT_BAD,
        BAD_TEST_EEPROM: BAD_TEST_EEPROM,
        BAD_TEST_FRAM: BAD_TEST_FRAM,
        BAT_FAULT: BAT_FAULT,
        BAT_OK: BAT_OK,
        BIPOLAR_POWER_FAULT: BIPOLAR_POWER_FAULT,
        BIPOLAR_POWER_OK: BIPOLAR_POWER_OK,
        BLOCK_TARIFF_BAD: BLOCK_TARIFF_BAD,
        CALC_PERIOD_BAD: CALC_PERIOD_BAD,
        CALFLAG_RESET: CALFLAG_RESET,
        CALFLAG_SET: CALFLAG_SET,
        CALIBR_PARAM_BAD: CALIBR_PARAM_BAD,
        CAL_FAULT: CAL_FAULT,
        CAL_OK: CAL_OK,
        CASE_CLOSE: CASE_CLOSE,
        CASE_MODULE_CLOSE: CASE_MODULE_CLOSE,
        CASE_MODULE_OPEN: CASE_MODULE_OPEN$1,
        CASE_OPEN: CASE_OPEN$1,
        CASE_TERMINAL_CLOSE: CASE_TERMINAL_CLOSE,
        CASE_TERMINAL_OPEN: CASE_TERMINAL_OPEN$1,
        CHANGE_ACCESS_KEY0: CHANGE_ACCESS_KEY0,
        CHANGE_ACCESS_KEY1: CHANGE_ACCESS_KEY1,
        CHANGE_ACCESS_KEY2: CHANGE_ACCESS_KEY2,
        CHANGE_ACCESS_KEY3: CHANGE_ACCESS_KEY3,
        CHANGE_COR_TIME: CHANGE_COR_TIME,
        CHANGE_PAR_LOCAL: CHANGE_PAR_LOCAL,
        CHANGE_PAR_REMOTE: CHANGE_PAR_REMOTE,
        CHANGE_TARIFF_TBL: CHANGE_TARIFF_TBL,
        CLOCK_FAULT: CLOCK_FAULT,
        CLOCK_OK: CLOCK_OK,
        CMD_CHANGE_TIME: CMD_CHANGE_TIME,
        CMD_RELAY_2_OFF: CMD_RELAY_2_OFF,
        CMD_RELAY_2_ON: CMD_RELAY_2_ON,
        CMD_RELAY_OFF: CMD_RELAY_OFF,
        CMD_RELAY_ON: CMD_RELAY_ON,
        CROSSZERO_ENT0: CROSSZERO_ENT0,
        CROSSZERO_ENT1: CROSSZERO_ENT1,
        CROSSZERO_ENT2: CROSSZERO_ENT2,
        CROSSZERO_ENT3: CROSSZERO_ENT3,
        CROSSZERO_EXP_ENT0: CROSSZERO_EXP_ENT0,
        CROSSZERO_EXP_ENT1: CROSSZERO_EXP_ENT1,
        CROSSZERO_EXP_ENT2: CROSSZERO_EXP_ENT2,
        CROSSZERO_EXP_ENT3: CROSSZERO_EXP_ENT3,
        CURRENT_UNEQUIL_FAULT: CURRENT_UNEQUIL_FAULT,
        CURRENT_UNEQUIL_OK: CURRENT_UNEQUIL_OK,
        EM_MAGNETIC_OFF: EM_MAGNETIC_OFF,
        EM_MAGNETIC_ON: EM_MAGNETIC_ON,
        ENERGY_REG_FAULT: ENERGY_REG_FAULT,
        ENERGY_REG_OVERFLOW: ENERGY_REG_OVERFLOW,
        ERR_ACCESS: ERR_ACCESS,
        F_MAX_OK: F_MAX_OK,
        F_MAX_OVER: F_MAX_OVER,
        F_MIN_OK: F_MIN_OK,
        F_MIN_OVER: F_MIN_OVER,
        I_MAX_OK: I_MAX_OK,
        I_MAX_OVER: I_MAX_OVER,
        MAGNETIC_OFF: MAGNETIC_OFF,
        MAGNETIC_ON: MAGNETIC_ON$1,
        NVRAM_FAULT: NVRAM_FAULT,
        OP_PAR_FAULT: OP_PAR_FAULT,
        POWERSALDO_OK: POWERSALDO_OK,
        POWERSALDO_OVER: POWERSALDO_OVER,
        POWER_A_OFF: POWER_A_OFF,
        POWER_A_ON: POWER_A_ON,
        POWER_OVER_RELAY_OFF: POWER_OVER_RELAY_OFF,
        P_MAX_OK: P_MAX_OK,
        P_MAX_OVER: P_MAX_OVER,
        RELAY_HARD_BAD_OFF: RELAY_HARD_BAD_OFF,
        RELAY_HARD_BAD_ON: RELAY_HARD_BAD_ON,
        RELAY_HARD_OFF: RELAY_HARD_OFF,
        RELAY_HARD_ON: RELAY_HARD_ON,
        RELAY_OFF: RELAY_OFF,
        RELAY_ON: RELAY_ON,
        RESET_EM_FLAG: RESET_EM_FLAG,
        RESET_MAGN_FLAG: RESET_MAGN_FLAG,
        RESTART: RESTART$1,
        SALDO_EN_BAD: SALDO_EN_BAD,
        SALDO_PARAM_BAD: SALDO_PARAM_BAD,
        SET_DEMAND_EN_10MIN: SET_DEMAND_EN_10MIN,
        SET_DEMAND_EN_15MIN: SET_DEMAND_EN_15MIN,
        SET_DEMAND_EN_1MIN: SET_DEMAND_EN_1MIN,
        SET_DEMAND_EN_30MIN: SET_DEMAND_EN_30MIN,
        SET_DEMAND_EN_3MIN: SET_DEMAND_EN_3MIN,
        SET_DEMAND_EN_5MIN: SET_DEMAND_EN_5MIN,
        SET_DEMAND_EN_60MIN: SET_DEMAND_EN_60MIN,
        SET_NEW_SALDO: SET_NEW_SALDO,
        SET_SALDO_PARAM: SET_SALDO_PARAM,
        SET_TARIFF_TBL: SET_TARIFF_TBL,
        SUMMER_TIME: SUMMER_TIME,
        TIME_CORRECT: TIME_CORRECT$1,
        TIME_CORRECT_NEW: TIME_CORRECT_NEW,
        T_MAX_OK: T_MAX_OK,
        T_MAX_OVER: T_MAX_OVER,
        T_MIN_OK: T_MIN_OK,
        T_MIN_OVER: T_MIN_OVER,
        VENDOR_PAR_FAULT: VENDOR_PAR_FAULT,
        V_MAX_OK: V_MAX_OK,
        V_MAX_OVER: V_MAX_OVER,
        V_MIN_OK: V_MIN_OK,
        V_MIN_OVER: V_MIN_OVER,
        WD_RESTART: WD_RESTART,
        WINTER_SUMMER_BAD: WINTER_SUMMER_BAD,
        WINTER_TIME: WINTER_TIME
    });

    var eventNames = invertObject(events);

    const defaultFrameHeader = {
      type: DATA_REQUEST,
      destination: 0xffff,
      source: 0xfffe
    };
    const TARIFF_PLAN_SIZE = 11;
    const OPERATOR_PARAMETERS_SIZE = 74;
    const SEASON_PROFILE_DAYS_NUMBER = 7;
    const SEASON_PROFILE_SIZE = 2 + SEASON_PROFILE_DAYS_NUMBER;
    const TARIFF_NUMBER$1 = 4;
    const PACKED_ENERGY_TYPE_SIZE = 1;
    const ENERGY_SIZE = 4;
    const DATE_SIZE$3 = 3;
    const MIN_HALF_HOUR_PERIODS = 48;
    const MAX_HALF_HOUR_PERIODS = 50;
    const MIN_HALF_HOUR_COMMAND_SIZE = 3 + MIN_HALF_HOUR_PERIODS * 2;
    const MAX_HALF_HOUR_COMMAND_SIZE = 4 + MAX_HALF_HOUR_PERIODS * 2;
    const baseDisplaySetMask = {
      SET_ALL_SEGMENT_DISPLAY: 0x0001,
      SOFTWARE_VERSION: 0x0002,
      TOTAL_ACTIVE_ENERGY: 0x0004,
      ACTIVE_ENERGY_T1: 0x0008,
      ACTIVE_ENERGY_T2: 0x0010,
      ACTIVE_ENERGY_T3: 0x0020,
      ACTIVE_ENERGY_T4: 0x0040,
      ACTIVE_POWER_PER_PHASE: 0x0080,
      ACTIVE_POWER_IN_NEUTRAL: 0x0100,
      CURRENT_IN_PHASE: 0x0200,
      CURRENT_IN_NEUTRAL: 0x0400,
      VOLTAGE: 0x0800,
      HOUR_MINUTE_SECOND: 0x1000,
      DATE_MONTH_YEAR: 0x2000,
      TOTAL_EXPORTED_ACTIVE_ENERGY: 0x4000,
      EXPORTED_ACTIVE_ENERGY_T1: 0x8000,
      EXPORTED_ACTIVE_ENERGY_T2: 0x00010000,
      EXPORTED_ACTIVE_ENERGY_T3: 0x00020000,
      EXPORTED_ACTIVE_ENERGY_T4: 0x00040000,
      POWER_COEFFICIENT_PHASE_A: 0x00080000,
      POWER_COEFFICIENT_PHASE_B: 0x00100000,
      BATTERY_VOLTAGE: 0x00200000,
      POWER_THRESHOLD_T1: 0x00400000,
      POWER_THRESHOLD_T2: 0x00800000,
      POWER_THRESHOLD_T3: 0x01000000,
      POWER_THRESHOLD_T4: 0x02000000,
      CURRENT_BALANCE: 0x20000000
    };
    const displaySetMask = {
      ...baseDisplaySetMask,
      AUTO_SCREEN_SCROLLING: 0x80000000
    };
    const displaySetExtMask = {
      ...baseDisplaySetMask,
      MAGNET_INDUCTION: 0x08000000,
      OPTOPORT_SPEED: 0x40000000,
      SORT_DISPLAY_SCREENS: 0x80000000
    };
    const relaySet1Mask = {
      RELAY_ON_Y: 0x01,
      RELAY_ON_CENTER: 0x02,
      RELAY_ON_PB: 0x04,
      RELAY_ON_TARIFF_0: 0x08,
      RELAY_ON_TARIFF_1: 0x10,
      RELAY_ON_TARIFF_2: 0x20,
      RELAY_ON_TARIFF_3: 0x40,
      RELAY_ON_V_GOOD: 0x80
    };
    const relaySet2Mask = {
      RELAY_OFF_Y: 0x01,
      RELAY_OFF_CENTER: 0x02,
      RELAY_OFF_TARIFF_0: 0x04,
      RELAY_OFF_TARIFF_1: 0x08,
      RELAY_OFF_TARIFF_2: 0x10,
      RELAY_OFF_TARIFF_3: 0x20,
      RELAY_OFF_I_LIMIT: 0x40,
      RELAY_OFF_V_BAD: 0x80
    };
    const relaySet3Mask = {
      RELAY_OFF_LIM_TARIFF_0: 0x02,
      RELAY_OFF_LIM_TARIFF_1: 0x04,
      RELAY_OFF_LIM_TARIFF_2: 0x08,
      RELAY_OFF_LIM_TARIFF_3: 0x10,
      RELAY_OFF_PF_MIN: 0x20
    };
    const relaySet4Mask = {
      RELAY_ON_TIMEOUT: 0x01,
      RELAY_ON_SALDO: 0x02,
      RELAY_OFF_SALDO: 0x04,
      RELAY_OFF_SALDO_SOFT: 0x08,
      RELAY_OFF_MAGNET: 0x10,
      RELAY_ON_MAGNET_TIMEOUT: 0x20,
      RELAY_ON_MAGNET_AUTO: 0x40
    };
    const relaySet5Mask = {
      RELAY_OFF_UNEQUAL_CURRENT: 0x01,
      RELAY_ON_UNEQUAL_CURRENT: 0x02,
      RELAY_OFF_BIPOLAR_POWER: 0x04,
      RELAY_ON_BIPOLAR_POWER: 0x08
    };
    const define1Mask = {
      BLOCK_KEY_OPTOPORT: 0x02,
      MAGNET_SCREEN_CONST: 0x20
    };
    const eventStatusMask = {
      CASE_OPEN: 2 ** 0,
      MAGNETIC_ON: 2 ** 1,
      PARAMETERS_UPDATE_REMOTE: 2 ** 2,
      PARAMETERS_UPDATE_LOCAL: 2 ** 3,
      RESTART: 2 ** 4,
      ERROR_ACCESS: 2 ** 5,
      TIME_SET: 2 ** 6,
      TIME_CORRECT: 2 ** 7,
      DEVICE_FAILURE: 2 ** 8,
      CASE_TERMINAL_OPEN: 2 ** 9,
      CASE_MODULE_OPEN: 2 ** 10,
      TARIFF_TABLE_SET: 2 ** 11,
      TARIFF_TABLE_GET: 2 ** 12,
      PROTECTION_RESET_EM: 2 ** 13,
      PROTECTION_RESET_MAGNETIC: 2 ** 14
    };
    const extendedCurrentValues2RelayStatusMask = {
      RELAY_STATE: 2 ** 0,
      RELAY_UBAD: 2 ** 1,
      RELAY_UNEQ_CURRENT: 2 ** 4,
      RELAY_OFF_CENTER: 2 ** 5,
      RELAY_IMAX: 2 ** 6,
      RELAY_PMAX: 2 ** 7
    };
    const extendedCurrentValues2RelayStatus2Mask = {
      RELAY_COSFI: 2 ** 0,
      RELAY_SALDO_OFF_FLAG: 2 ** 1,
      RELAY_UNEQUIL_CURRENT_OFF: 2 ** 2,
      RELAY_BIPOLAR_POWER_OFF: 2 ** 3,
      RELAY_SALDO_OFF_ON_MAX_POWER: 2 ** 4,
      RELAY_HARD_ST1: 2 ** 5
    };
    const extendedCurrentValues2Status1Mask = {
      MAXVA: 2 ** 0,
      MINVA: 2 ** 1,
      MAXT: 2 ** 2,
      MINT: 2 ** 3,
      MAXF: 2 ** 4,
      MINF: 2 ** 5,
      MAXIA: 2 ** 6,
      MAXP: 2 ** 7
    };
    const extendedCurrentValues2Status2Mask = {
      MAX_POWER_SALDO: 2 ** 0,
      BATTERY_VBAT_BAD: 2 ** 1,
      CLOCK_UNSET: 2 ** 3,
      MIN_COS_FI: 2 ** 5
    };
    const extendedCurrentValues2Status3Mask = {
      UNEQUIL_CURRENT: 2 ** 0,
      BIPOLAR_POWER: 2 ** 1,
      POWER_A_NEGATIVE: 2 ** 6,
      POWER_B_NEGATIVE: 2 ** 7
    };
    const operatorParametersExtended3RelaySetMask = {
      RELAY_OFF_LIMIT_P_MINUS_T1: 0x04,
      RELAY_OFF_LIMIT_P_MINUS_T2: 0x08,
      RELAY_OFF_LIMIT_P_MINUS_T3: 0x10,
      RELAY_OFF_LIMIT_P_MINUS_T4: 0x20
    };
    function getPackedEnergies(buffer, energyType, tariffMapByte) {
      const byte = tariffMapByte >> TARIFF_NUMBER$1;
      const energies = new Array(TARIFF_NUMBER$1).fill(0);
      energies.forEach((energy, index) => {
        const isTariffExists = !!extractBits(byte, 1, index + 1);
        if (isTariffExists) {
          energies[index] = buffer.getUint32();
        } else {
          energies[index] = null;
        }
      });
      return energies;
    }
    function setPackedEnergyType(buffer, energyType, energies) {
      const indexShift = 1 + TARIFF_NUMBER$1;
      let tariffsByte = energyType;
      energies.forEach((energy, index) => {
        tariffsByte = fillBits(tariffsByte, 1, index + indexShift, Number(!!energy));
      });
      buffer.setUint8(tariffsByte);
    }
    function getEnergyPeriod(period) {
      if (period === 0xffff) {
        return {
          tariff: undefined,
          energy: undefined
        };
      }
      return {
        tariff: period >> 14 & 0x03,
        energy: period & 0x3fff
      };
    }
    function setEnergyPeriod(buffer, _ref) {
      let {
        tariff,
        energy
      } = _ref;
      if (tariff !== undefined && energy !== undefined) {
        buffer.setUint16(tariff << 14 | energy & 0x3fff);
      } else {
        buffer.setUint16(0xffff);
      }
    }
    function CommandBinaryBuffer$1(dataOrLength) {
      let isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      BinaryBuffer.call(this, dataOrLength, isLittleEndian);
    }
    CommandBinaryBuffer$1.prototype = Object.create(BinaryBuffer.prototype);
    CommandBinaryBuffer$1.prototype.constructor = CommandBinaryBuffer$1;
    CommandBinaryBuffer$1.getDayProfileFromByte = value => ({
      tariff: extractBits(value, 2, 1),
      isFirstHalfHour: !extractBits(value, 1, 3),
      hour: extractBits(value, 5, 4)
    });
    CommandBinaryBuffer$1.getByteFromDayProfile = dayProfile => {
      let value = 0;
      value = fillBits(value, 2, 1, dayProfile.tariff);
      value = fillBits(value, 1, 3, +!dayProfile.isFirstHalfHour);
      value = fillBits(value, 5, 4, dayProfile.hour);
      return value;
    };
    CommandBinaryBuffer$1.getDefaultSeasonProfile = () => ({
      month: 1,
      date: 1,
      dayIndexes: [0, 0, 0, 0, 0, 0, 0]
    });
    CommandBinaryBuffer$1.getDefaultOperatorParameters = () => ({
      vpThreshold: 265000,
      vThreshold: 156000,
      ipThreshold: 120000,
      pmaxThreshold0: 31800,
      pmaxThreshold1: 31800,
      pmaxThreshold2: 31800,
      pmaxThreshold3: 31800,
      speedOptoPort: 0,
      tint: 30,
      calcPeriodDate: 1,
      timeoutDisplay: 127,
      timeoutScreen: 7,
      displaySet: toObject(displaySetMask, 0x80003184),
      relaySet4: toObject(relaySet4Mask, 0),
      relaySet3: toObject(relaySet3Mask, 0),
      relaySet2: toObject(relaySet2Mask, 3),
      relaySet1: toObject(relaySet1Mask, 3),
      displayType: 0,
      ten: 0,
      timeoutRefresh: 240,
      deltaCorMin: 15,
      timeoutMagnetOff: 5,
      timeoutMagnetOn: 5,
      define1: toObject(define1Mask, 0),
      timeoutRelayOn: 1,
      timeoutRelayKey: 0,
      timeoutRelayAuto: 5,
      timeoutBadVAVB: 5,
      freqMax: 55,
      freqMin: 45,
      phMin: 0,
      year: 0,
      month: 0,
      date: 0,
      energyDecimalPoint: 2,
      typeMeter: 0,
      timeoutIMax: 5,
      timeoutPMax: 5,
      timeoutCos: 5,
      pMaxDef: 1,
      displaySetExt: toObject(displaySetExtMask, 0x8383fff),
      timeoutUneqCurrent: 5,
      timeoutBipolarPower: 5,
      relaySet5: toObject(relaySet5Mask, 0),
      timeCorrectPeriod: 24,
      timeCorrectPassHalfhour: false
    });
    CommandBinaryBuffer$1.prototype.getFrameHeader = function () {
      const type = this.getUint8();
      const typeName = frameNames[type];
      const destination = this.getUint16();
      const source = this.getUint16();
      return {
        type,
        typeName,
        destination,
        source
      };
    };
    CommandBinaryBuffer$1.prototype.setFrameHeader = function (_ref2) {
      let {
        type = defaultFrameHeader.type,
        destination = defaultFrameHeader.destination,
        source = defaultFrameHeader.source
      } = _ref2;
      this.setUint8(type);
      this.setUint16(destination);
      this.setUint16(source);
    };
    CommandBinaryBuffer$1.prototype.getDeviceId = function () {
      const manufacturer = getHexFromBytes(this.getBytes(3), {
        separator: ''
      });
      const type = this.getUint8();
      const year = this.getUint8();
      const serial = getHexFromBytes(this.getBytes(3), {
        separator: ''
      });
      return {
        manufacturer,
        type,
        year,
        serial
      };
    };
    CommandBinaryBuffer$1.prototype.setDeviceId = function (_ref3) {
      let {
        manufacturer,
        type,
        year,
        serial
      } = _ref3;
      this.setBytes(getBytesFromHex(manufacturer));
      this.setUint8(type);
      this.setUint8(year);
      this.setBytes(getBytesFromHex(serial));
    };
    CommandBinaryBuffer$1.prototype.getDateTime = function () {
      return {
        isSummerTime: !!this.getUint8(),
        seconds: this.getUint8(),
        minutes: this.getUint8(),
        hours: this.getUint8(),
        day: this.getUint8(),
        date: this.getUint8(),
        month: this.getUint8(),
        year: this.getUint8()
      };
    };
    CommandBinaryBuffer$1.prototype.setDateTime = function (dateTime) {
      this.setUint8(dateTime.isSummerTime ? 1 : 0);
      this.setUint8(dateTime.seconds);
      this.setUint8(dateTime.minutes);
      this.setUint8(dateTime.hours);
      this.setUint8(dateTime.day || 0);
      this.setUint8(dateTime.date);
      this.setUint8(dateTime.month);
      this.setUint8(dateTime.year);
    };
    CommandBinaryBuffer$1.prototype.getTariffPlan = function () {
      return {
        id: this.getUint32(),
        tariffSet: this.getUint8(),
        activateYear: this.getUint8(),
        activateMonth: this.getUint8(),
        activateDay: this.getUint8(),
        specialProfilesArraySize: this.getUint8(),
        seasonProfilesArraySize: this.getUint8(),
        dayProfilesArraySize: this.getUint8()
      };
    };
    CommandBinaryBuffer$1.prototype.setTariffPlan = function (tariffPlan) {
      this.setUint32(tariffPlan.id);
      this.setUint8(tariffPlan.tariffSet);
      this.setUint8(tariffPlan.activateYear);
      this.setUint8(tariffPlan.activateMonth);
      this.setUint8(tariffPlan.activateDay);
      this.setUint8(tariffPlan.specialProfilesArraySize);
      this.setUint8(tariffPlan.seasonProfilesArraySize);
      this.setUint8(tariffPlan.dayProfilesArraySize);
    };
    CommandBinaryBuffer$1.prototype.getTimeCorrectionParameters = function () {
      return {
        monthTransitionSummer: this.getUint8(),
        dateTransitionSummer: this.getUint8(),
        hoursTransitionSummer: this.getUint8(),
        hoursCorrectSummer: this.getUint8(),
        monthTransitionWinter: this.getUint8(),
        dateTransitionWinter: this.getUint8(),
        hoursTransitionWinter: this.getUint8(),
        hoursCorrectWinter: this.getUint8(),
        isCorrectionNeeded: this.getUint8() === 1
      };
    };
    CommandBinaryBuffer$1.prototype.setTimeCorrectionParameters = function (parameters) {
      this.setUint8(parameters.monthTransitionSummer);
      this.setUint8(parameters.dateTransitionSummer);
      this.setUint8(parameters.hoursTransitionSummer);
      this.setUint8(parameters.hoursCorrectSummer);
      this.setUint8(parameters.monthTransitionWinter);
      this.setUint8(parameters.dateTransitionWinter);
      this.setUint8(parameters.hoursTransitionWinter);
      this.setUint8(parameters.hoursCorrectWinter);
      this.setUint8(+parameters.isCorrectionNeeded);
    };
    CommandBinaryBuffer$1.prototype.getDayProfile = function () {
      return CommandBinaryBuffer$1.getDayProfileFromByte(this.getUint8());
    };
    CommandBinaryBuffer$1.prototype.setDayProfile = function (dayProfile) {
      this.setUint8(CommandBinaryBuffer$1.getByteFromDayProfile(dayProfile));
    };
    CommandBinaryBuffer$1.prototype.getSeasonProfile = function () {
      return {
        month: this.getUint8(),
        date: this.getUint8(),
        dayIndexes: new Array(SEASON_PROFILE_DAYS_NUMBER).fill(0).map(() => this.getUint8())
      };
    };
    CommandBinaryBuffer$1.prototype.setSeasonProfile = function (seasonProfile) {
      this.setUint8(seasonProfile.month);
      this.setUint8(seasonProfile.date);
      seasonProfile.dayIndexes.forEach(value => this.setUint8(value));
    };
    CommandBinaryBuffer$1.prototype.getSpecialDay = function () {
      return {
        month: this.getUint8(),
        date: this.getUint8(),
        dayIndex: this.getUint8(),
        isPeriodic: this.getUint8() === 0
      };
    };
    CommandBinaryBuffer$1.prototype.setSpecialDay = function (specialDay) {
      this.setUint8(specialDay.month);
      this.setUint8(specialDay.date);
      this.setUint8(specialDay.dayIndex);
      this.setUint8(+!specialDay.isPeriodic);
    };
    CommandBinaryBuffer$1.prototype.getDeviceType = function () {
      return fromBytes$23(this.getBytes(9));
    };
    CommandBinaryBuffer$1.prototype.setDeviceType = function (deviceType) {
      this.setBytes(toBytes$24(deviceType));
    };
    CommandBinaryBuffer$1.prototype.getOperatorParameters = function () {
      const operatorParameters = {
        vpThreshold: this.getUint32(),
        vThreshold: this.getUint32(),
        ipThreshold: this.getUint32(),
        pmaxThreshold0: this.getUint32(),
        pmaxThreshold1: this.getUint32(),
        pmaxThreshold2: this.getUint32(),
        pmaxThreshold3: this.getUint32(),
        speedOptoPort: this.getUint8(),
        tint: this.getUint8(),
        calcPeriodDate: this.getUint8(),
        timeoutDisplay: this.getUint8(),
        timeoutScreen: this.getUint8(),
        displaySet: toObject(displaySetMask, this.getUint32()),
        relaySet4: toObject(relaySet4Mask, this.getUint8()),
        relaySet3: toObject(relaySet3Mask, this.getUint8()),
        relaySet2: toObject(relaySet2Mask, this.getUint8()),
        relaySet1: toObject(relaySet1Mask, this.getUint8()),
        displayType: this.getUint8(),
        ten: this.getUint8(),
        timeoutRefresh: this.getUint16(),
        deltaCorMin: this.getUint8(),
        timeoutMagnetOff: this.getUint8(),
        timeoutMagnetOn: this.getUint8(),
        define1: toObject(define1Mask, this.getUint8()),
        timeoutRelayOn: this.getUint8(),
        timeoutRelayKey: this.getUint8(),
        timeoutRelayAuto: this.getUint8(),
        timeoutBadVAVB: this.getUint8(),
        freqMax: this.getUint8(),
        freqMin: this.getUint8(),
        phMin: this.getUint16(),
        year: this.getUint8(),
        month: this.getUint8(),
        date: this.getUint8(),
        energyDecimalPoint: this.getUint8(),
        typeMeter: this.getUint8(),
        timeoutIMax: this.getUint8(),
        timeoutPMax: this.getUint8(),
        timeoutCos: this.getUint8(),
        pMaxDef: this.getUint8(),
        displaySetExt: toObject(displaySetExtMask, this.getUint32()),
        timeoutUneqCurrent: this.getUint8(),
        timeoutBipolarPower: this.getUint8(),
        relaySet5: toObject(relaySet5Mask, this.getUint8()),
        timeCorrectPeriod: 0,
        timeCorrectPassHalfhour: false
      };
      const timeCorrectPeriod = this.getUint8();
      operatorParameters.timeCorrectPeriod = timeCorrectPeriod & 0x7f;
      operatorParameters.timeCorrectPassHalfhour = !!(timeCorrectPeriod & 0x80);
      return operatorParameters;
    };
    CommandBinaryBuffer$1.prototype.setOperatorParameters = function (operatorParameters) {
      const timeCorrectPeriod = operatorParameters.timeCorrectPeriod | (operatorParameters.timeCorrectPassHalfhour ? 0x80 : 0);
      this.setUint32(operatorParameters.vpThreshold);
      this.setUint32(operatorParameters.vThreshold);
      this.setUint32(operatorParameters.ipThreshold);
      this.setUint32(operatorParameters.pmaxThreshold0);
      this.setUint32(operatorParameters.pmaxThreshold1);
      this.setUint32(operatorParameters.pmaxThreshold2);
      this.setUint32(operatorParameters.pmaxThreshold3);
      this.setUint8(operatorParameters.speedOptoPort);
      this.setUint8(operatorParameters.tint);
      this.setUint8(operatorParameters.calcPeriodDate);
      this.setUint8(operatorParameters.timeoutDisplay);
      this.setUint8(operatorParameters.timeoutScreen);
      this.setUint32(fromObject(displaySetMask, operatorParameters.displaySet));
      this.setUint8(fromObject(relaySet4Mask, operatorParameters.relaySet4));
      this.setUint8(fromObject(relaySet3Mask, operatorParameters.relaySet3));
      this.setUint8(fromObject(relaySet2Mask, operatorParameters.relaySet2));
      this.setUint8(fromObject(relaySet1Mask, operatorParameters.relaySet1));
      this.setUint8(operatorParameters.displayType);
      this.setUint8(operatorParameters.ten);
      this.setUint16(operatorParameters.timeoutRefresh);
      this.setUint8(operatorParameters.deltaCorMin);
      this.setUint8(operatorParameters.timeoutMagnetOff);
      this.setUint8(operatorParameters.timeoutMagnetOn);
      this.setUint8(fromObject(define1Mask, operatorParameters.define1));
      this.setUint8(operatorParameters.timeoutRelayOn);
      this.setUint8(operatorParameters.timeoutRelayKey);
      this.setUint8(operatorParameters.timeoutRelayAuto);
      this.setUint8(operatorParameters.timeoutBadVAVB);
      this.setUint8(operatorParameters.freqMax);
      this.setUint8(operatorParameters.freqMin);
      this.setUint16(operatorParameters.phMin);
      this.setUint8(operatorParameters.year);
      this.setUint8(operatorParameters.month);
      this.setUint8(operatorParameters.date);
      this.setUint8(operatorParameters.energyDecimalPoint);
      this.setUint8(operatorParameters.typeMeter);
      this.setUint8(operatorParameters.timeoutIMax);
      this.setUint8(operatorParameters.timeoutPMax);
      this.setUint8(operatorParameters.timeoutCos);
      this.setUint8(operatorParameters.pMaxDef);
      this.setUint32(fromObject(displaySetExtMask, operatorParameters.displaySetExt));
      this.setUint8(operatorParameters.timeoutUneqCurrent);
      this.setUint8(operatorParameters.timeoutBipolarPower);
      this.setUint8(fromObject(relaySet5Mask, operatorParameters.relaySet5));
      this.setUint8(timeCorrectPeriod);
    };
    CommandBinaryBuffer$1.prototype.getPackedEnergyWithType = function () {
      const byte = this.getUint8();
      const energyType = extractBits(byte, TARIFF_NUMBER$1, 1);
      const energies = getPackedEnergies(this, energyType, byte);
      return {
        energyType,
        energies
      };
    };
    CommandBinaryBuffer$1.prototype.setPackedEnergyWithType = function (_ref4) {
      let {
        energyType,
        energies
      } = _ref4;
      if (energyType) {
        setPackedEnergyType(this, energyType, energies);
      }
      energies.forEach(energy => {
        if (energy !== null) {
          this.setUint32(energy);
        }
      });
    };
    CommandBinaryBuffer$1.prototype.getEnergies = function () {
      return new Array(TARIFF_NUMBER$1).fill(0).map(() => this.getInt32());
    };
    CommandBinaryBuffer$1.prototype.setEnergies = function (energies) {
      energies.forEach(value => this.setUint32(value));
    };
    CommandBinaryBuffer$1.prototype.getDate = function () {
      return {
        year: this.getUint8(),
        month: this.getUint8(),
        date: this.getUint8()
      };
    };
    CommandBinaryBuffer$1.prototype.setDate = function (date) {
      this.setUint8(date.year);
      this.setUint8(date.month);
      this.setUint8(date.date);
    };
    CommandBinaryBuffer$1.prototype.getSaldoParameters = function () {
      return {
        coefficients: new Array(4).fill(0).map(() => this.getUint32()),
        decimalPointTariff: this.getUint8(),
        indicationThreshold: this.getInt32(),
        relayThreshold: this.getInt32(),
        mode: this.getUint8(),
        saldoOffTimeBegin: this.getUint8(),
        saldoOffTimeEnd: this.getUint8(),
        decimalPointIndication: this.getUint8(),
        powerThreshold: this.getUint32(),
        creditThreshold: this.getInt32()
      };
    };
    CommandBinaryBuffer$1.prototype.setSaldoParameters = function (saldoParameters) {
      saldoParameters.coefficients.forEach(value => this.setUint32(value));
      this.setUint8(saldoParameters.decimalPointTariff);
      this.setInt32(saldoParameters.indicationThreshold);
      this.setInt32(saldoParameters.relayThreshold);
      this.setUint8(saldoParameters.mode);
      this.setUint8(saldoParameters.saldoOffTimeBegin);
      this.setUint8(saldoParameters.saldoOffTimeEnd);
      this.setUint8(saldoParameters.decimalPointIndication);
      this.setUint32(saldoParameters.powerThreshold);
      this.setInt32(saldoParameters.creditThreshold);
    };
    CommandBinaryBuffer$1.prototype.getEnergyPeriods = function (periodsNumber) {
      const periods = new Array(periodsNumber).fill(0).map(() => this.getUint16());
      return periods.map(period => getEnergyPeriod(period));
    };
    CommandBinaryBuffer$1.prototype.setEnergyPeriods = function (periods) {
      periods.forEach(period => setEnergyPeriod(this, period));
    };
    CommandBinaryBuffer$1.prototype.getEventStatus = function () {
      const eventStatus = this.getUint16();
      return toObject(eventStatusMask, eventStatus);
    };
    CommandBinaryBuffer$1.prototype.setEventStatus = function (parameters) {
      this.setUint16(fromObject(eventStatusMask, parameters));
    };
    CommandBinaryBuffer$1.prototype.getExtendedCurrentValues2 = function () {
      const uBattery = this.getUint16();
      const relayStatus = toObject(extendedCurrentValues2RelayStatusMask, this.getUint8());
      const relayStatus2 = toObject(extendedCurrentValues2RelayStatus2Mask, this.getUint8());
      const status1 = toObject(extendedCurrentValues2Status1Mask, this.getUint8());
      const status2 = toObject(extendedCurrentValues2Status2Mask, this.getUint8());
      const status3 = toObject(extendedCurrentValues2Status3Mask, this.getUint8());
      return {
        uBattery,
        relayStatus,
        relayStatus2,
        status1,
        status2,
        status3
      };
    };
    CommandBinaryBuffer$1.prototype.setExtendedCurrentValues2 = function (parameters) {
      const {
        uBattery,
        relayStatus,
        relayStatus2,
        status1,
        status2,
        status3
      } = parameters;
      this.setUint16(uBattery);
      this.setUint8(fromObject(extendedCurrentValues2RelayStatusMask, relayStatus));
      this.setUint8(fromObject(extendedCurrentValues2RelayStatus2Mask, relayStatus2));
      this.setUint8(fromObject(extendedCurrentValues2Status1Mask, status1));
      this.setUint8(fromObject(extendedCurrentValues2Status2Mask, status2));
      this.setUint8(fromObject(extendedCurrentValues2Status3Mask, status3));
    };
    CommandBinaryBuffer$1.prototype.getEvent = function () {
      const data = {
        hours: this.getUint8(),
        minutes: this.getUint8(),
        seconds: this.getUint8(),
        event: this.getUint8()
      };
      const {
        event
      } = data;
      const {
        bytesLeft
      } = this;
      data.eventName = eventNames[event];
      switch (event) {
        case POWER_OVER_RELAY_OFF:
          if (bytesLeft < 4) {
            return data;
          }
          data.power = [this.getUint8(), this.getUint8(), this.getUint8(), this.getUint8()];
          break;
        case CMD_CHANGE_TIME:
        case TIME_CORRECT$1:
          if (bytesLeft < 8) {
            return data;
          }
          data.newDate = this.getDateTime();
          break;
      }
      return data;
    };
    CommandBinaryBuffer$1.prototype.setEvent = function (event) {
      this.setUint8(event.hours);
      this.setUint8(event.minutes);
      this.setUint8(event.seconds);
      this.setUint8(event.event);
      switch (event.event) {
        case POWER_OVER_RELAY_OFF:
          for (const item of event.power) {
            this.setUint8(item);
          }
          break;
        case CMD_CHANGE_TIME:
        case TIME_CORRECT$1:
          this.setDateTime(event.newDate);
          break;
      }
    };
    CommandBinaryBuffer$1.prototype.getDemand = function () {
      const date0 = this.getUint8();
      const date1 = this.getUint8();
      return {
        date: {
          year: date0 >> 1,
          month: date0 << 3 & 0x0f | date1 >> 5,
          date: date1 & 0x1f
        },
        energyType: this.getUint8(),
        firstIndex: this.getUint16(),
        count: this.getUint8(),
        period: this.getUint8()
      };
    };
    CommandBinaryBuffer$1.prototype.setDemand = function (parameters) {
      const date0 = parameters.date.year << 1 | parameters.date.month >> 3 & 0x01;
      const date1 = parameters.date.month << 5 & 0xe0 | parameters.date.date & 0x1f;
      this.setUint8(date0);
      this.setUint8(date1);
      this.setUint8(parameters.energyType);
      this.setUint16(parameters.firstIndex);
      this.setUint8(parameters.count);
      this.setUint8(parameters.period);
    };
    CommandBinaryBuffer$1.prototype.getDayMaxDemandResponse = function () {
      const date = this.getDate();
      const power = new Array(TARIFF_NUMBER$1).fill(0).map(() => ({
        hours: this.getUint8(),
        minutes: this.getUint8(),
        power: this.getUint32()
      }));
      return {
        date,
        power
      };
    };
    CommandBinaryBuffer$1.prototype.setDayMaxDemandResponse = function (parameters) {
      this.setDate(parameters.date);
      parameters.power.forEach(value => {
        this.setUint8(value.hours);
        this.setUint8(value.minutes);
        this.setUint32(value.power);
      });
    };
    CommandBinaryBuffer$1.prototype.getOperatorParametersExtended3 = function () {
      return {
        pmaxMinusThreshold0: this.getUint32(),
        pmaxMinusThreshold1: this.getUint32(),
        pmaxMinusThreshold2: this.getUint32(),
        pmaxMinusThreshold3: this.getUint32(),
        relaySet: toObject(operatorParametersExtended3RelaySetMask, this.getUint8())
      };
    };
    CommandBinaryBuffer$1.prototype.setOperatorParametersExtended3 = function (parameters) {
      const {
        pmaxMinusThreshold0,
        pmaxMinusThreshold1,
        pmaxMinusThreshold2,
        pmaxMinusThreshold3,
        relaySet
      } = parameters;
      this.setUint32(pmaxMinusThreshold0);
      this.setUint32(pmaxMinusThreshold1);
      this.setUint32(pmaxMinusThreshold2);
      this.setUint32(pmaxMinusThreshold3);
      this.setUint8(fromObject(operatorParametersExtended3RelaySetMask, relaySet));
    };
    CommandBinaryBuffer$1.prototype.getMonthMaxPowerByTariffs = function () {
      return new Array(TARIFF_NUMBER$1).fill(0).map(() => ({
        date: this.getUint8(),
        hours: this.getUint8(),
        minutes: this.getUint8(),
        power: this.getUint32()
      }));
    };
    CommandBinaryBuffer$1.prototype.setMonthMaxPowerByTariffs = function (tariffs) {
      tariffs.forEach(tariff => {
        this.setUint8(tariff.date);
        this.setUint8(tariff.hours);
        this.setUint8(tariff.minutes);
        this.setUint32(tariff.power);
      });
    };
    const getPackedEnergiesWithDateSize = parameters => {
      if (parameters?.energyType) {
        const energiesNumber = parameters.energies.filter(energy => energy !== null).length;
        return DATE_SIZE$3 + PACKED_ENERGY_TYPE_SIZE + energiesNumber * ENERGY_SIZE;
      }
      return DATE_SIZE$3 + ENERGY_SIZE * TARIFF_NUMBER$1;
    };

    const toBytes$23 = function (commandId) {
      let commandBytes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      return [commandId, commandBytes.length, ...commandBytes];
    };

    const UNENCRYPTED = 0x00;
    const READ_ONLY = 0x03;

    const getEventStatus = 0x01;
    const getEnergyDayPrevious = 0x03;
    const getDeviceType = 0x04;
    const getDeviceId = 0x05;
    const getDateTime = 0x07;
    const setDateTime = 0x08;
    const setAccessKey = 0x09;
    const getCurrentValues = 0x0d;
    const getEnergy = 0x0f;
    const setDayProfile = 0x10;
    const setSeasonProfile = 0x11;
    const setSpecialDay = 0x12;
    const activateRatePlan = 0x13;
    const prepareRatePlan = 0x14;
    const getHalfHourDemand = 0x15;
    const getDayDemand = 0x16;
    const getMonthDemand = 0x17;
    const turnRelayOn = 0x18;
    const turnRelayOff = 0x19;
    const setCorrectTime = 0x1c;
    const getOperatorParameters = 0x1e;
    const setOperatorParameters = 0x1f;
    const getVersion = 0x28;
    const getSaldo = 0x29;
    const setSaldo = 0x2a;
    const getRatePlanInfo = 0x2c;
    const getExtendedCurrentValues2 = 0x2d;
    const getSaldoParameters = 0x2e;
    const setSaldoParameters = 0x2f;
    const getDayMaxDemand = 0x31;
    const getMonthMaxDemand = 0x32;
    const getEvents = 0x33;
    const getEventsCounters = 0x34;
    const resetPowerMaxDay = 0x35;
    const resetPowerMaxMonth = 0x36;
    const getCurrentStatusMeter = 0x39;
    const getExtendedCurrentValues = 0x3a;
    const getDayProfile = 0x3b;
    const getSeasonProfile = 0x3c;
    const getSpecialDay = 0x3d;
    const getCorrectTime = 0x3e;
    const getCriticalEvent = 0x41;
    const runTariffPlan = 0x46;
    const getDayMaxDemandPrevious = 0x4a;
    const getHalfHourDemandPrevious = 0x4b;
    const getDayDemandExport = 0x4f;
    const getEnergyExportDayPrevious = 0x50;
    const getMonthDemandExport = 0x52;
    const getHalfHourDemandExport = 0x53;
    const getDayMaxDemandExport = 0x58;
    const getMonthMaxDemandExport = 0x59;
    const getEnergyExport = 0x5b;
    const setCorrectDateTime = 0x5c;
    const setDisplayParam = 0x5d;
    const getDisplayParam = 0x5e;
    const setSpecialOperation = 0x64;
    const getMagneticFieldThreshold = 0x6d;
    const getHalfhoursEnergies = 0x6f;
    const getBuildVersion = 0x70;
    const getOperatorParametersExtended3 = 0x71;
    const setOperatorParametersExtended3 = 0x72;
    const getDemand = 0x76;
    const getMeterInfo = 0x7a;

    var downlinkIds = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activateRatePlan: activateRatePlan,
        getBuildVersion: getBuildVersion,
        getCorrectTime: getCorrectTime,
        getCriticalEvent: getCriticalEvent,
        getCurrentStatusMeter: getCurrentStatusMeter,
        getCurrentValues: getCurrentValues,
        getDateTime: getDateTime,
        getDayDemand: getDayDemand,
        getDayDemandExport: getDayDemandExport,
        getDayMaxDemand: getDayMaxDemand,
        getDayMaxDemandExport: getDayMaxDemandExport,
        getDayMaxDemandPrevious: getDayMaxDemandPrevious,
        getDayProfile: getDayProfile,
        getDemand: getDemand,
        getDeviceId: getDeviceId,
        getDeviceType: getDeviceType,
        getDisplayParam: getDisplayParam,
        getEnergy: getEnergy,
        getEnergyDayPrevious: getEnergyDayPrevious,
        getEnergyExport: getEnergyExport,
        getEnergyExportDayPrevious: getEnergyExportDayPrevious,
        getEventStatus: getEventStatus,
        getEvents: getEvents,
        getEventsCounters: getEventsCounters,
        getExtendedCurrentValues: getExtendedCurrentValues,
        getExtendedCurrentValues2: getExtendedCurrentValues2,
        getHalfHourDemand: getHalfHourDemand,
        getHalfHourDemandExport: getHalfHourDemandExport,
        getHalfHourDemandPrevious: getHalfHourDemandPrevious,
        getHalfhoursEnergies: getHalfhoursEnergies,
        getMagneticFieldThreshold: getMagneticFieldThreshold,
        getMeterInfo: getMeterInfo,
        getMonthDemand: getMonthDemand,
        getMonthDemandExport: getMonthDemandExport,
        getMonthMaxDemand: getMonthMaxDemand,
        getMonthMaxDemandExport: getMonthMaxDemandExport,
        getOperatorParameters: getOperatorParameters,
        getOperatorParametersExtended3: getOperatorParametersExtended3,
        getRatePlanInfo: getRatePlanInfo,
        getSaldo: getSaldo,
        getSaldoParameters: getSaldoParameters,
        getSeasonProfile: getSeasonProfile,
        getSpecialDay: getSpecialDay,
        getVersion: getVersion,
        prepareRatePlan: prepareRatePlan,
        resetPowerMaxDay: resetPowerMaxDay,
        resetPowerMaxMonth: resetPowerMaxMonth,
        runTariffPlan: runTariffPlan,
        setAccessKey: setAccessKey,
        setCorrectDateTime: setCorrectDateTime,
        setCorrectTime: setCorrectTime,
        setDateTime: setDateTime,
        setDayProfile: setDayProfile,
        setDisplayParam: setDisplayParam,
        setOperatorParameters: setOperatorParameters,
        setOperatorParametersExtended3: setOperatorParametersExtended3,
        setSaldo: setSaldo,
        setSaldoParameters: setSaldoParameters,
        setSeasonProfile: setSeasonProfile,
        setSpecialDay: setSpecialDay,
        setSpecialOperation: setSpecialOperation,
        turnRelayOff: turnRelayOff,
        turnRelayOn: turnRelayOn
    });

    var downlinkNames = invertObject(downlinkIds);

    const id$20 = activateRatePlan;
    downlinkNames[activateRatePlan];
    const maxSize$1C = 1 + TARIFF_PLAN_SIZE;
    const fromBytes$22 = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        tariffTable: buffer.getUint8(),
        tariffPlan: buffer.getTariffPlan()
      };
    };
    const toBytes$22 = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1C);
      buffer.setUint8(parameters.tariffTable);
      buffer.setTariffPlan(parameters.tariffPlan);
      return toBytes$23(id$20, buffer.data);
    };

    const id$1$ = getBuildVersion;
    downlinkNames[getBuildVersion];
    const maxSize$1B = 0;
    const fromBytes$21 = bytes => {
      if (bytes.length !== maxSize$1B) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$21 = () => toBytes$23(id$1$);

    const id$1_ = getCorrectTime;
    downlinkNames[getCorrectTime];
    const maxSize$1A = 0;
    const fromBytes$20 = bytes => {
      if (bytes.length !== maxSize$1A) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$20 = () => toBytes$23(id$1_);

    const CASE_OPEN = 0;
    const MAGNETIC_ON = 1;
    const PARAMETERS_UPDATE_REMOTE = 2;
    const PARAMETERS_UPDATE_LOCAL = 3;
    const RESTART = 4;
    const ERROR_ACCESS = 5;
    const TIME_SET = 6;
    const TIME_CORRECT = 7;
    const DEVICE_FAILURE = 8;
    const CASE_TERMINAL_OPEN = 9;
    const CASE_MODULE_OPEN = 10;
    const TARIFF_TABLE_SET = 11;
    const TARIFF_TABLE_GET = 12;
    const PROTECTION_RESET_EM = 13;
    const PROTECTION_RESET_MAGNETIC = 14;

    var criticalEvents = /*#__PURE__*/Object.freeze({
        __proto__: null,
        CASE_MODULE_OPEN: CASE_MODULE_OPEN,
        CASE_OPEN: CASE_OPEN,
        CASE_TERMINAL_OPEN: CASE_TERMINAL_OPEN,
        DEVICE_FAILURE: DEVICE_FAILURE,
        ERROR_ACCESS: ERROR_ACCESS,
        MAGNETIC_ON: MAGNETIC_ON,
        PARAMETERS_UPDATE_LOCAL: PARAMETERS_UPDATE_LOCAL,
        PARAMETERS_UPDATE_REMOTE: PARAMETERS_UPDATE_REMOTE,
        PROTECTION_RESET_EM: PROTECTION_RESET_EM,
        PROTECTION_RESET_MAGNETIC: PROTECTION_RESET_MAGNETIC,
        RESTART: RESTART,
        TARIFF_TABLE_GET: TARIFF_TABLE_GET,
        TARIFF_TABLE_SET: TARIFF_TABLE_SET,
        TIME_CORRECT: TIME_CORRECT,
        TIME_SET: TIME_SET
    });

    var criticalEventNames = invertObject(criticalEvents);

    const id$1Z = getCriticalEvent;
    downlinkNames[getCriticalEvent];
    const maxSize$1z = 2;
    const fromBytes$1$ = bytes => {
      if (bytes.length !== maxSize$1z) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const [event, index] = bytes;
      return {
        event,
        name: criticalEventNames[event],
        index
      };
    };
    const toBytes$1$ = parameters => toBytes$23(id$1Z, [parameters.event, parameters.index]);

    const id$1Y = getCurrentStatusMeter;
    downlinkNames[getCurrentStatusMeter];
    const maxSize$1y = 0;
    const fromBytes$1_ = bytes => {
      if (bytes.length !== maxSize$1y) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1_ = () => toBytes$23(id$1Y);

    const id$1X = getCurrentValues;
    downlinkNames[getCurrentValues];
    const maxSize$1x = 0;
    const fromBytes$1Z = bytes => {
      if (bytes.length !== maxSize$1x) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1Z = () => toBytes$23(id$1X);

    const id$1W = getDateTime;
    downlinkNames[getDateTime];
    const maxSize$1w = 0;
    const fromBytes$1Y = bytes => {
      if (bytes.length !== maxSize$1w) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1Y = () => toBytes$23(id$1W);

    const MIN_COMMAND_SIZE$5 = 3;
    const MAX_COMMAND_SIZE$5 = 4;
    const id$1V = getDayDemand;
    downlinkNames[getDayDemand];
    const fromBytes$1X = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      if (bytes.length === MAX_COMMAND_SIZE$5) {
        return {
          date: buffer.getDate(),
          energyType: buffer.getUint8()
        };
      }
      return {
        date: buffer.getDate()
      };
    };
    const toBytes$1X = parameters => {
      const buffer = new CommandBinaryBuffer$1(parameters?.energyType ? MAX_COMMAND_SIZE$5 : MIN_COMMAND_SIZE$5);
      buffer.setDate(parameters?.date);
      if (parameters?.energyType) {
        buffer.setUint8(parameters.energyType);
      }
      return toBytes$23(id$1V, buffer.data);
    };

    const MIN_COMMAND_SIZE$4 = 3;
    const MAX_COMMAND_SIZE$4 = 4;
    const id$1U = getDayDemandExport;
    downlinkNames[getDayDemandExport];
    const fromBytes$1W = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      if (bytes.length === MAX_COMMAND_SIZE$4) {
        return {
          date: buffer.getDate(),
          energyType: buffer.getUint8()
        };
      }
      return {
        date: buffer.getDate()
      };
    };
    const toBytes$1W = parameters => {
      const buffer = new CommandBinaryBuffer$1(parameters?.energyType ? MAX_COMMAND_SIZE$4 : MIN_COMMAND_SIZE$4);
      buffer.setDate(parameters?.date);
      if (parameters?.energyType) {
        buffer.setUint8(parameters.energyType);
      }
      return toBytes$23(id$1U, buffer.data);
    };

    const id$1T = getDayMaxDemand;
    downlinkNames[getDayMaxDemand];
    const maxSize$1v = 3;
    const fromBytes$1V = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        date: buffer.getDate()
      };
    };
    const toBytes$1V = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1v);
      buffer.setDate(parameters.date);
      return toBytes$23(id$1T, buffer.data);
    };

    const id$1S = getDayMaxDemandExport;
    downlinkNames[getDayMaxDemandExport];
    const maxSize$1u = 3;
    const fromBytes$1U = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        date: buffer.getDate()
      };
    };
    const toBytes$1U = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1u);
      buffer.setDate(parameters.date);
      return toBytes$23(id$1S, buffer.data);
    };

    const id$1R = getDayMaxDemandPrevious;
    downlinkNames[getDayMaxDemandPrevious];
    const maxSize$1t = 0;
    const fromBytes$1T = bytes => {
      if (bytes.length !== maxSize$1t) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1T = () => toBytes$23(id$1R);

    const id$1Q = getDayProfile;
    downlinkNames[getDayProfile];
    const maxSize$1s = 3;
    const fromBytes$1S = _ref => {
      let [tariffTable, index, isActive] = _ref;
      return {
        tariffTable,
        index,
        isActive: isActive === 0
      };
    };
    const toBytes$1S = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1s);
      buffer.setUint8(parameters.tariffTable);
      buffer.setUint8(parameters.index);
      buffer.setUint8(parameters.isActive ? 0 : 1);
      return toBytes$23(id$1Q, buffer.data);
    };

    const A_PLUS = 0x01;
    const A_MINUS = 0x02;

    const id$1P = getDemand;
    downlinkNames[getDemand];
    const maxSize$1r = 7;
    const fromBytes$1R = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getDemand();
    };
    const toBytes$1R = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1r);
      buffer.setDemand(parameters);
      return toBytes$23(id$1P, buffer.data);
    };

    const id$1O = getDeviceId;
    downlinkNames[getDeviceId];
    const maxSize$1q = 0;
    const fromBytes$1Q = bytes => {
      if (bytes.length !== maxSize$1q) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1Q = () => toBytes$23(id$1O);

    const id$1N = getDeviceType;
    downlinkNames[getDeviceType];
    const maxSize$1p = 0;
    const fromBytes$1P = data => {
      if (data.length !== maxSize$1p) {
        throw new Error(`Wrong buffer size: ${data.length}.`);
      }
      return {};
    };
    const toBytes$1P = () => toBytes$23(id$1N);

    const id$1M = getDisplayParam;
    downlinkNames[getDisplayParam];
    const maxSize$1o = 1;
    const fromBytes$1O = _ref => {
      let [displayMode] = _ref;
      return {
        displayMode
      };
    };
    const toBytes$1O = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1o);
      buffer.setUint8(parameters.displayMode);
      return toBytes$23(id$1M, buffer.data);
    };

    const MIN_COMMAND_SIZE$3 = 0;
    const MAX_COMMAND_SIZE$3 = 1;
    const id$1L = getEnergy;
    downlinkNames[getEnergy];
    const fromBytes$1N = bytes => {
      if (bytes.length === MAX_COMMAND_SIZE$3) {
        return {
          energyType: bytes[0]
        };
      }
      return {};
    };
    const toBytes$1N = function () {
      let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const buffer = new CommandBinaryBuffer$1(parameters?.energyType ? MAX_COMMAND_SIZE$3 : MIN_COMMAND_SIZE$3);
      if (parameters?.energyType) {
        buffer.setUint8(parameters.energyType);
      }
      return toBytes$23(id$1L, buffer.data);
    };

    const MIN_COMMAND_SIZE$2 = 0;
    const MAX_COMMAND_SIZE$2 = 1;
    const id$1K = getEnergyDayPrevious;
    downlinkNames[getEnergyDayPrevious];
    const fromBytes$1M = bytes => {
      const {
        length
      } = bytes;
      if (length !== MAX_COMMAND_SIZE$2 && length !== MIN_COMMAND_SIZE$2) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      if (length === MAX_COMMAND_SIZE$2) {
        return {
          energyType: bytes[0]
        };
      }
      return {};
    };
    const toBytes$1M = parameters => {
      if (parameters.energyType) {
        return toBytes$23(id$1K, [parameters.energyType]);
      }
      return toBytes$23(id$1K);
    };

    const MIN_COMMAND_SIZE$1 = 0;
    const MAX_COMMAND_SIZE$1 = 1;
    const id$1J = getEnergyExport;
    downlinkNames[getEnergyExport];
    const fromBytes$1L = bytes => {
      if (bytes.length === MAX_COMMAND_SIZE$1) {
        return {
          energyType: bytes[0]
        };
      }
      return {};
    };
    const toBytes$1L = function () {
      let parameters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      const buffer = new CommandBinaryBuffer$1(parameters?.energyType ? MAX_COMMAND_SIZE$1 : MIN_COMMAND_SIZE$1);
      if (parameters?.energyType) {
        buffer.setUint8(parameters.energyType);
      }
      return toBytes$23(id$1J, buffer.data);
    };

    const MIN_COMMAND_SIZE = 0;
    const MAX_COMMAND_SIZE = 1;
    const id$1I = getEnergyExportDayPrevious;
    downlinkNames[getEnergyExportDayPrevious];
    const fromBytes$1K = bytes => {
      const {
        length
      } = bytes;
      if (length !== MAX_COMMAND_SIZE && length !== MIN_COMMAND_SIZE) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      if (length === MAX_COMMAND_SIZE) {
        return {
          energyType: bytes[0]
        };
      }
      return {};
    };
    const toBytes$1K = parameters => {
      if (parameters.energyType) {
        return toBytes$23(id$1I, [parameters.energyType]);
      }
      return toBytes$23(id$1I);
    };

    const id$1H = getEvents;
    downlinkNames[getEvents];
    const maxSize$1n = 4;
    const fromBytes$1J = bytes => {
      if (bytes.length !== maxSize$1n) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new CommandBinaryBuffer$1(bytes);
      const date = buffer.getDate();
      const offset = buffer.getUint8();
      return {
        date,
        offset
      };
    };
    const toBytes$1J = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1n);
      buffer.setDate(parameters.date);
      buffer.setUint8(parameters.offset);
      return toBytes$23(id$1H, buffer.data);
    };

    const id$1G = getEventsCounters;
    downlinkNames[getEventsCounters];
    const maxSize$1m = 0;
    const fromBytes$1I = bytes => {
      if (bytes.length !== maxSize$1m) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1I = () => toBytes$23(id$1G);

    const id$1F = getEventStatus;
    downlinkNames[getEventStatus];
    const maxSize$1l = 0;
    const fromBytes$1H = bytes => {
      if (bytes.length !== maxSize$1l) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1H = () => toBytes$23(id$1F);

    const id$1E = getExtendedCurrentValues;
    downlinkNames[getExtendedCurrentValues];
    const maxSize$1k = 0;
    const fromBytes$1G = bytes => {
      if (bytes.length !== maxSize$1k) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1G = () => toBytes$23(id$1E);

    const id$1D = getExtendedCurrentValues2;
    downlinkNames[getExtendedCurrentValues2];
    const maxSize$1j = 0;
    const fromBytes$1F = bytes => {
      if (bytes.length !== maxSize$1j) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1F = () => toBytes$23(id$1D);

    const id$1C = getHalfHourDemand;
    downlinkNames[getHalfHourDemand];
    const maxSize$1i = 3;
    const fromBytes$1E = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        date: buffer.getDate()
      };
    };
    const toBytes$1E = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1i);
      buffer.setDate(parameters.date);
      return toBytes$23(id$1C, buffer.data);
    };

    const id$1B = getHalfHourDemandExport;
    downlinkNames[getHalfHourDemandExport];
    const maxSize$1h = 3;
    const fromBytes$1D = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        date: buffer.getDate()
      };
    };
    const toBytes$1D = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1h);
      buffer.setDate(parameters.date);
      return toBytes$23(id$1B, buffer.data);
    };

    const id$1A = getHalfHourDemandPrevious;
    downlinkNames[getHalfHourDemandPrevious];
    const maxSize$1g = 0;
    const fromBytes$1C = data => {
      if (data.length !== maxSize$1g) {
        throw new Error(`Wrong buffer size: ${data.length}.`);
      }
      return {};
    };
    const toBytes$1C = () => toBytes$23(id$1A);

    const TARIFF_NUMBER = 4;
    const UNDEFINED_ENERGY_VALUE = 0xffffffff;
    const energiesMask = {
      'A+': 0x01,
      'A+R+': 0x02,
      'A+R-': 0x04,
      'A-': 0x08,
      'A-R+': 0x10,
      'A-R-': 0x20
    };
    const getEnergiesFlags = energies => {
      const booleanObject = {};
      Object.keys(energies).forEach(name => {
        booleanObject[name] = !!energies[name];
      });
      return fromObject(energiesMask, booleanObject);
    };
    const getAPlusTariffBit = tariff => tariff < TARIFF_NUMBER ? 1 << tariff : 0;
    const getAMinusTariffBit = tariff => tariff < TARIFF_NUMBER ? 1 << tariff << 4 : 0;
    const getTariffEnergiesFlag = (tariff, energies) => {
      let flag = 0;
      if (tariff < TARIFF_NUMBER) {
        if (energies['A+'] || energies['A+R+'] || energies['A+R-']) {
          flag |= getAPlusTariffBit(tariff);
        }
        if (energies['A-'] || energies['A-R+'] || energies['A-R-']) {
          flag |= getAMinusTariffBit(tariff);
        }
      }
      return flag;
    };
    function CommandBinaryBuffer(dataOrLength) {
      let isLittleEndian = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      BinaryBuffer.call(this, dataOrLength, isLittleEndian);
    }
    CommandBinaryBuffer.prototype = Object.create(BinaryBuffer.prototype);
    CommandBinaryBuffer.prototype.constructor = CommandBinaryBuffer;
    CommandBinaryBuffer.prototype.getDate = function () {
      const date0 = this.getUint8();
      const date1 = this.getUint8();
      return {
        year: date0 >> 1,
        month: date0 << 3 & 0x0f | date1 >> 5,
        date: date1 & 0x1f
      };
    };
    CommandBinaryBuffer.prototype.setDate = function (_ref) {
      let {
        year,
        month,
        date
      } = _ref;
      const date0 = year << 1 | month >> 3 & 0x01;
      const date1 = month << 5 & 0xe0 | date & 0x1f;
      this.setUint8(date0);
      this.setUint8(date1);
    };
    CommandBinaryBuffer.prototype.getEnergiesFlags = function () {
      const byte = this.getUint8();
      return toObject(energiesMask, byte);
    };
    CommandBinaryBuffer.prototype.setEnergiesFlags = function (energies) {
      this.setUint8(getEnergiesFlags(energies));
    };
    CommandBinaryBuffer.prototype.getHalfhoursEnergy = function (halfhoursNumber) {
      const halfhours = [];
      for (let index = 0; index < halfhoursNumber; index++) {
        const value = this.getUint16();
        halfhours.push(value === UNDEFINED_ENERGY_VALUE ? undefined : value);
      }
      return halfhours;
    };
    CommandBinaryBuffer.prototype.setHalfhoursEnergy = function (halfhours) {
      if (halfhours) {
        for (let index = 0; index < halfhours.length; index++) {
          const value = halfhours[index];
          this.setUint16(value === undefined ? UNDEFINED_ENERGY_VALUE : value);
        }
      }
    };
    CommandBinaryBuffer.prototype.getHalfhoursEnergies = function (energiesFlags, halfhoursNumber) {
      const energies = {};
      if (energiesFlags['A+']) {
        energies['A+'] = this.getHalfhoursEnergy(halfhoursNumber);
      }
      if (energiesFlags['A+R+']) {
        energies['A+R+'] = this.getHalfhoursEnergy(halfhoursNumber);
      }
      if (energiesFlags['A+R-']) {
        energies['A+R-'] = this.getHalfhoursEnergy(halfhoursNumber);
      }
      if (energiesFlags['A-']) {
        energies['A-'] = this.getHalfhoursEnergy(halfhoursNumber);
      }
      if (energiesFlags['A-R+']) {
        energies['A-R+'] = this.getHalfhoursEnergy(halfhoursNumber);
      }
      if (energiesFlags['A-R-']) {
        energies['A-R-'] = this.getHalfhoursEnergy(halfhoursNumber);
      }
      return energies;
    };
    CommandBinaryBuffer.prototype.setHalfhoursEnergies = function (energies) {
      this.setHalfhoursEnergy(energies['A+']);
      this.setHalfhoursEnergy(energies['A+R+']);
      this.setHalfhoursEnergy(energies['A+R-']);
      this.setHalfhoursEnergy(energies['A-']);
      this.setHalfhoursEnergy(energies['A-R+']);
      this.setHalfhoursEnergy(energies['A-R-']);
    };
    CommandBinaryBuffer.prototype.getAPlusTariffEnergies = function (energyFlags) {
      const energies = {};
      if (energyFlags & energiesMask['A+']) {
        energies['A+'] = this.getUint32();
      }
      if (energyFlags & energiesMask['A+R+']) {
        energies['A+R+'] = this.getUint32();
      }
      if (energyFlags & energiesMask['A+R-']) {
        energies['A+R-'] = this.getUint32();
      }
      return energies;
    };
    CommandBinaryBuffer.prototype.setAPlusTariffEnergies = function (energies) {
      if (energies) {
        if (energies['A+']) {
          this.setUint32(energies['A+']);
        }
        if (energies['A+R+']) {
          this.setUint32(energies['A+R+']);
        }
        if (energies['A+R-']) {
          this.setUint32(energies['A+R-']);
        }
      }
    };
    CommandBinaryBuffer.prototype.getAMinusTariffEnergies = function (energyFlags) {
      const energies = {};
      if (energyFlags & energiesMask['A-']) {
        energies['A-'] = this.getUint32();
      }
      if (energyFlags & energiesMask['A-R+']) {
        energies['A-R+'] = this.getUint32();
      }
      if (energyFlags & energiesMask['A-R-']) {
        energies['A-R-'] = this.getUint32();
      }
      return energies;
    };
    CommandBinaryBuffer.prototype.setAMinusTariffEnergies = function (energies) {
      if (energies) {
        if (energies['A-']) {
          this.setUint32(energies['A-']);
        }
        if (energies['A-R+']) {
          this.setUint32(energies['A-R+']);
        }
        if (energies['A-R-']) {
          this.setUint32(energies['A-R-']);
        }
      }
    };
    CommandBinaryBuffer.prototype.getTariffsEnergies = function () {
      const energyFlags = this.getUint8();
      const tariffFlags = this.getUint8();
      const tariffs = new Array(TARIFF_NUMBER).fill(null);
      for (let index = 0; index < TARIFF_NUMBER; index++) {
        if (tariffFlags & getAPlusTariffBit(index)) {
          tariffs[index] = this.getAPlusTariffEnergies(energyFlags);
        }
      }
      for (let index = 0; index < TARIFF_NUMBER; index++) {
        if (tariffFlags & getAMinusTariffBit(index)) {
          tariffs[index] = {
            ...tariffs[index],
            ...this.getAMinusTariffEnergies(energyFlags)
          };
        }
      }
      return tariffs;
    };
    CommandBinaryBuffer.prototype.setTariffsEnergies = function (tariffs) {
      let energiesFlags = 0;
      let tariffsFlags = 0;
      tariffs.forEach((tariff, index) => {
        if (tariff) {
          energiesFlags |= getEnergiesFlags(tariff);
          tariffsFlags |= getTariffEnergiesFlag(index, tariff);
        }
      });
      this.setUint8(energiesFlags);
      this.setUint8(tariffsFlags);
      tariffs.forEach(tariff => this.setAPlusTariffEnergies(tariff));
      tariffs.forEach(tariff => this.setAMinusTariffEnergies(tariff));
    };
    CommandBinaryBuffer.prototype.getPowerMax = function () {
      return {
        hours: this.getUint8(),
        minutes: this.getUint8(),
        power: this.getUint32()
      };
    };
    CommandBinaryBuffer.prototype.setPowerMax = function (value) {
      if (value) {
        const {
          hours,
          minutes,
          power
        } = value;
        this.setUint8(hours);
        this.setUint8(minutes);
        this.setUint32(power);
      }
    };
    CommandBinaryBuffer.prototype.getAPlusTariffPowerMax = function (energyFlags) {
      const energies = {};
      if (energyFlags & energiesMask['A+']) {
        energies['A+'] = this.getPowerMax();
      }
      if (energyFlags & energiesMask['A+R+']) {
        energies['A+R+'] = this.getPowerMax();
      }
      if (energyFlags & energiesMask['A+R-']) {
        energies['A+R-'] = this.getPowerMax();
      }
      return energies;
    };
    CommandBinaryBuffer.prototype.setAPlusTariffPowerMax = function (energies) {
      if (energies) {
        this.setPowerMax(energies['A+']);
        this.setPowerMax(energies['A+R+']);
        this.setPowerMax(energies['A+R+']);
      }
    };
    CommandBinaryBuffer.prototype.getAMinusTariffPowerMax = function (energyFlags) {
      const energies = {};
      if (energyFlags & energiesMask['A-']) {
        energies['A-'] = this.getPowerMax();
      }
      if (energyFlags & energiesMask['A-R+']) {
        energies['A-R+'] = this.getPowerMax();
      }
      if (energyFlags & energiesMask['A-R-']) {
        energies['A-R-'] = this.getPowerMax();
      }
      return energies;
    };
    CommandBinaryBuffer.prototype.setAMinusTariffPowerMax = function (energies) {
      if (energies) {
        this.setPowerMax(energies['A-']);
        this.setPowerMax(energies['A-R+']);
        this.setPowerMax(energies['A-R-']);
      }
    };
    CommandBinaryBuffer.prototype.getTariffsPowerMax = function () {
      const energyFlags = this.getUint8();
      const tariffFlags = this.getUint8();
      const tariffs = new Array(TARIFF_NUMBER).fill(null);
      for (let index = 0; index < TARIFF_NUMBER; index++) {
        if (tariffFlags & getAPlusTariffBit(index)) {
          tariffs[index] = this.getAPlusTariffPowerMax(energyFlags);
        }
      }
      for (let index = 0; index < TARIFF_NUMBER; index++) {
        if (tariffFlags & getAMinusTariffBit(index)) {
          tariffs[index] = {
            ...tariffs[index],
            ...this.getAMinusTariffPowerMax(energyFlags)
          };
        }
      }
      return tariffs;
    };
    CommandBinaryBuffer.prototype.setTariffsPowerMax = function (tariffs) {
      let energiesFlags = 0;
      let tariffsFlags = 0;
      tariffs.forEach((tariff, index) => {
        if (tariff) {
          energiesFlags |= getEnergiesFlags(tariff);
          tariffsFlags |= getTariffEnergiesFlag(index, tariff);
        }
      });
      this.setUint8(energiesFlags);
      this.setUint8(tariffsFlags);
      tariffs.forEach(tariff => this.setAPlusTariffPowerMax(tariff));
      tariffs.forEach(tariff => this.setAMinusTariffPowerMax(tariff));
    };

    const id$1z = getHalfhoursEnergies;
    downlinkNames[getHalfhoursEnergies];
    const maxSize$1f = 5;
    const fromBytes$1B = bytes => {
      const buffer = new CommandBinaryBuffer(bytes);
      return {
        date: buffer.getDate(),
        energies: buffer.getEnergiesFlags(),
        firstHalfhour: buffer.getUint8(),
        halfhoursNumber: buffer.getUint8()
      };
    };
    const toBytes$1B = parameters => {
      const buffer = new CommandBinaryBuffer(maxSize$1f);
      buffer.setDate(parameters.date);
      buffer.setEnergiesFlags(parameters.energies);
      buffer.setUint8(parameters.firstHalfhour);
      buffer.setUint8(parameters.halfhoursNumber);
      return toBytes$23(id$1z, buffer.data);
    };

    const id$1y = getMagneticFieldThreshold;
    downlinkNames[getMagneticFieldThreshold];
    const maxSize$1e = 0;
    const fromBytes$1A = bytes => {
      if (bytes.length !== maxSize$1e) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1A = () => toBytes$23(id$1y);

    const id$1x = getMeterInfo;
    downlinkNames[getMeterInfo];
    const maxSize$1d = 0;
    const fromBytes$1z = bytes => {
      if (bytes.length !== maxSize$1d) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1z = () => toBytes$23(id$1x);

    const id$1w = getMonthDemand;
    downlinkNames[getMonthDemand];
    const maxSize$1c = 2;
    const fromBytes$1y = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        year: buffer.getUint8(),
        month: buffer.getUint8()
      };
    };
    const toBytes$1y = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1c);
      buffer.setUint8(parameters.year);
      buffer.setUint8(parameters.month);
      return toBytes$23(id$1w, buffer.data);
    };

    const id$1v = getMonthDemandExport;
    downlinkNames[getMonthDemandExport];
    const maxSize$1b = 2;
    const fromBytes$1x = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        year: buffer.getUint8(),
        month: buffer.getUint8()
      };
    };
    const toBytes$1x = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1b);
      buffer.setUint8(parameters.year);
      buffer.setUint8(parameters.month);
      return toBytes$23(id$1v, buffer.data);
    };

    const id$1u = getMonthMaxDemand;
    downlinkNames[getMonthMaxDemand];
    const fromBytes$1w = bytes => {
      const [year, month] = bytes;
      return {
        year,
        month
      };
    };
    const toBytes$1w = _ref => {
      let {
        year,
        month
      } = _ref;
      return toBytes$23(id$1u, [year, month]);
    };

    const id$1t = getMonthMaxDemandExport;
    downlinkNames[getMonthMaxDemandExport];
    const fromBytes$1v = bytes => {
      const [year, month] = bytes;
      return {
        year,
        month
      };
    };
    const toBytes$1v = _ref => {
      let {
        year,
        month
      } = _ref;
      return toBytes$23(id$1t, [year, month]);
    };

    const id$1s = getOperatorParametersExtended3;
    downlinkNames[getOperatorParametersExtended3];
    const maxSize$1a = 0;
    const fromBytes$1u = bytes => {
      if (bytes.length !== maxSize$1a) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1u = () => toBytes$23(id$1s);

    const id$1r = getOperatorParameters;
    downlinkNames[getOperatorParameters];
    const maxSize$19 = 0;
    const fromBytes$1t = bytes => {
      if (bytes.length !== maxSize$19) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1t = () => toBytes$23(id$1r);

    const id$1q = getRatePlanInfo;
    downlinkNames[getRatePlanInfo];
    const fromBytes$1s = bytes => ({
      tariffTable: bytes[0]
    });
    const toBytes$1s = parameters => toBytes$23(id$1q, [parameters.tariffTable]);

    const id$1p = getSaldo;
    downlinkNames[getSaldo];
    const maxSize$18 = 0;
    const fromBytes$1r = bytes => {
      if (bytes.length !== maxSize$18) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1r = () => toBytes$23(id$1p);

    const id$1o = getSaldoParameters;
    downlinkNames[getSaldoParameters];
    const maxSize$17 = 0;
    const fromBytes$1q = bytes => {
      if (bytes.length !== maxSize$17) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1q = () => toBytes$23(id$1o);

    const id$1n = getSeasonProfile;
    downlinkNames[getSeasonProfile];
    const maxSize$16 = 3;
    const fromBytes$1p = _ref => {
      let [tariffTable, index, isActive] = _ref;
      return {
        tariffTable,
        index,
        isActive: isActive === 0
      };
    };
    const toBytes$1p = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$16);
      buffer.setUint8(parameters.tariffTable);
      buffer.setUint8(parameters.index);
      buffer.setUint8(parameters.isActive ? 0 : 1);
      return toBytes$23(id$1n, buffer.data);
    };

    const id$1m = getSpecialDay;
    downlinkNames[getSpecialDay];
    const maxSize$15 = 3;
    const fromBytes$1o = _ref => {
      let [tariffTable, index, isActive] = _ref;
      return {
        tariffTable,
        index,
        isActive: isActive === 0
      };
    };
    const toBytes$1o = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$15);
      buffer.setUint8(parameters.tariffTable);
      buffer.setUint8(parameters.index);
      buffer.setUint8(parameters.isActive ? 0 : 1);
      return toBytes$23(id$1m, buffer.data);
    };

    const id$1l = getVersion;
    downlinkNames[getVersion];
    const maxSize$14 = 0;
    const fromBytes$1n = bytes => {
      if (bytes.length !== maxSize$14) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1n = () => toBytes$23(id$1l);

    const id$1k = prepareRatePlan;
    downlinkNames[prepareRatePlan];
    const maxSize$13 = 5;
    const fromBytes$1m = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        tariffTable: buffer.getUint8(),
        id: buffer.getUint32()
      };
    };
    const toBytes$1m = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$13);
      buffer.setUint8(parameters.tariffTable);
      buffer.setUint32(parameters.id);
      return toBytes$23(id$1k, buffer.data);
    };

    const id$1j = resetPowerMaxDay;
    downlinkNames[resetPowerMaxDay];
    const maxSize$12 = 0;
    const fromBytes$1l = bytes => {
      if (bytes.length !== maxSize$12) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1l = () => toBytes$23(id$1j);

    const id$1i = resetPowerMaxMonth;
    downlinkNames[resetPowerMaxMonth];
    const maxSize$11 = 0;
    const fromBytes$1k = bytes => {
      if (bytes.length !== maxSize$11) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1k = () => toBytes$23(id$1i);

    const id$1h = runTariffPlan;
    downlinkNames[runTariffPlan];
    const fromBytes$1j = bytes => ({
      tariffTable: bytes[0]
    });
    const toBytes$1j = parameters => toBytes$23(id$1h, [parameters.tariffTable]);

    const KEY_SIZE = 16;
    const id$1g = setAccessKey;
    downlinkNames[setAccessKey];
    const maxSize$10 = 1 + KEY_SIZE;
    const fromBytes$1i = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        accessLevel: buffer.getUint8(),
        key: buffer.getBytes(KEY_SIZE)
      };
    };
    const toBytes$1i = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$10);
      buffer.setUint8(parameters.accessLevel);
      buffer.setBytes(parameters.key);
      return toBytes$23(id$1g, buffer.data);
    };

    const id$1f = setCorrectDateTime;
    downlinkNames[setCorrectDateTime];
    const maxSize$ = 2;
    const fromBytes$1h = bytes => {
      if (bytes.length !== maxSize$) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        seconds: buffer.getInt16()
      };
    };
    const toBytes$1h = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$);
      buffer.setInt16(parameters.seconds);
      return toBytes$23(id$1f, buffer.data);
    };

    const id$1e = setCorrectTime;
    downlinkNames[setCorrectTime];
    const maxSize$_ = 9;
    const fromBytes$1g = bytes => {
      if (bytes.length !== maxSize$_) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getTimeCorrectionParameters();
    };
    const toBytes$1g = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$_);
      buffer.setTimeCorrectionParameters(parameters);
      return toBytes$23(id$1e, buffer.data);
    };

    const id$1d = setDateTime;
    downlinkNames[setDateTime];
    const maxSize$Z = 8;
    const fromBytes$1f = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getDateTime();
    };
    const toBytes$1f = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$Z);
      buffer.setDateTime(parameters);
      return toBytes$23(id$1d, buffer.data);
    };

    const MAX_PERIODS_NUMBER$1 = 8;
    const PERIODS_FINAL_BYTE$1 = 0xff;
    const id$1c = setDayProfile;
    downlinkNames[setDayProfile];
    const fromBytes$1e = bytes => {
      const finalByteIndex = bytes.indexOf(PERIODS_FINAL_BYTE$1);
      const cleanBytes = finalByteIndex === -1 ? bytes : bytes.slice(0, finalByteIndex);
      const buffer = new CommandBinaryBuffer$1(cleanBytes);
      return {
        tariffTable: buffer.getUint8(),
        index: buffer.getUint8(),
        periods: [...cleanBytes.slice(buffer.offset)].map(CommandBinaryBuffer$1.getDayProfileFromByte)
      };
    };
    const toBytes$1e = parameters => {
      const hasPeriodsFinalByte = parameters.periods.length < MAX_PERIODS_NUMBER$1;
      const size = 2 + parameters.periods.length + +hasPeriodsFinalByte;
      const buffer = new CommandBinaryBuffer$1(size);
      buffer.setUint8(parameters.tariffTable);
      buffer.setUint8(parameters.index);
      parameters.periods.forEach(period => {
        buffer.setDayProfile(period);
      });
      if (hasPeriodsFinalByte) {
        buffer.setUint8(PERIODS_FINAL_BYTE$1);
      }
      return toBytes$23(id$1c, buffer.data);
    };

    const id$1b = setDisplayParam;
    downlinkNames[setDisplayParam];
    const maxSize$Y = 33;
    const fromBytes$1d = bytes => {
      if (bytes.length < 1 || bytes.length > maxSize$Y) {
        throw new Error('Invalid SetDisplayParam data size.');
      }
      const [displayMode, ...order] = bytes;
      return {
        displayMode,
        order
      };
    };
    const toBytes$1d = parameters => toBytes$23(id$1b, [parameters.displayMode, ...parameters.order]);

    const id$1a = setOperatorParametersExtended3;
    downlinkNames[setOperatorParametersExtended3];
    const maxSize$X = 17;
    const fromBytes$1c = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getOperatorParametersExtended3();
    };
    const toBytes$1c = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$X);
      buffer.setOperatorParametersExtended3(parameters);
      return toBytes$23(id$1a, buffer.data);
    };

    const id$19 = setOperatorParameters;
    downlinkNames[setOperatorParameters];
    const maxSize$W = OPERATOR_PARAMETERS_SIZE;
    const fromBytes$1b = bytes => {
      if (bytes.length !== maxSize$W) {
        throw new Error('Invalid SetOpParams data size.');
      }
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getOperatorParameters();
    };
    const toBytes$1b = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$W);
      buffer.setOperatorParameters(parameters);
      return toBytes$23(id$19, buffer.data);
    };

    const id$18 = setSaldo;
    downlinkNames[setSaldo];
    const maxSize$V = 12;
    const fromBytes$1a = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        date: {
          month: buffer.getUint8(),
          date: buffer.getUint8(),
          hours: buffer.getUint8(),
          minutes: buffer.getUint8()
        },
        saldoNew: buffer.getInt32(),
        saldoOld: buffer.getInt32()
      };
    };
    const toBytes$1a = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$V);
      buffer.setUint8(parameters.date.month);
      buffer.setUint8(parameters.date.date);
      buffer.setUint8(parameters.date.hours);
      buffer.setUint8(parameters.date.minutes);
      buffer.setInt32(parameters.saldoNew);
      buffer.setInt32(parameters.saldoOld);
      return toBytes$23(id$18, buffer.data);
    };

    const id$17 = setSaldoParameters;
    downlinkNames[setSaldoParameters];
    const maxSize$U = 37;
    const fromBytes$19 = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getSaldoParameters();
    };
    const toBytes$19 = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$U);
      buffer.setSaldoParameters(parameters);
      return toBytes$23(id$17, buffer.data);
    };

    const id$16 = setSeasonProfile;
    downlinkNames[setSeasonProfile];
    const maxSize$T = SEASON_PROFILE_SIZE;
    const fromBytes$18 = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        tariffTable: buffer.getUint8(),
        index: buffer.getUint8(),
        ...buffer.getSeasonProfile()
      };
    };
    const toBytes$18 = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$T);
      buffer.setUint8(parameters.tariffTable);
      buffer.setUint8(parameters.index);
      buffer.setSeasonProfile(parameters);
      return toBytes$23(id$16, buffer.data);
    };

    const id$15 = setSpecialDay;
    downlinkNames[setSpecialDay];
    const maxSize$S = 6;
    const fromBytes$17 = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        tariffTable: buffer.getUint8(),
        index: buffer.getUint8(),
        ...buffer.getSpecialDay()
      };
    };
    const toBytes$17 = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$S);
      buffer.setUint8(parameters.tariffTable);
      buffer.setUint8(parameters.index);
      buffer.setSpecialDay(parameters);
      return toBytes$23(id$15, buffer.data);
    };

    const id$14 = setSpecialOperation;
    downlinkNames[setSpecialOperation];
    const maxSize$R = 2;
    const fromBytes$16 = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      const type = buffer.getUint8();
      const flags = buffer.getUint8();
      const readScreensInfo = !!(flags & 0x80);
      const resetElectroMagneticIndication = !!(flags & 1);
      const resetMagneticIndication = !!(flags & 2);
      return {
        type,
        readScreensInfo,
        resetElectroMagneticIndication,
        resetMagneticIndication
      };
    };
    const toBytes$16 = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$R);
      let flags = 0;
      if (parameters.readScreensInfo) {
        flags |= 0x80;
      }
      if (parameters.resetElectroMagneticIndication) {
        flags |= 1;
      }
      if (parameters.resetMagneticIndication) {
        flags |= 2;
      }
      buffer.setUint8(parameters.type);
      buffer.setUint8(flags);
      return toBytes$23(id$14, buffer.data);
    };

    const id$13 = turnRelayOff;
    downlinkNames[turnRelayOff];
    const maxSize$Q = 0;
    const fromBytes$15 = bytes => {
      if (bytes.length !== maxSize$Q) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$15 = () => toBytes$23(id$13);

    const id$12 = turnRelayOn;
    downlinkNames[turnRelayOn];
    const maxSize$P = 0;
    const fromBytes$14 = bytes => {
      if (bytes.length !== maxSize$P) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$14 = () => toBytes$23(id$12);

    // this is required to shadow crypto-js implementation
    const aes = {
      encrypt: () => {},
      decrypt: () => {}
    };

    var calculateLrc = (function (data) {
      let initialLrc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0x55;
      let lrc = initialLrc;
      data.forEach(item => {
        lrc ^= item;
      });
      return lrc;
    });

    const ACCESS_LEVEL_MASK = 0x03;
    const MESSAGE_HEADER_SIZE = 2;
    const BLOCK_SIZE = 16;
    const COMMANDS_END_MARK = [0];
    const COMMAND_HEADER_SIZE = 2;
    const getFromBytes$2 = (fromBytesMap, nameMap) => function () {
      let bytes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      const aesKey = config?.aesKey;
      const commands = [];
      const [messageId, maskedAccessLevel] = bytes;
      const accessLevel = maskedAccessLevel & ACCESS_LEVEL_MASK;
      const message = {
        messageId,
        accessLevel,
        commands,
        bytes,
        lrc: {
          received: undefined,
          calculated: 0
        }
      };
      let messageBody = bytes.slice(MESSAGE_HEADER_SIZE);
      let error;
      if (aesKey && accessLevel !== UNENCRYPTED) {
        messageBody = [...aes.decrypt(aesKey, messageBody)];
      }
      const receivedLrc = messageBody[messageBody.length - 1];
      messageBody = messageBody.slice(0, -1);
      const calculatedLrc = calculateLrc(messageBody);
      if (accessLevel !== UNENCRYPTED || receivedLrc !== 0) {
        if (receivedLrc !== calculatedLrc) {
          error = 'Mismatch LRC.';
        }
      }
      const accessLevel2 = messageBody[0] & ACCESS_LEVEL_MASK;
      const commandsData = messageBody.slice(1);
      if (accessLevel !== accessLevel2) {
        error = 'Mismatch access levels.';
      }
      let position = 0;
      do {
        const commandId = commandsData[position];
        const commandBodySize = commandsData[position + 1];
        const commandSize = COMMAND_HEADER_SIZE + commandBodySize;
        const commandBody = commandsData.slice(position + COMMAND_HEADER_SIZE, position + commandSize);
        const command = {
          id: commandId,
          name: nameMap[commandId],
          headerSize: COMMAND_HEADER_SIZE,
          bytes: commandsData.slice(position, position + commandSize)
        };
        if (!commandId) {
          break;
        }
        try {
          if (!fromBytesMap[commandId]) {
            throw new Error(`Unsupported command id: ${commandId}!`);
          }
          command.parameters = fromBytesMap[commandId](commandBody, config);
          commands.push(command);
        } catch (exception) {
          commands.push({
            command,
            error: exception.message
          });
        }
        position += commandSize;
      } while (position <= commandsData.length);
      message.lrc.calculated = calculatedLrc;
      message.lrc.received = receivedLrc;
      if (error) {
        return {
          message,
          error
        };
      }
      return message;
    };
    const getToBytes$1 = toBytesMap => (commands, _ref) => {
      let {
        messageId = 1,
        accessLevel = READ_ONLY,
        aesKey
      } = _ref;
      const commandBytes = commands.map(command => {
        if ('id' in command) {
          return toBytesMap[command.id](command.parameters || {});
        }
        if ('command' in command) {
          return command.command.bytes;
        }
        throw new Error('wrong command format');
      });
      const maskedAccessLevel = accessLevel | 0x10;
      const header = [messageId, maskedAccessLevel];
      let body = [].concat(maskedAccessLevel, ...commandBytes, COMMANDS_END_MARK);
      if (accessLevel !== UNENCRYPTED) {
        const padding = (body.length + 1) % BLOCK_SIZE;
        if (padding) {
          body = body.concat(new Array(BLOCK_SIZE - padding).fill(0));
        }
      }
      body = body.concat(calculateLrc(body));
      if (aesKey && accessLevel !== UNENCRYPTED) {
        body = [...aes.encrypt(aesKey, body)];
      }
      return header.concat(body);
    };

    const toBytesMap$1 = {};
    const fromBytesMap$1 = {};
    const nameMap$1 = downlinkNames;
    const fromBytes$13 = getFromBytes$2(fromBytesMap$1, nameMap$1);
    const toBytes$13 = getToBytes$1(toBytesMap$1);
    toBytesMap$1[id$20] = toBytes$22;
    toBytesMap$1[id$1$] = toBytes$21;
    toBytesMap$1[id$1_] = toBytes$20;
    toBytesMap$1[id$1Z] = toBytes$1$;
    toBytesMap$1[id$1Y] = toBytes$1_;
    toBytesMap$1[id$1X] = toBytes$1Z;
    toBytesMap$1[id$1W] = toBytes$1Y;
    toBytesMap$1[id$1V] = toBytes$1X;
    toBytesMap$1[id$1U] = toBytes$1W;
    toBytesMap$1[id$1T] = toBytes$1V;
    toBytesMap$1[id$1S] = toBytes$1U;
    toBytesMap$1[id$1R] = toBytes$1T;
    toBytesMap$1[id$1Q] = toBytes$1S;
    toBytesMap$1[id$1P] = toBytes$1R;
    toBytesMap$1[id$1O] = toBytes$1Q;
    toBytesMap$1[id$1N] = toBytes$1P;
    toBytesMap$1[id$1M] = toBytes$1O;
    toBytesMap$1[id$1L] = toBytes$1N;
    toBytesMap$1[id$1K] = toBytes$1M;
    toBytesMap$1[id$1J] = toBytes$1L;
    toBytesMap$1[id$1I] = toBytes$1K;
    toBytesMap$1[id$1H] = toBytes$1J;
    toBytesMap$1[id$1G] = toBytes$1I;
    toBytesMap$1[id$1F] = toBytes$1H;
    toBytesMap$1[id$1E] = toBytes$1G;
    toBytesMap$1[id$1D] = toBytes$1F;
    toBytesMap$1[id$1C] = toBytes$1E;
    toBytesMap$1[id$1B] = toBytes$1D;
    toBytesMap$1[id$1A] = toBytes$1C;
    toBytesMap$1[id$1z] = toBytes$1B;
    toBytesMap$1[id$1y] = toBytes$1A;
    toBytesMap$1[id$1x] = toBytes$1z;
    toBytesMap$1[id$1w] = toBytes$1y;
    toBytesMap$1[id$1v] = toBytes$1x;
    toBytesMap$1[id$1u] = toBytes$1w;
    toBytesMap$1[id$1t] = toBytes$1v;
    toBytesMap$1[id$1s] = toBytes$1u;
    toBytesMap$1[id$1r] = toBytes$1t;
    toBytesMap$1[id$1q] = toBytes$1s;
    toBytesMap$1[id$1p] = toBytes$1r;
    toBytesMap$1[id$1o] = toBytes$1q;
    toBytesMap$1[id$1n] = toBytes$1p;
    toBytesMap$1[id$1m] = toBytes$1o;
    toBytesMap$1[id$1l] = toBytes$1n;
    toBytesMap$1[id$1k] = toBytes$1m;
    toBytesMap$1[id$1j] = toBytes$1l;
    toBytesMap$1[id$1i] = toBytes$1k;
    toBytesMap$1[id$1h] = toBytes$1j;
    toBytesMap$1[id$1g] = toBytes$1i;
    toBytesMap$1[id$1f] = toBytes$1h;
    toBytesMap$1[id$1e] = toBytes$1g;
    toBytesMap$1[id$1d] = toBytes$1f;
    toBytesMap$1[id$1c] = toBytes$1e;
    toBytesMap$1[id$1b] = toBytes$1d;
    toBytesMap$1[id$1a] = toBytes$1c;
    toBytesMap$1[id$19] = toBytes$1b;
    toBytesMap$1[id$18] = toBytes$1a;
    toBytesMap$1[id$17] = toBytes$19;
    toBytesMap$1[id$16] = toBytes$18;
    toBytesMap$1[id$15] = toBytes$17;
    toBytesMap$1[id$14] = toBytes$16;
    toBytesMap$1[id$13] = toBytes$15;
    toBytesMap$1[id$12] = toBytes$14;
    fromBytesMap$1[id$20] = fromBytes$22;
    fromBytesMap$1[id$1$] = fromBytes$21;
    fromBytesMap$1[id$1_] = fromBytes$20;
    fromBytesMap$1[id$1Z] = fromBytes$1$;
    fromBytesMap$1[id$1Y] = fromBytes$1_;
    fromBytesMap$1[id$1X] = fromBytes$1Z;
    fromBytesMap$1[id$1W] = fromBytes$1Y;
    fromBytesMap$1[id$1V] = fromBytes$1X;
    fromBytesMap$1[id$1U] = fromBytes$1W;
    fromBytesMap$1[id$1T] = fromBytes$1V;
    fromBytesMap$1[id$1S] = fromBytes$1U;
    fromBytesMap$1[id$1R] = fromBytes$1T;
    fromBytesMap$1[id$1Q] = fromBytes$1S;
    fromBytesMap$1[id$1P] = fromBytes$1R;
    fromBytesMap$1[id$1O] = fromBytes$1Q;
    fromBytesMap$1[id$1N] = fromBytes$1P;
    fromBytesMap$1[id$1M] = fromBytes$1O;
    fromBytesMap$1[id$1L] = fromBytes$1N;
    fromBytesMap$1[id$1K] = fromBytes$1M;
    fromBytesMap$1[id$1J] = fromBytes$1L;
    fromBytesMap$1[id$1I] = fromBytes$1K;
    fromBytesMap$1[id$1H] = fromBytes$1J;
    fromBytesMap$1[id$1G] = fromBytes$1I;
    fromBytesMap$1[id$1F] = fromBytes$1H;
    fromBytesMap$1[id$1E] = fromBytes$1G;
    fromBytesMap$1[id$1D] = fromBytes$1F;
    fromBytesMap$1[id$1C] = fromBytes$1E;
    fromBytesMap$1[id$1B] = fromBytes$1D;
    fromBytesMap$1[id$1A] = fromBytes$1C;
    fromBytesMap$1[id$1z] = fromBytes$1B;
    fromBytesMap$1[id$1y] = fromBytes$1A;
    fromBytesMap$1[id$1x] = fromBytes$1z;
    fromBytesMap$1[id$1w] = fromBytes$1y;
    fromBytesMap$1[id$1v] = fromBytes$1x;
    fromBytesMap$1[id$1u] = fromBytes$1w;
    fromBytesMap$1[id$1t] = fromBytes$1v;
    fromBytesMap$1[id$1s] = fromBytes$1u;
    fromBytesMap$1[id$1r] = fromBytes$1t;
    fromBytesMap$1[id$1q] = fromBytes$1s;
    fromBytesMap$1[id$1p] = fromBytes$1r;
    fromBytesMap$1[id$1o] = fromBytes$1q;
    fromBytesMap$1[id$1n] = fromBytes$1p;
    fromBytesMap$1[id$1m] = fromBytes$1o;
    fromBytesMap$1[id$1l] = fromBytes$1n;
    fromBytesMap$1[id$1k] = fromBytes$1m;
    fromBytesMap$1[id$1j] = fromBytes$1l;
    fromBytesMap$1[id$1i] = fromBytes$1k;
    fromBytesMap$1[id$1h] = fromBytes$1j;
    fromBytesMap$1[id$1g] = fromBytes$1i;
    fromBytesMap$1[id$1f] = fromBytes$1h;
    fromBytesMap$1[id$1e] = fromBytes$1g;
    fromBytesMap$1[id$1d] = fromBytes$1f;
    fromBytesMap$1[id$1c] = fromBytes$1e;
    fromBytesMap$1[id$1b] = fromBytes$1d;
    fromBytesMap$1[id$1a] = fromBytes$1c;
    fromBytesMap$1[id$19] = fromBytes$1b;
    fromBytesMap$1[id$18] = fromBytes$1a;
    fromBytesMap$1[id$17] = fromBytes$19;
    fromBytesMap$1[id$16] = fromBytes$18;
    fromBytesMap$1[id$15] = fromBytes$17;
    fromBytesMap$1[id$14] = fromBytes$16;
    fromBytesMap$1[id$13] = fromBytes$15;
    fromBytesMap$1[id$12] = fromBytes$14;

    var downlink = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromBytes: fromBytes$13,
        fromBytesMap: fromBytesMap$1,
        nameMap: nameMap$1,
        toBytes: toBytes$13,
        toBytesMap: toBytesMap$1
    });

    const getDayEnergies = 0x78;
    const getDayMaxPower = 0x79;
    const errorResponse = 0xfe;

    var uplinkIds = /*#__PURE__*/Object.freeze({
        __proto__: null,
        activateRatePlan: activateRatePlan,
        errorResponse: errorResponse,
        getBuildVersion: getBuildVersion,
        getCorrectTime: getCorrectTime,
        getCriticalEvent: getCriticalEvent,
        getCurrentStatusMeter: getCurrentStatusMeter,
        getCurrentValues: getCurrentValues,
        getDateTime: getDateTime,
        getDayDemand: getDayDemand,
        getDayDemandExport: getDayDemandExport,
        getDayEnergies: getDayEnergies,
        getDayMaxDemand: getDayMaxDemand,
        getDayMaxDemandExport: getDayMaxDemandExport,
        getDayMaxDemandPrevious: getDayMaxDemandPrevious,
        getDayMaxPower: getDayMaxPower,
        getDayProfile: getDayProfile,
        getDemand: getDemand,
        getDeviceId: getDeviceId,
        getDeviceType: getDeviceType,
        getDisplayParam: getDisplayParam,
        getEnergy: getEnergy,
        getEnergyDayPrevious: getEnergyDayPrevious,
        getEnergyExport: getEnergyExport,
        getEnergyExportDayPrevious: getEnergyExportDayPrevious,
        getEventStatus: getEventStatus,
        getEvents: getEvents,
        getEventsCounters: getEventsCounters,
        getExtendedCurrentValues: getExtendedCurrentValues,
        getExtendedCurrentValues2: getExtendedCurrentValues2,
        getHalfHourDemand: getHalfHourDemand,
        getHalfHourDemandExport: getHalfHourDemandExport,
        getHalfHourDemandPrevious: getHalfHourDemandPrevious,
        getHalfhoursEnergies: getHalfhoursEnergies,
        getMagneticFieldThreshold: getMagneticFieldThreshold,
        getMeterInfo: getMeterInfo,
        getMonthDemand: getMonthDemand,
        getMonthDemandExport: getMonthDemandExport,
        getMonthMaxDemand: getMonthMaxDemand,
        getMonthMaxDemandExport: getMonthMaxDemandExport,
        getOperatorParameters: getOperatorParameters,
        getOperatorParametersExtended3: getOperatorParametersExtended3,
        getRatePlanInfo: getRatePlanInfo,
        getSaldo: getSaldo,
        getSaldoParameters: getSaldoParameters,
        getSeasonProfile: getSeasonProfile,
        getSpecialDay: getSpecialDay,
        getVersion: getVersion,
        prepareRatePlan: prepareRatePlan,
        resetPowerMaxDay: resetPowerMaxDay,
        resetPowerMaxMonth: resetPowerMaxMonth,
        runTariffPlan: runTariffPlan,
        setAccessKey: setAccessKey,
        setCorrectDateTime: setCorrectDateTime,
        setCorrectTime: setCorrectTime,
        setDateTime: setDateTime,
        setDayProfile: setDayProfile,
        setDisplayParam: setDisplayParam,
        setOperatorParameters: setOperatorParameters,
        setOperatorParametersExtended3: setOperatorParametersExtended3,
        setSaldo: setSaldo,
        setSaldoParameters: setSaldoParameters,
        setSeasonProfile: setSeasonProfile,
        setSpecialDay: setSpecialDay,
        setSpecialOperation: setSpecialOperation,
        turnRelayOff: turnRelayOff,
        turnRelayOn: turnRelayOn
    });

    var uplinkNames = invertObject(uplinkIds);

    const id$11 = activateRatePlan;
    uplinkNames[activateRatePlan];
    const maxSize$O = 0;
    const fromBytes$12 = bytes => {
      if (bytes.length !== maxSize$O) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$12 = () => toBytes$23(id$11);

    const OK = 0;
    const UNKNOWN_COMMAND = 0x80;
    const NOT_ALIGNED_DATA = 0x81;
    const DECRYPTION_FAILURE = 0x82;
    const UNKNOWN_PROTOCOL = 0x83;
    const BAD_MESSAGE = 0x84;
    const BAD_DATA_LENGTH = 0x85;
    const BAD_ARRAY_INDEX = 0x86;
    const NOT_PREPARED_RATE_PLAN = 0x87;
    const BAD_RATE_PLAN_ID = 0x88;
    const BAD_RATE_PLAN_SIZE = 0x89;
    const BAD_RESPONSE_LENGTH = 0x90;
    const NO_DATA_FOR_DATE = 0x91;
    const CALIBRATION_DISABLED = 0x92;
    const ACCESS_DENIED = 0x93;
    const BAD_SALDO_WRITE = 0x95;
    const BLOCKED_METER = 0x97;
    const UNENCRYPTED_COMMAND_DISABLED = 0x98;
    const TIME_CORRECTION_FAILURE = 0x99;
    const INVALID_CORRECTION_INTERVAL = 0x9a;
    const TIME_CORRECTION_OUT_HALF_HOUR_DISABLED = 0x9b;
    const BAD_BLOCK_NUMBER = 0x9c;
    const OUT_OFF_RANGE = 0x9f;
    const SET_METER_TYPE_FAILURE = 0xa0;
    const INTERNAL = 0xf0;

    var resultCodes = /*#__PURE__*/Object.freeze({
        __proto__: null,
        ACCESS_DENIED: ACCESS_DENIED,
        BAD_ARRAY_INDEX: BAD_ARRAY_INDEX,
        BAD_BLOCK_NUMBER: BAD_BLOCK_NUMBER,
        BAD_DATA_LENGTH: BAD_DATA_LENGTH,
        BAD_MESSAGE: BAD_MESSAGE,
        BAD_RATE_PLAN_ID: BAD_RATE_PLAN_ID,
        BAD_RATE_PLAN_SIZE: BAD_RATE_PLAN_SIZE,
        BAD_RESPONSE_LENGTH: BAD_RESPONSE_LENGTH,
        BAD_SALDO_WRITE: BAD_SALDO_WRITE,
        BLOCKED_METER: BLOCKED_METER,
        CALIBRATION_DISABLED: CALIBRATION_DISABLED,
        DECRYPTION_FAILURE: DECRYPTION_FAILURE,
        INTERNAL: INTERNAL,
        INVALID_CORRECTION_INTERVAL: INVALID_CORRECTION_INTERVAL,
        NOT_ALIGNED_DATA: NOT_ALIGNED_DATA,
        NOT_PREPARED_RATE_PLAN: NOT_PREPARED_RATE_PLAN,
        NO_DATA_FOR_DATE: NO_DATA_FOR_DATE,
        OK: OK,
        OUT_OFF_RANGE: OUT_OFF_RANGE,
        SET_METER_TYPE_FAILURE: SET_METER_TYPE_FAILURE,
        TIME_CORRECTION_FAILURE: TIME_CORRECTION_FAILURE,
        TIME_CORRECTION_OUT_HALF_HOUR_DISABLED: TIME_CORRECTION_OUT_HALF_HOUR_DISABLED,
        UNENCRYPTED_COMMAND_DISABLED: UNENCRYPTED_COMMAND_DISABLED,
        UNKNOWN_COMMAND: UNKNOWN_COMMAND,
        UNKNOWN_PROTOCOL: UNKNOWN_PROTOCOL
    });

    var resultNames = invertObject(resultCodes);

    const id$10 = errorResponse;
    uplinkNames[errorResponse];
    const maxSize$N = 2;
    const getFromBytes$1 = commandNamesParameter => bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      const errorCommandId = buffer.getUint8();
      const errorCode = buffer.getUint8();
      return {
        commandId: errorCommandId,
        commandName: commandNamesParameter[errorCommandId],
        errorCode,
        errorName: resultNames[errorCode]
      };
    };
    const fromBytes$11 = getFromBytes$1(uplinkNames);
    const toBytes$11 = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$N);
      buffer.setUint8(parameters.commandId);
      buffer.setUint8(parameters.errorCode);
      return toBytes$23(id$10, buffer.data);
    };

    const id$ = getBuildVersion;
    uplinkNames[getBuildVersion];
    const maxSize$M = 6;
    const fromBytes$10 = bytes => {
      if (bytes.length !== maxSize$M) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const [date, month, year, n3, n2, n1] = bytes;
      return {
        date: {
          date,
          month,
          year
        },
        version: `${n3}.${n2}.${n1}`
      };
    };
    const toBytes$10 = parameters => {
      const {
        date,
        version
      } = parameters;
      const versionParts = version.split('.').map(part => parseInt(part, 10));
      return toBytes$23(id$, [date.date, date.month, date.year, ...versionParts]);
    };

    const id$_ = getCorrectTime;
    uplinkNames[getCorrectTime];
    const maxSize$L = 9;
    const fromBytes$ = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getTimeCorrectionParameters();
    };
    const toBytes$ = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$L);
      buffer.setTimeCorrectionParameters(parameters);
      return toBytes$23(id$_, buffer.data);
    };

    const id$Z = getCriticalEvent;
    uplinkNames[getCriticalEvent];
    const maxSize$K = 9;
    const fromBytes$_ = bytes => {
      if (bytes.length !== maxSize$K) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const [event, index, year, month, date, hours, minutes, seconds, count] = bytes;
      return {
        event,
        name: criticalEventNames[event],
        index,
        date: {
          year,
          month,
          date,
          hours,
          minutes,
          seconds
        },
        count
      };
    };
    const toBytes$_ = parameters => {
      const {
        event,
        index,
        date,
        count
      } = parameters;
      return toBytes$23(id$Z, [event, index, date.year, date.month, date.date, date.hours, date.minutes, date.seconds, count]);
    };

    const id$Y = getCurrentStatusMeter;
    uplinkNames[getCurrentStatusMeter];
    const maxSize$J = 31;
    const calibrationFlagsMask = {
      calibrationEnable: 0x01,
      hardkey: 0x02,
      keyPressTest: 0x04,
      keyOpenkeyTest: 0x08,
      keyGerkonTest: 0x10,
      keyOpenKlemaTest: 0x20,
      keyOpenModuleTest: 0x40,
      keyPress2Test: 0x80
    };
    const fromBytes$Z = data => {
      const buffer = new CommandBinaryBuffer$1(data);
      const operatingSeconds = buffer.getUint32();
      const tbadVAVB = buffer.getUint32();
      const tbadImaxAll = buffer.getUint32();
      const tbadPmaxAll = buffer.getUint32();
      buffer.getUint32();
      const tbadFREQ = buffer.getUint32();
      const relayStatus = toObject(extendedCurrentValues2RelayStatusMask, buffer.getUint8());
      const statusEvent1 = buffer.getUint8();
      const statusEvent2 = buffer.getUint8();
      const calibrationFlags = toObject(calibrationFlagsMask, buffer.getUint8());
      const currentTariffs = {
        'A+': buffer.getUint8(),
        'A-': buffer.getUint8()
      };
      const isSummerTime = !!(buffer.getUint8() & 1);
      const statusEventValue = statusEvent1 | statusEvent2 << 8;
      return {
        operatingSeconds,
        tbadVAVB,
        tbadImaxAll,
        tbadPmaxAll,
        tbadFREQ,
        relayStatus,
        statusEvent: toObject(eventStatusMask, statusEventValue),
        calibrationFlags,
        currentTariffs,
        isSummerTime
      };
    };
    const toBytes$Z = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$J);
      const statusEventValue = fromObject(eventStatusMask, parameters.statusEvent);
      buffer.setUint32(parameters.operatingSeconds);
      buffer.setUint32(parameters.tbadVAVB);
      buffer.setUint32(parameters.tbadImaxAll);
      buffer.setUint32(parameters.tbadPmaxAll);
      buffer.setUint32(0);
      buffer.setUint32(parameters.tbadFREQ);
      buffer.setUint8(fromObject(extendedCurrentValues2RelayStatusMask, parameters.relayStatus));
      buffer.setUint8(statusEventValue & 0xff);
      buffer.setUint8(statusEventValue >> 8 & 0xff);
      buffer.setUint8(fromObject(calibrationFlagsMask, parameters.calibrationFlags));
      buffer.setUint8(parameters.currentTariffs['A+']);
      buffer.setUint8(parameters.currentTariffs['A-']);
      buffer.setUint8(parameters.isSummerTime ? 1 : 0);
      return toBytes$23(id$Y, buffer.data);
    };

    const id$X = getCurrentValues;
    uplinkNames[getCurrentValues];
    const maxSize$I = 32;
    const fromBytes$Y = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        powerA: buffer.getInt32(),
        iaRms: buffer.getInt32(),
        vavbRms: buffer.getInt32(),
        varA: buffer.getInt32(),
        pfA: buffer.getInt16() / 1000,
        ibRms: buffer.getInt32(),
        powerB: buffer.getInt32(),
        varB: buffer.getInt32(),
        pfB: buffer.getInt16() / 1000
      };
    };
    const toBytes$Y = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$I);
      buffer.setInt32(parameters.powerA);
      buffer.setInt32(parameters.iaRms);
      buffer.setInt32(parameters.vavbRms);
      buffer.setInt32(parameters.varA);
      buffer.setInt16(parameters.pfA * 1000);
      buffer.setInt32(parameters.ibRms);
      buffer.setInt32(parameters.powerB);
      buffer.setInt32(parameters.varB);
      buffer.setInt16(parameters.pfB * 1000);
      return toBytes$23(id$X, buffer.data);
    };

    const id$W = getDateTime;
    uplinkNames[getDateTime];
    const maxSize$H = 8;
    const fromBytes$X = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getDateTime();
    };
    const toBytes$X = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$H);
      buffer.setDateTime(parameters);
      return toBytes$23(id$W, buffer.data);
    };

    const COMMAND_SIZE$5 = 19;
    const id$V = getDayDemand;
    uplinkNames[getDayDemand];
    const fromBytes$W = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      let parameters;
      if (bytes.length === COMMAND_SIZE$5) {
        parameters = {
          date: buffer.getDate(),
          energies: buffer.getEnergies()
        };
      } else {
        parameters = {
          date: buffer.getDate(),
          ...buffer.getPackedEnergyWithType()
        };
      }
      return parameters;
    };
    const toBytes$W = parameters => {
      let size = COMMAND_SIZE$5;
      if (parameters?.energyType) {
        const energiesNumber = parameters.energies.filter(energy => energy !== null).length;
        size = DATE_SIZE$3 + PACKED_ENERGY_TYPE_SIZE + energiesNumber * ENERGY_SIZE;
      }
      const buffer = new CommandBinaryBuffer$1(size);
      buffer.setDate(parameters.date);
      buffer.setPackedEnergyWithType(parameters);
      return toBytes$23(id$V, buffer.data);
    };

    const COMMAND_SIZE$4 = 19;
    const id$U = getDayDemandExport;
    uplinkNames[getDayDemandExport];
    const fromBytes$V = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      let parameters;
      if (bytes.length === COMMAND_SIZE$4) {
        parameters = {
          date: buffer.getDate(),
          energies: buffer.getEnergies()
        };
      } else {
        parameters = {
          date: buffer.getDate(),
          ...buffer.getPackedEnergyWithType()
        };
      }
      return parameters;
    };
    const toBytes$V = parameters => {
      let size = COMMAND_SIZE$4;
      if (parameters?.energyType) {
        const energiesNumber = parameters.energies.filter(energy => energy !== null).length;
        size = DATE_SIZE$3 + PACKED_ENERGY_TYPE_SIZE + energiesNumber * ENERGY_SIZE;
      }
      const buffer = new CommandBinaryBuffer$1(size);
      buffer.setDate(parameters.date);
      buffer.setPackedEnergyWithType(parameters);
      return toBytes$23(id$U, buffer.data);
    };

    const DATE_SIZE$2 = 2;
    const ENERGY_FLAGS_SIZE$2 = 1;
    const TARIFF_FLAGS_SIZE$1 = 1;
    const MAX_TARIFFS_ENERGIES_SIZE$1 = 6 * 4 * 4;
    const id$T = getDayEnergies;
    uplinkNames[getDayEnergies];
    const maxSize$G = DATE_SIZE$2 + ENERGY_FLAGS_SIZE$2 + TARIFF_FLAGS_SIZE$1 + MAX_TARIFFS_ENERGIES_SIZE$1;
    const fromBytes$U = bytes => {
      const buffer = new CommandBinaryBuffer(bytes);
      return {
        date: buffer.getDate(),
        energies: buffer.getTariffsEnergies()
      };
    };
    const toBytes$U = parameters => {
      const buffer = new CommandBinaryBuffer(maxSize$G);
      buffer.setDate(parameters.date);
      buffer.setTariffsEnergies(parameters.energies);
      return toBytes$23(id$T, buffer.getBytesToOffset());
    };

    const id$S = getDayMaxDemand;
    uplinkNames[getDayMaxDemand];
    const maxSize$F = 27;
    const fromBytes$T = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getDayMaxDemandResponse();
    };
    const toBytes$T = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$F);
      buffer.setDayMaxDemandResponse(parameters);
      return toBytes$23(id$S, buffer.getBytesToOffset());
    };

    const id$R = getDayMaxDemandExport;
    uplinkNames[getDayMaxDemandExport];
    const maxSize$E = 27;
    const fromBytes$S = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getDayMaxDemandResponse();
    };
    const toBytes$S = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$E);
      buffer.setDayMaxDemandResponse(parameters);
      return toBytes$23(id$R, buffer.getBytesToOffset());
    };

    const id$Q = getDayMaxDemandPrevious;
    uplinkNames[getDayMaxDemandPrevious];
    const maxSize$D = 27;
    const fromBytes$R = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getDayMaxDemandResponse();
    };
    const toBytes$R = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$D);
      buffer.setDayMaxDemandResponse(parameters);
      return toBytes$23(id$Q, buffer.getBytesToOffset());
    };

    const DATE_SIZE$1 = 2;
    const ENERGY_FLAGS_SIZE$1 = 1;
    const TARIFF_FLAGS_SIZE = 1;
    const MAX_TARIFFS_ENERGIES_SIZE = 6 * 4 * (1 + 1 + 4);
    const id$P = getDayMaxPower;
    uplinkNames[getDayMaxPower];
    const maxSize$C = DATE_SIZE$1 + ENERGY_FLAGS_SIZE$1 + TARIFF_FLAGS_SIZE + MAX_TARIFFS_ENERGIES_SIZE;
    const fromBytes$Q = bytes => {
      const buffer = new CommandBinaryBuffer(bytes);
      return {
        date: buffer.getDate(),
        tariffs: buffer.getTariffsPowerMax()
      };
    };
    const toBytes$Q = parameters => {
      const buffer = new CommandBinaryBuffer(maxSize$C);
      buffer.setDate(parameters.date);
      buffer.setTariffsPowerMax(parameters.tariffs);
      return toBytes$23(id$P, buffer.getBytesToOffset());
    };

    const MAX_PERIODS_NUMBER = 8;
    const PERIODS_FINAL_BYTE = 0xff;
    const id$O = getDayProfile;
    uplinkNames[getDayProfile];
    const fromBytes$P = bytes => {
      const finalByteIndex = bytes.indexOf(PERIODS_FINAL_BYTE);
      const cleanData = finalByteIndex === -1 ? bytes : bytes.slice(0, finalByteIndex);
      return {
        periods: [...cleanData].map(CommandBinaryBuffer$1.getDayProfileFromByte)
      };
    };
    const toBytes$P = parameters => {
      const hasPeriodsFinalByte = parameters.periods.length < MAX_PERIODS_NUMBER;
      const size = parameters.periods.length + +hasPeriodsFinalByte;
      const buffer = new CommandBinaryBuffer$1(size);
      parameters.periods.forEach(period => {
        buffer.setDayProfile(period);
      });
      if (hasPeriodsFinalByte) {
        buffer.setUint8(PERIODS_FINAL_BYTE);
      }
      return toBytes$23(id$O, buffer.data);
    };

    const ADDITIONAL_HOUR = 25;
    const getRecordIndex = (hours, minutes, periodMin) => Math.trunc((hours * 60 + minutes) / periodMin);
    const getLastSummerHourIndex = periodMin => getRecordIndex(ADDITIONAL_HOUR, 0, periodMin);
    const energyFromWord = (word, index, periodMin) => {
      if (word === 0xffff) {
        return null;
      }
      const indexLastSummerRecord = getLastSummerHourIndex(periodMin);
      if (index === indexLastSummerRecord) {
        return {
          lastSummerHour: word >> 8 & 0xff
        };
      }
      return periodMin === 60 ? {
        energy: word
      } : {
        tariff: word >> 14 & 0x03,
        energy: word & 0x3fff
      };
    };
    const energyToWord = data => {
      if (data === null) {
        return 0xffff;
      }
      const {
        energy,
        tariff,
        lastSummerHour
      } = data;
      if (lastSummerHour) {
        return lastSummerHour << 8 | 0xff;
      }
      return tariff ? tariff << 14 | energy & 0x3fff : energy;
    };
    const energyFromBinary = function (bytes, offset) {
      let periodMin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 30;
      return bytes.reduce((collector, value, index) => {
        collector.push(energyFromWord(value, (offset ?? 0) + index, periodMin));
        return collector;
      }, []);
    };
    const energyToBinary = energies => energies.reduce((collector, value) => {
      collector.push(energyToWord(value));
      return collector;
    }, []);
    const voltageFromWord = (word, index, periodMin) => {
      if (word === 0xffff) {
        return 0xffff;
      }
      const indexLastSummerRecord = getLastSummerHourIndex(periodMin);
      return index === indexLastSummerRecord ? {
        lastSummerHour: word >> 8 & 0xff
      } : {
        voltage: word
      };
    };
    const voltageToWord = _ref => {
      let {
        voltage,
        lastSummerHour
      } = _ref;
      if (lastSummerHour) {
        return lastSummerHour << 8 | 0xff;
      }
      return voltage;
    };
    const voltageFromBinary = function (bytes, offset) {
      let periodMin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 30;
      return bytes.reduce((collector, value, index) => {
        collector.push(voltageFromWord(value, (offset ?? 0) + index, periodMin));
        return collector;
      }, []);
    };
    const voltageToBinary = energies => energies.reduce((collector, value) => {
      collector.push(voltageToWord(value));
      return collector;
    }, []);

    const id$N = getDemand;
    uplinkNames[getDemand];
    const fromBytes$O = bytes => {
      if (!bytes || bytes.length < maxSize$1r) {
        throw new Error('Invalid uplink GetDemand byte length.');
      }
      const buffer = new CommandBinaryBuffer$1(bytes);
      const parameters = buffer.getDemand();
      if (bytes.length !== maxSize$1r + 2 * parameters.count) {
        throw new Error('Invalid uplink GetDemand demands byte length.');
      }
      const demandsBytes = new Array(parameters.count).fill(0).map(() => buffer.getUint16());
      const isEnergiesDemand = parameters.energyType === A_PLUS || parameters.energyType === A_MINUS;
      parameters.demands = isEnergiesDemand ? energyFromBinary(demandsBytes, parameters.firstIndex, parameters.period) : voltageFromBinary(demandsBytes, parameters.firstIndex, parameters.period);
      return parameters;
    };
    const toBytes$O = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$1r + parameters.count * 2);
      buffer.setDemand(parameters);
      if (parameters.energyType === A_PLUS || parameters.energyType === A_MINUS) {
        energyToBinary(parameters.demands).forEach(value => buffer.setUint16(value));
      } else {
        voltageToBinary(parameters.demands).forEach(value => buffer.setUint16(value));
      }
      return toBytes$23(id$N, buffer.data);
    };

    const id$M = getDeviceId;
    uplinkNames[getDeviceId];
    const maxSize$B = 8;
    const fromBytes$N = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getDeviceId();
    };
    const toBytes$N = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$B);
      buffer.setDeviceId(parameters);
      return toBytes$23(id$M, buffer.data);
    };

    const id$L = getDeviceType;
    uplinkNames[getDeviceType];
    const maxSize$A = 9;
    const fromBytes$M = data => {
      const buffer = new CommandBinaryBuffer$1(data);
      return buffer.getDeviceType();
    };
    const toBytes$M = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$A);
      buffer.setDeviceType(parameters);
      return toBytes$23(id$L, buffer.data);
    };

    const id$K = getDisplayParam;
    uplinkNames[getDisplayParam];
    const fromBytes$L = bytes => {
      const [displayMode, ...order] = bytes;
      return {
        displayMode,
        order
      };
    };
    const toBytes$L = parameters => toBytes$23(id$K, [parameters.displayMode, ...parameters.order]);

    const COMMAND_SIZE$3 = 16;
    const id$J = getEnergy;
    uplinkNames[getEnergy];
    const fromBytes$K = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      let parameters;
      if (bytes.length === COMMAND_SIZE$3) {
        parameters = {
          energies: buffer.getEnergies()
        };
      } else {
        parameters = buffer.getPackedEnergyWithType();
      }
      return parameters;
    };
    const toBytes$K = parameters => {
      let size = COMMAND_SIZE$3;
      if (parameters?.energyType) {
        const energiesNumber = parameters.energies.filter(energy => energy !== null).length;
        size = PACKED_ENERGY_TYPE_SIZE + energiesNumber * ENERGY_SIZE;
      }
      const buffer = new CommandBinaryBuffer$1(size);
      buffer.setPackedEnergyWithType(parameters);
      return toBytes$23(id$J, buffer.data);
    };

    const COMMAND_SIZE$2 = 19;
    const id$I = getEnergyDayPrevious;
    uplinkNames[getEnergyDayPrevious];
    const fromBytes$J = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      let parameters;
      if (bytes.length === COMMAND_SIZE$2) {
        parameters = {
          date: buffer.getDate(),
          energies: buffer.getEnergies()
        };
      } else {
        parameters = {
          date: buffer.getDate(),
          ...buffer.getPackedEnergyWithType()
        };
      }
      return parameters;
    };
    const toBytes$J = parameters => {
      const buffer = new CommandBinaryBuffer$1(getPackedEnergiesWithDateSize(parameters));
      buffer.setDate(parameters.date);
      buffer.setPackedEnergyWithType(parameters);
      return toBytes$23(id$I, buffer.data);
    };

    const COMMAND_SIZE$1 = 16;
    const id$H = getEnergyExport;
    uplinkNames[getEnergyExport];
    const fromBytes$I = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      let parameters;
      if (bytes.length === COMMAND_SIZE$1) {
        parameters = {
          energies: buffer.getEnergies()
        };
      } else {
        parameters = buffer.getPackedEnergyWithType();
      }
      return parameters;
    };
    const toBytes$I = parameters => {
      let size = COMMAND_SIZE$1;
      if (parameters?.energyType) {
        const energiesNumber = parameters.energies.filter(energy => energy !== null).length;
        size = PACKED_ENERGY_TYPE_SIZE + energiesNumber * ENERGY_SIZE;
      }
      const buffer = new CommandBinaryBuffer$1(size);
      buffer.setPackedEnergyWithType(parameters);
      return toBytes$23(id$H, buffer.data);
    };

    const COMMAND_SIZE = 19;
    const id$G = getEnergyExportDayPrevious;
    uplinkNames[getEnergyExportDayPrevious];
    const fromBytes$H = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      let parameters;
      if (bytes.length === COMMAND_SIZE) {
        parameters = {
          date: buffer.getDate(),
          energies: buffer.getEnergies()
        };
      } else {
        parameters = {
          date: buffer.getDate(),
          ...buffer.getPackedEnergyWithType()
        };
      }
      return parameters;
    };
    const toBytes$H = parameters => {
      const buffer = new CommandBinaryBuffer$1(getPackedEnergiesWithDateSize(parameters));
      buffer.setDate(parameters.date);
      buffer.setPackedEnergyWithType(parameters);
      return toBytes$23(id$G, buffer.data);
    };

    const BODY_WITHOUT_EVENTS_SIZE = 3 + 1;
    const EVENT_SIZE = 4;
    const id$F = getEvents;
    uplinkNames[getEvents];
    const maxSize$z = BODY_WITHOUT_EVENTS_SIZE + 255 * EVENT_SIZE;
    const getFromBytes = BinaryBufferConstructor => bytes => {
      if (bytes.length > maxSize$z) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new BinaryBufferConstructor(bytes);
      const date = buffer.getDate();
      const eventsNumber = buffer.getUint8();
      const events = [];
      while (!buffer.isEmpty) {
        events.push(buffer.getEvent());
      }
      return {
        date,
        eventsNumber,
        events
      };
    };
    const getToBytes = BinaryBufferConstructor => parameters => {
      const buffer = new BinaryBufferConstructor(maxSize$z);
      buffer.setDate(parameters.date);
      buffer.setUint8(parameters.eventsNumber);
      for (const event of parameters.events) {
        buffer.setEvent(event);
      }
      return toBytes$23(id$F, buffer.getBytesToOffset());
    };
    const fromBytes$G = getFromBytes(CommandBinaryBuffer$1);
    const toBytes$G = getToBytes(CommandBinaryBuffer$1);

    const COMMAND_BODY_SIZE = 14;
    const OLD_COMMAND_BODY_SIZE = 20;
    const id$E = getEventsCounters;
    uplinkNames[getEventsCounters];
    const fromBytes$F = bytes => {
      if (bytes.length !== COMMAND_BODY_SIZE && bytes.length !== OLD_COMMAND_BODY_SIZE) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      const buffer = new CommandBinaryBuffer$1(bytes);
      const restart = buffer.getUint16();
      const powerOff = buffer.getUint16();
      const localParametersChange = buffer.getUint16();
      const remoteParametersChange = buffer.getUint16();
      const accessError = buffer.getUint16();
      const accessClosed = buffer.getUint16();
      const setClock = buffer.getUint16();
      return {
        accessClosed,
        accessError,
        localParametersChange,
        remoteParametersChange,
        powerOff,
        restart,
        setClock
      };
    };
    const toBytes$F = parameters => {
      const buffer = new CommandBinaryBuffer$1(COMMAND_BODY_SIZE);
      buffer.setUint16(parameters.restart);
      buffer.setUint16(parameters.powerOff);
      buffer.setUint16(parameters.localParametersChange);
      buffer.setUint16(parameters.remoteParametersChange);
      buffer.setUint16(parameters.accessError);
      buffer.setUint16(parameters.accessClosed);
      buffer.setUint16(parameters.setClock);
      return toBytes$23(id$E, buffer.data);
    };

    const id$D = getEventStatus;
    uplinkNames[getEventStatus];
    const maxSize$y = 2;
    const fromBytes$E = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes, true);
      return buffer.getEventStatus();
    };
    const toBytes$E = eventStatus => {
      const buffer = new CommandBinaryBuffer$1(maxSize$y, true);
      buffer.setEventStatus(eventStatus);
      return toBytes$23(id$D, buffer.data);
    };

    const id$C = getExtendedCurrentValues;
    uplinkNames[getExtendedCurrentValues];
    const maxSize$x = 4;
    const fromBytes$D = data => {
      const buffer = new CommandBinaryBuffer$1(data);
      return {
        temperature: buffer.getInt16(),
        frequency: buffer.getInt16()
      };
    };
    const toBytes$D = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$x);
      buffer.setInt16(parameters.temperature);
      buffer.setInt16(parameters.frequency);
      return toBytes$23(id$C, buffer.data);
    };

    const id$B = getExtendedCurrentValues2;
    uplinkNames[getExtendedCurrentValues2];
    const maxSize$w = 7;
    const fromBytes$C = data => {
      const buffer = new CommandBinaryBuffer$1(data);
      return buffer.getExtendedCurrentValues2();
    };
    const toBytes$C = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$w);
      buffer.setExtendedCurrentValues2(parameters);
      return toBytes$23(id$B, buffer.data);
    };

    const id$A = getHalfHourDemand;
    uplinkNames[getHalfHourDemand];
    const fromBytes$B = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      const hasDst = bytes.length > MIN_HALF_HOUR_COMMAND_SIZE;
      const date = buffer.getDate();
      const periods = buffer.getEnergyPeriods(hasDst ? MAX_HALF_HOUR_PERIODS : MIN_HALF_HOUR_PERIODS);
      if (hasDst) {
        return {
          date,
          periods,
          dstHour: buffer.getUint8()
        };
      }
      return {
        date,
        periods
      };
    };
    const toBytes$B = parameters => {
      const buffer = new CommandBinaryBuffer$1(parameters.periods.length > MIN_HALF_HOUR_PERIODS ? MAX_HALF_HOUR_COMMAND_SIZE : MIN_HALF_HOUR_COMMAND_SIZE);
      buffer.setDate(parameters.date);
      buffer.setEnergyPeriods(parameters.periods);
      if (parameters.dstHour) {
        buffer.setUint8(parameters.dstHour);
      }
      return toBytes$23(id$A, buffer.data);
    };

    const id$z = getHalfHourDemandExport;
    uplinkNames[getHalfHourDemandExport];
    const fromBytes$A = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      const hasDst = bytes.length > MIN_HALF_HOUR_COMMAND_SIZE;
      const date = buffer.getDate();
      const periods = buffer.getEnergyPeriods(hasDst ? MAX_HALF_HOUR_PERIODS : MIN_HALF_HOUR_PERIODS);
      if (hasDst) {
        return {
          date,
          periods,
          dstHour: buffer.getUint8()
        };
      }
      return {
        date,
        periods
      };
    };
    const toBytes$A = parameters => {
      const buffer = new CommandBinaryBuffer$1(parameters.periods.length > MIN_HALF_HOUR_PERIODS ? MAX_HALF_HOUR_COMMAND_SIZE : MIN_HALF_HOUR_COMMAND_SIZE);
      buffer.setDate(parameters.date);
      buffer.setEnergyPeriods(parameters.periods);
      if (parameters.dstHour) {
        buffer.setUint8(parameters.dstHour);
      }
      return toBytes$23(id$z, buffer.data);
    };

    const id$y = getHalfHourDemandPrevious;
    uplinkNames[getHalfHourDemandPrevious];
    const fromBytes$z = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      const hasDst = bytes.length > MIN_HALF_HOUR_COMMAND_SIZE;
      const date = buffer.getDate();
      const periods = buffer.getEnergyPeriods(hasDst ? MAX_HALF_HOUR_PERIODS : MIN_HALF_HOUR_PERIODS);
      if (hasDst) {
        return {
          date,
          periods,
          dstHour: buffer.getUint8()
        };
      }
      return {
        date,
        periods
      };
    };
    const toBytes$z = parameters => {
      const buffer = new CommandBinaryBuffer$1(parameters.periods.length > MIN_HALF_HOUR_PERIODS ? MAX_HALF_HOUR_COMMAND_SIZE : MIN_HALF_HOUR_COMMAND_SIZE);
      buffer.setDate(parameters.date);
      buffer.setEnergyPeriods(parameters.periods);
      if (parameters.dstHour) {
        buffer.setUint8(parameters.dstHour);
      }
      return toBytes$23(id$y, buffer.data);
    };

    const DATE_SIZE = 2;
    const ENERGY_FLAGS_SIZE = 1;
    const START_HALFHOUR_SIZE = 1;
    const HALFHOURS_NUMBER_SIZE = 1;
    const MAX_HALFHOURS_ENERGY_SIZE = 247;
    const id$x = getHalfhoursEnergies;
    uplinkNames[getHalfhoursEnergies];
    const maxSize$v = DATE_SIZE + ENERGY_FLAGS_SIZE + START_HALFHOUR_SIZE + HALFHOURS_NUMBER_SIZE + MAX_HALFHOURS_ENERGY_SIZE;
    const fromBytes$y = bytes => {
      const buffer = new CommandBinaryBuffer(bytes);
      const date = buffer.getDate();
      const energiesFlags = buffer.getEnergiesFlags();
      const firstHalfhour = buffer.getUint8();
      const halfhoursNumber = buffer.getUint8();
      return {
        date,
        firstHalfhour,
        halfhoursNumber,
        energies: buffer.getHalfhoursEnergies(energiesFlags, halfhoursNumber)
      };
    };
    const toBytes$y = parameters => {
      const buffer = new CommandBinaryBuffer(maxSize$v);
      const {
        date,
        firstHalfhour,
        halfhoursNumber,
        energies
      } = parameters;
      buffer.setDate(date);
      buffer.setEnergiesFlags(energies);
      buffer.setUint8(firstHalfhour);
      buffer.setUint8(halfhoursNumber);
      buffer.setHalfhoursEnergies(energies);
      return toBytes$23(id$x, buffer.getBytesToOffset());
    };

    const id$w = getMagneticFieldThreshold;
    uplinkNames[getMagneticFieldThreshold];
    const maxSize$u = 10;
    const fromBytes$x = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        induction: buffer.getUint16(),
        threshold: buffer.getUint16(),
        inductionCoefficient: buffer.getUint16() / 100,
        reserved: buffer.getUint32()
      };
    };
    const toBytes$x = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$u);
      buffer.setUint16(parameters.induction);
      buffer.setUint16(parameters.threshold);
      buffer.setUint16(parameters.inductionCoefficient * 100);
      buffer.setUint32(parameters.reserved);
      return toBytes$23(id$w, buffer.data);
    };

    const id$v = getMeterInfo;
    uplinkNames[getMeterInfo];
    const fromBytes$w = _ref => {
      let [ten] = _ref;
      return {
        ten
      };
    };
    const toBytes$w = _ref2 => {
      let {
        ten
      } = _ref2;
      return toBytes$23(id$v, [ten]);
    };

    const id$u = getMonthDemand;
    uplinkNames[getMonthDemand];
    const maxSize$t = 18;
    const fromBytes$v = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        year: buffer.getUint8(),
        month: buffer.getUint8(),
        energies: buffer.getEnergies()
      };
    };
    const toBytes$v = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$t);
      buffer.setUint8(parameters.year);
      buffer.setUint8(parameters.month);
      buffer.setEnergies(parameters.energies);
      return toBytes$23(id$u, buffer.data);
    };

    const id$t = getMonthDemandExport;
    uplinkNames[getMonthDemandExport];
    const maxSize$s = 18;
    const fromBytes$u = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        year: buffer.getUint8(),
        month: buffer.getUint8(),
        energies: buffer.getEnergies()
      };
    };
    const toBytes$u = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$s);
      buffer.setUint8(parameters.year);
      buffer.setUint8(parameters.month);
      buffer.setEnergies(parameters.energies);
      return toBytes$23(id$t, buffer.data);
    };

    const id$s = getMonthMaxDemand;
    uplinkNames[getMonthMaxDemand];
    const maxSize$r = 2 + TARIFF_NUMBER$1 * 7;
    const fromBytes$t = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        year: buffer.getUint8(),
        month: buffer.getUint8(),
        tariffs: buffer.getMonthMaxPowerByTariffs()
      };
    };
    const toBytes$t = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$r);
      buffer.setUint8(parameters.year);
      buffer.setUint8(parameters.month);
      buffer.setMonthMaxPowerByTariffs(parameters.tariffs);
      return toBytes$23(id$s, buffer.data);
    };

    const id$r = getMonthMaxDemandExport;
    uplinkNames[getMonthMaxDemandExport];
    const maxSize$q = 2 + TARIFF_NUMBER$1 * 7;
    const fromBytes$s = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        year: buffer.getUint8(),
        month: buffer.getUint8(),
        tariffs: buffer.getMonthMaxPowerByTariffs()
      };
    };
    const toBytes$s = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$q);
      buffer.setUint8(parameters.year);
      buffer.setUint8(parameters.month);
      buffer.setMonthMaxPowerByTariffs(parameters.tariffs);
      return toBytes$23(id$r, buffer.data);
    };

    const id$q = getOperatorParametersExtended3;
    uplinkNames[getOperatorParametersExtended3];
    const maxSize$p = 17;
    const fromBytes$r = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getOperatorParametersExtended3();
    };
    const toBytes$r = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$p);
      buffer.setOperatorParametersExtended3(parameters);
      return toBytes$23(id$q, buffer.data);
    };

    const id$p = getOperatorParameters;
    uplinkNames[getOperatorParameters];
    const maxSize$o = OPERATOR_PARAMETERS_SIZE;
    const fromBytes$q = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getOperatorParameters();
    };
    const toBytes$q = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$o);
      buffer.setOperatorParameters(parameters);
      return toBytes$23(id$p, buffer.data);
    };

    const id$o = getRatePlanInfo;
    uplinkNames[getRatePlanInfo];
    const maxSize$n = 1 + TARIFF_PLAN_SIZE * 2;
    const fromBytes$p = bytes => {
      if (bytes.length !== maxSize$n) {
        throw new Error('Invalid getRatePlanInfo data size.');
      }
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        tariffTable: buffer.getUint8(),
        activePlan: buffer.getTariffPlan(),
        passivePlan: buffer.getTariffPlan()
      };
    };
    const toBytes$p = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$n);
      buffer.setUint8(parameters.tariffTable);
      buffer.setTariffPlan(parameters.activePlan);
      buffer.setTariffPlan(parameters.passivePlan);
      return toBytes$23(id$o, buffer.data);
    };

    const id$n = getSaldo;
    uplinkNames[getSaldo];
    const maxSize$m = 29;
    const fromBytes$o = bytes => {
      if (bytes.length !== maxSize$m) {
        throw new Error('Invalid getSaldo data size.');
      }
      const buffer = new CommandBinaryBuffer$1(bytes);
      return {
        currentSaldo: buffer.getInt32(),
        count: buffer.getUint8(),
        energy: new Array(4).fill(0).map(() => buffer.getInt32()),
        beginSaldoOfPeriod: buffer.getInt32(),
        date: {
          month: buffer.getUint8(),
          date: buffer.getUint8(),
          hours: buffer.getUint8(),
          minutes: buffer.getUint8()
        }
      };
    };
    const toBytes$o = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$m);
      buffer.setInt32(parameters.currentSaldo);
      buffer.setUint8(parameters.count);
      parameters.energy.forEach(value => buffer.setInt32(value));
      buffer.setInt32(parameters.beginSaldoOfPeriod);
      buffer.setUint8(parameters.date.month);
      buffer.setUint8(parameters.date.date);
      buffer.setUint8(parameters.date.hours);
      buffer.setUint8(parameters.date.minutes);
      return toBytes$23(id$n, buffer.data);
    };

    const id$m = getSaldoParameters;
    uplinkNames[getSaldoParameters];
    const maxSize$l = 37;
    const fromBytes$n = bytes => {
      if (bytes.length !== maxSize$l) {
        throw new Error('Invalid getSaldoParameters data size.');
      }
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getSaldoParameters();
    };
    const toBytes$n = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$l);
      buffer.setSaldoParameters(parameters);
      return toBytes$23(id$m, buffer.data);
    };

    const id$l = getSeasonProfile;
    uplinkNames[getSeasonProfile];
    const maxSize$k = 9;
    const fromBytes$m = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getSeasonProfile();
    };
    const toBytes$m = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$k);
      buffer.setSeasonProfile(parameters);
      return toBytes$23(id$l, buffer.data);
    };

    const id$k = getSpecialDay;
    uplinkNames[getSpecialDay];
    const maxSize$j = 4;
    const fromBytes$l = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      return buffer.getSpecialDay();
    };
    const toBytes$l = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$j);
      buffer.setSpecialDay(parameters);
      return toBytes$23(id$k, buffer.data);
    };

    const id$j = getVersion;
    uplinkNames[getVersion];
    const fromBytes$k = bytes => ({
      version: String.fromCharCode.apply(null, [...bytes])
    });
    const toBytes$k = parameters => {
      const version = parameters.version.split('').map(char => char.charCodeAt(0));
      return toBytes$23(id$j, version);
    };

    const id$i = prepareRatePlan;
    uplinkNames[prepareRatePlan];
    const maxSize$i = 0;
    const fromBytes$j = bytes => {
      if (bytes.length !== maxSize$i) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$j = () => toBytes$23(id$i);

    const id$h = resetPowerMaxDay;
    uplinkNames[resetPowerMaxDay];
    const maxSize$h = 0;
    const fromBytes$i = bytes => {
      if (bytes.length !== maxSize$h) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$i = () => toBytes$23(id$h);

    const id$g = resetPowerMaxMonth;
    uplinkNames[resetPowerMaxMonth];
    const maxSize$g = 0;
    const fromBytes$h = bytes => {
      if (bytes.length !== maxSize$g) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$h = () => toBytes$23(id$g);

    const id$f = runTariffPlan;
    uplinkNames[runTariffPlan];
    const maxSize$f = 0;
    const fromBytes$g = bytes => {
      if (bytes.length !== maxSize$f) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$g = () => toBytes$23(id$f);

    const id$e = setAccessKey;
    uplinkNames[setAccessKey];
    const maxSize$e = 0;
    const fromBytes$f = bytes => {
      if (bytes.length !== maxSize$e) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$f = () => toBytes$23(id$e);

    const id$d = setCorrectDateTime;
    uplinkNames[setCorrectDateTime];
    const maxSize$d = 0;
    const fromBytes$e = bytes => {
      if (bytes.length !== maxSize$d) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$e = () => toBytes$23(id$d);

    const id$c = setCorrectTime;
    uplinkNames[setCorrectTime];
    const maxSize$c = 0;
    const fromBytes$d = bytes => {
      if (bytes.length !== maxSize$c) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$d = () => toBytes$23(id$c);

    const id$b = setDateTime;
    uplinkNames[setDateTime];
    const maxSize$b = 0;
    const fromBytes$c = bytes => {
      if (bytes.length !== maxSize$b) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$c = () => toBytes$23(id$b);

    const id$a = setDayProfile;
    uplinkNames[setDayProfile];
    const maxSize$a = 0;
    const fromBytes$b = bytes => {
      if (bytes.length !== maxSize$a) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$b = () => toBytes$23(id$a);

    const id$9 = setDisplayParam;
    uplinkNames[setDisplayParam];
    const maxSize$9 = 0;
    const fromBytes$a = bytes => {
      if (bytes.length !== maxSize$9) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$a = () => toBytes$23(id$9);

    const id$8 = setOperatorParametersExtended3;
    uplinkNames[setOperatorParametersExtended3];
    const maxSize$8 = 0;
    const fromBytes$9 = bytes => {
      if (bytes.length !== maxSize$8) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$9 = () => toBytes$23(id$8);

    const id$7 = setOperatorParameters;
    uplinkNames[setOperatorParameters];
    const maxSize$7 = 0;
    const fromBytes$8 = bytes => {
      if (bytes.length !== maxSize$7) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$8 = () => toBytes$23(id$7);

    const id$6 = setSaldo;
    uplinkNames[setSaldo];
    const maxSize$6 = 0;
    const fromBytes$7 = bytes => {
      if (bytes.length !== maxSize$6) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$7 = () => toBytes$23(id$6);

    const id$5 = setSaldoParameters;
    uplinkNames[setSaldoParameters];
    const maxSize$5 = 0;
    const fromBytes$6 = bytes => {
      if (bytes.length !== maxSize$5) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$6 = () => toBytes$23(id$5);

    const id$4 = setSeasonProfile;
    uplinkNames[setSeasonProfile];
    const maxSize$4 = 0;
    const fromBytes$5 = bytes => {
      if (bytes.length !== maxSize$4) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$5 = () => toBytes$23(id$4);

    const id$3 = setSpecialDay;
    uplinkNames[setSpecialDay];
    const maxSize$3 = 0;
    const fromBytes$4 = bytes => {
      if (bytes.length !== maxSize$3) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$4 = () => toBytes$23(id$3);

    const id$2 = setSpecialOperation;
    uplinkNames[setSpecialOperation];
    const maxSize$2 = 1;
    const fromBytes$3 = bytes => {
      const buffer = new CommandBinaryBuffer$1(bytes);
      const flags = buffer.getUint8();
      const electroMagneticIndication = !!(flags & 1);
      const magneticIndication = !!(flags & 2);
      return {
        electroMagneticIndication,
        magneticIndication
      };
    };
    const toBytes$3 = parameters => {
      const buffer = new CommandBinaryBuffer$1(maxSize$2);
      let flags = 0;
      if (parameters.electroMagneticIndication) {
        flags |= 1;
      }
      if (parameters.magneticIndication) {
        flags |= 2;
      }
      buffer.setUint8(flags);
      return toBytes$23(id$2, buffer.data);
    };

    const id$1 = turnRelayOff;
    uplinkNames[turnRelayOff];
    const maxSize$1 = 0;
    const fromBytes$2 = bytes => {
      if (bytes.length !== maxSize$1) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$2 = () => toBytes$23(id$1);

    const id = turnRelayOn;
    uplinkNames[turnRelayOn];
    const maxSize = 0;
    const fromBytes$1 = bytes => {
      if (bytes.length !== maxSize) {
        throw new Error(`Wrong buffer size: ${bytes.length}.`);
      }
      return {};
    };
    const toBytes$1 = () => toBytes$23(id);

    const toBytesMap = {};
    const fromBytesMap = {};
    const nameMap = uplinkNames;
    const fromBytes = getFromBytes$2(fromBytesMap, nameMap);
    const toBytes = getToBytes$1(toBytesMap);
    toBytesMap[id$11] = toBytes$12;
    toBytesMap[id$10] = toBytes$11;
    toBytesMap[id$] = toBytes$10;
    toBytesMap[id$_] = toBytes$;
    toBytesMap[id$Z] = toBytes$_;
    toBytesMap[id$Y] = toBytes$Z;
    toBytesMap[id$X] = toBytes$Y;
    toBytesMap[id$W] = toBytes$X;
    toBytesMap[id$V] = toBytes$W;
    toBytesMap[id$U] = toBytes$V;
    toBytesMap[id$T] = toBytes$U;
    toBytesMap[id$S] = toBytes$T;
    toBytesMap[id$R] = toBytes$S;
    toBytesMap[id$Q] = toBytes$R;
    toBytesMap[id$P] = toBytes$Q;
    toBytesMap[id$O] = toBytes$P;
    toBytesMap[id$N] = toBytes$O;
    toBytesMap[id$M] = toBytes$N;
    toBytesMap[id$L] = toBytes$M;
    toBytesMap[id$K] = toBytes$L;
    toBytesMap[id$J] = toBytes$K;
    toBytesMap[id$I] = toBytes$J;
    toBytesMap[id$H] = toBytes$I;
    toBytesMap[id$G] = toBytes$H;
    toBytesMap[id$F] = toBytes$G;
    toBytesMap[id$E] = toBytes$F;
    toBytesMap[id$D] = toBytes$E;
    toBytesMap[id$C] = toBytes$D;
    toBytesMap[id$B] = toBytes$C;
    toBytesMap[id$A] = toBytes$B;
    toBytesMap[id$z] = toBytes$A;
    toBytesMap[id$y] = toBytes$z;
    toBytesMap[id$x] = toBytes$y;
    toBytesMap[id$w] = toBytes$x;
    toBytesMap[id$v] = toBytes$w;
    toBytesMap[id$u] = toBytes$v;
    toBytesMap[id$t] = toBytes$u;
    toBytesMap[id$s] = toBytes$t;
    toBytesMap[id$r] = toBytes$s;
    toBytesMap[id$q] = toBytes$r;
    toBytesMap[id$p] = toBytes$q;
    toBytesMap[id$o] = toBytes$p;
    toBytesMap[id$n] = toBytes$o;
    toBytesMap[id$m] = toBytes$n;
    toBytesMap[id$l] = toBytes$m;
    toBytesMap[id$k] = toBytes$l;
    toBytesMap[id$j] = toBytes$k;
    toBytesMap[id$i] = toBytes$j;
    toBytesMap[id$h] = toBytes$i;
    toBytesMap[id$g] = toBytes$h;
    toBytesMap[id$f] = toBytes$g;
    toBytesMap[id$e] = toBytes$f;
    toBytesMap[id$d] = toBytes$e;
    toBytesMap[id$c] = toBytes$d;
    toBytesMap[id$b] = toBytes$c;
    toBytesMap[id$a] = toBytes$b;
    toBytesMap[id$9] = toBytes$a;
    toBytesMap[id$8] = toBytes$9;
    toBytesMap[id$7] = toBytes$8;
    toBytesMap[id$6] = toBytes$7;
    toBytesMap[id$5] = toBytes$6;
    toBytesMap[id$4] = toBytes$5;
    toBytesMap[id$3] = toBytes$4;
    toBytesMap[id$2] = toBytes$3;
    toBytesMap[id$1] = toBytes$2;
    toBytesMap[id] = toBytes$1;
    fromBytesMap[id$11] = fromBytes$12;
    fromBytesMap[id$10] = fromBytes$11;
    fromBytesMap[id$] = fromBytes$10;
    fromBytesMap[id$_] = fromBytes$;
    fromBytesMap[id$Z] = fromBytes$_;
    fromBytesMap[id$Y] = fromBytes$Z;
    fromBytesMap[id$X] = fromBytes$Y;
    fromBytesMap[id$W] = fromBytes$X;
    fromBytesMap[id$V] = fromBytes$W;
    fromBytesMap[id$U] = fromBytes$V;
    fromBytesMap[id$T] = fromBytes$U;
    fromBytesMap[id$S] = fromBytes$T;
    fromBytesMap[id$R] = fromBytes$S;
    fromBytesMap[id$Q] = fromBytes$R;
    fromBytesMap[id$P] = fromBytes$Q;
    fromBytesMap[id$O] = fromBytes$P;
    fromBytesMap[id$N] = fromBytes$O;
    fromBytesMap[id$M] = fromBytes$N;
    fromBytesMap[id$L] = fromBytes$M;
    fromBytesMap[id$K] = fromBytes$L;
    fromBytesMap[id$J] = fromBytes$K;
    fromBytesMap[id$I] = fromBytes$J;
    fromBytesMap[id$H] = fromBytes$I;
    fromBytesMap[id$G] = fromBytes$H;
    fromBytesMap[id$F] = fromBytes$G;
    fromBytesMap[id$E] = fromBytes$F;
    fromBytesMap[id$D] = fromBytes$E;
    fromBytesMap[id$C] = fromBytes$D;
    fromBytesMap[id$B] = fromBytes$C;
    fromBytesMap[id$A] = fromBytes$B;
    fromBytesMap[id$z] = fromBytes$A;
    fromBytesMap[id$y] = fromBytes$z;
    fromBytesMap[id$x] = fromBytes$y;
    fromBytesMap[id$w] = fromBytes$x;
    fromBytesMap[id$v] = fromBytes$w;
    fromBytesMap[id$u] = fromBytes$v;
    fromBytesMap[id$t] = fromBytes$u;
    fromBytesMap[id$s] = fromBytes$t;
    fromBytesMap[id$r] = fromBytes$s;
    fromBytesMap[id$q] = fromBytes$r;
    fromBytesMap[id$p] = fromBytes$q;
    fromBytesMap[id$o] = fromBytes$p;
    fromBytesMap[id$n] = fromBytes$o;
    fromBytesMap[id$m] = fromBytes$n;
    fromBytesMap[id$l] = fromBytes$m;
    fromBytesMap[id$k] = fromBytes$l;
    fromBytesMap[id$j] = fromBytes$k;
    fromBytesMap[id$i] = fromBytes$j;
    fromBytesMap[id$h] = fromBytes$i;
    fromBytesMap[id$g] = fromBytes$h;
    fromBytesMap[id$f] = fromBytes$g;
    fromBytesMap[id$e] = fromBytes$f;
    fromBytesMap[id$d] = fromBytes$e;
    fromBytesMap[id$c] = fromBytes$d;
    fromBytesMap[id$b] = fromBytes$c;
    fromBytesMap[id$a] = fromBytes$b;
    fromBytesMap[id$9] = fromBytes$a;
    fromBytesMap[id$8] = fromBytes$9;
    fromBytesMap[id$7] = fromBytes$8;
    fromBytesMap[id$6] = fromBytes$7;
    fromBytesMap[id$5] = fromBytes$6;
    fromBytesMap[id$4] = fromBytes$5;
    fromBytesMap[id$3] = fromBytes$4;
    fromBytesMap[id$2] = fromBytes$3;
    fromBytesMap[id$1] = fromBytes$2;
    fromBytesMap[id] = fromBytes$1;

    var uplink = /*#__PURE__*/Object.freeze({
        __proto__: null,
        fromBytes: fromBytes,
        fromBytesMap: fromBytesMap,
        nameMap: nameMap,
        toBytes: toBytes,
        toBytesMap: toBytesMap
    });

    var mtxMessage = /*#__PURE__*/Object.freeze({
        __proto__: null,
        downlink: downlink,
        uplink: uplink
    });

    /**
     * Data segment wrapper around an MTX message.
     */


    // 0b10010001 (segmentIndex: 1, segmentsNumber: 1, isLast: true)
    const SINGLE_SEGMENT_FLAG = 0x91;
    const DATA_SEGMENT_COMMAND_ID = 0x1e;
    const get = bytes => {
      // check if it is a DataSegment command
      if (bytes[0] !== DATA_SEGMENT_COMMAND_ID) {
        return {};
      }

      // DataSegment command size
      const size = bytes[1];

      // segment metadata
      const flag = bytes[3];

      // payload
      const data = bytes.slice(4, size + 2);

      // if the mtx message is unencrypted, the device sets the LRC to 0
      // no need to validate for now
      // const expectedLrc = calculateLrc(bytes.slice(0, size + 2));
      // const actualLrc = bytes[size + 2];

      // just a single data segment (without lrc validation)
      if (flag === SINGLE_SEGMENT_FLAG) {
        return data;
      }
      return null;
    };
    const set = bytes => {
      const body = [DATA_SEGMENT_COMMAND_ID, bytes.length + 2, 0, SINGLE_SEGMENT_FLAG, ...bytes];
      return [...body, calculateLrc(body)];
    };

    // export
    message = mtxMessage;
    getDataSegment = get;
    setDataSegment = set;

})();
//#endregion
